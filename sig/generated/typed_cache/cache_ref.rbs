# Generated from lib/typed_cache/cache_ref.rb with RBS::Inline

module TypedCache
  # A monadic wrapper for cached values that provides safe access with rich error context.
  # All operations return Either[Error, Snapshot[V]] to provide detailed information about
  # cache operations and the source of values.
  #
  # @rbs generic V
  class CacheRef[V]
    attr_reader store: Store[V]

    attr_reader key: CacheKey

    # : (Store[V], CacheKey) -> void
    def initialize: (Store[V], CacheKey) -> void

    # Gets a value from the cache as a snapshot
    # : -> either[Error, Snapshot[maybe[V]]]
    def read: () -> either[Error, Snapshot[maybe[V]]]

    # Sets a value in the cache and returns it as an updated snapshot
    # : (V) -> either[Error, Snapshot[V]]
    def write: (V) -> either[Error, Snapshot[V]]

    # Deletes the value from the cache and returns the deleted value as a snapshot
    # : -> either[Error, maybe[V]]
    def delete: () -> either[Error, maybe[V]]

    # Fetches a value from cache, computing and storing it if not found
    # The snapshot indicates whether the value came from cache or was computed
    # : () { -> V? } -> either[Error, Snapshot[maybe[V]]]
    def fetch: () { () -> V? } -> either[Error, Snapshot[maybe[V]]]

    # Checks if the cache contains a value for this key
    # : -> bool
    def present?: () -> bool

    # Checks if the cache is empty for this key
    # : -> bool
    def empty?: () -> bool

    # Maps over the cached value if it exists, preserving snapshot metadata
    # : [R] () { (V) -> R } -> either[Error, Snapshot[R]]
    def map: [R] () { (V) -> R } -> either[Error, Snapshot[R]]

    # Updates the cached value using the provided block
    # Returns the updated value as a snapshot with source=:updated
    # : () { (V) -> V? } -> either[Error, Snapshot[maybe[V]]]
    def update: () { (V) -> V? } -> either[Error, Snapshot[maybe[V]]]

    # Computes and caches a value if the cache is currently empty
    # Returns existing snapshot if present, computed snapshot if cache miss, error otherwise
    # : () { -> V? } -> either[Error, Snapshot[maybe[V]]]
    def compute_if_absent: () { () -> V? } -> either[Error, Snapshot[maybe[V]]]

    # Convenience method to work with the snapshot directly
    # : [R] () { (Snapshot[V]) -> R } -> either[Error, R]
    def with_snapshot: [R] () { (Snapshot[V]) -> R } -> either[Error, R]

    # Convenience method to work with just the value (losing snapshot context)
    # : [R] () { (V) -> R } -> either[Error, R]
    def with: [R] () { (V) -> R } -> either[Error, R]

    # @rbs () -> String
    def to_s: () -> String

    # @rbs () -> String
    def inspect: () -> String
  end
end
