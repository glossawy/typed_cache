# Generated from lib/typed_cache/backends/memory.rb with RBS::Inline

module TypedCache
  class MemoryStoreRegistry
    include Singleton

    extend Forwardable

    # : -> void
    def initialize: () -> void
  end

  module Backends
    # A type-safe memory store implementation with built-in namespacing
    # @rbs generic V
    class Memory[V]
      include Backend[V]

      interface _HashLike[K, V]
        def []: (K) -> V?

        def []=: (K, V) -> V

        def delete: (K) -> V?

        def key?: (K) -> bool

        def keys: () -> Array[K]
      end

      type hash_like[K, V] = _HashLike[K, V]

      # @private
      # @rbs generic V
      class Entry[V] < Dry::Struct
        attr_accessor expires_at: Time

        attr_reader value: V

        # @rbs (value: V, expires_in: Integer) -> Entry[V]
        def self.expiring: (value: V, expires_in: Integer) -> Entry[V]

        # @rbs () -> bool
        def expired?: () -> bool
      end

      attr_reader namespace: Namespace

      attr_reader ttl: Namespace

      attr_reader backing_store: hash_like[CacheKey, Entry[V]]

      # : (Namespace, shared: bool, ttl: Integer) -> void
      def initialize: (Namespace, shared: bool, ttl: Integer) -> void

      # @rbs override
      # : (cache_key) -> either[Error, Snapshot[V]]
      def get: ...

      # @rbs override
      # : (cache_key, V) -> either[Error, Snapshot[V]]
      def set: ...

      # @rbs override
      # : (cache_key) -> either[Error, Snapshot[V]]
      def delete: ...

      # @rbs override
      # : (cache_key) -> bool
      def key?: ...

      # @rbs override
      # : -> maybe[Error]
      def clear: ...

      # @rbs override
      # : -> String
      def store_type: ...

      # : -> Integer
      def size: () -> Integer

      # : -> Array[CacheKey]
      def keys: () -> Array[CacheKey]

      private

      # : -> Hash[CacheKey, Entry[V]]
      def namespaced_entries: () -> Hash[CacheKey, Entry[V]]

      # : -> void
      def purge_expired_keys: () -> void
    end
  end
end
