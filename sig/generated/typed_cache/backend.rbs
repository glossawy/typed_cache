# Generated from lib/typed_cache/backend.rb with RBS::Inline

module TypedCache
  # Marker mixin for concrete cache back-ends.
  # A Backend *is* a Store, but the reverse is not necessarily true (decorators also
  # include Store). By tagging back-ends with this module we can type-check and
  # register them separately from decorators.
  #
  # Back-ends should *not* assume they wrap another store â€“ they are the leaf nodes
  # that actually persist data.
  # @rbs generic V
  module Backend[V]
    type cache_key = String | CacheKey

    interface _Backend[V]
      def read: (cache_key, **top) -> V?

      def read_multi: (Array[cache_key], **top) -> Hash[cache_key, V]

      def write: (cache_key, V, **top) -> V

      def write_multi: (Hash[cache_key, V], **top) -> Hash[cache_key, V]

      def delete: (cache_key) -> V?

      def key?: (cache_key) -> bool

      def clear: () -> void

      def fetch: (cache_key, **top) { () -> V? } -> V?

      def fetch_multi: (Array[cache_key], **top) { (cache_key) -> V? } -> Hash[cache_key, V]
    end

    include _Backend[V]

    # @rbs override
    # @rbs (cache_key, **top) -> V?
    def read: ...

    # @rbs override
    # @rbs (Array[cache_key], **top) -> Hash[cache_key, V]
    def read_multi: ...

    # @rbs override
    # @rbs (cache_key, V, **top) -> V
    def write: ...

    # @rbs override
    # @rbs (Hash[cache_key, V], **top) -> Hash[cache_key, V]
    def write_multi: ...

    # @rbs override
    # @rbs (cache_key) -> V?
    def delete: ...

    # @rbs override
    # @rbs (cache_key) -> bool
    def key?: ...

    # @rbs override
    # @rbs () -> void
    def clear: ...

    # @rbs override
    # @rbs (cache_key, **top) { () -> V? } -> V?
    def fetch: ...

    # @rbs override
    # @rbs (Array[cache_key], **top) { (cache_key) -> V? } -> Hash[cache_key, V]
    def fetch_multi: ...

    # @rbs override
    # @rbs () -> String
    def to_s: ...

    # @rbs override
    # @rbs () -> String
    def inspect: ...
  end

  type backend[V] = Backend::_Backend[V]
end
