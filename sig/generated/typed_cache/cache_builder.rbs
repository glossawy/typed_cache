# Generated from lib/typed_cache/cache_builder.rb with RBS::Inline

module TypedCache
  class BackendConfig < Dry::Struct
  end

  class DecoratorConfig < Dry::Struct
  end

  class CacheDefinition
    include _CacheDefinition

    type instrumenter_source = :default | :dry | :rails | Instrumenter

    attr_reader backend_config: BackendConfig?

    attr_reader decorator_configs: Array[DecoratorConfig]

    attr_reader instrumenter_source: instrumenter_source

    # @rbs (?BackendConfig?, ?Array[DecoratorConfig], ?instrumenter_source) -> void
    def initialize: (?BackendConfig?, ?Array[DecoratorConfig], ?instrumenter_source) -> void

    # @rbs override
    # @rbs (Symbol, *untyped, **untyped) -> self
    def with_backend: ...

    # @rbs override
    # @rbs (Symbol, **untyped) -> self
    def with_decorator: ...

    # @rbs override
    # @rbs (instrumenter_source) -> self
    def with_instrumentation: ...
  end

  class CacheBuilder
    include _CacheBuilder

    include _CacheDefinition

    # @rbs (?_CacheDefinition, ?Registry[backend[untyped]], ?Registry[decorator[untyped]]) -> void
    def initialize: (?_CacheDefinition, ?Registry[backend[untyped]], ?Registry[decorator[untyped]]) -> void

    # Builds the cache using the given namespace, defaulting to the root namespace
    # @rbs (?Namespace) -> either[Error, Store[untyped]]
    def build: (?Namespace) -> either[Error, Store[untyped]]

    # @rbs (Namespace) -> Store[untyped]
    def build!: (Namespace) -> Store[untyped]

    # Constructs only a typed backend from the registry without a Store wrapper
    # @rbs () -> either[Error, Backend[untyped]]
    def build_backend: () -> either[Error, Backend[untyped]]

    # Constructs only a typed backend from the registry without a Store wrapper,
    # raises an error if the backend cannot be constructed
    #
    # @rbs () -> Backend[untyped]
    def build_backend!: () -> Backend[untyped]

    # Familiar Ruby fluent interface - always succeeds
    # Invalid configurations are caught during build()
    # @rbs (Symbol, *untyped, **untyped) -> self
    def with_backend: (Symbol, *untyped, **untyped) -> self

    # Adds an arbitrary decorator by registry key
    # @rbs (Symbol) -> self
    def with_decorator: (Symbol) -> self

    # Adds instrumentation using the specified strategy.
    # @rbs (instrumenter_source) -> either[Error, self]
    def with_instrumentation: (instrumenter_source) -> either[Error, self]

    private

    # @rbs (Namespace) -> either[Error, Store[V]]
    def validate_and_build: (Namespace) -> either[Error, Store[V]]

    # @rbs (Namespace) -> either[Error, Backend[untyped]]
    def create_backend: (Namespace) -> either[Error, Backend[untyped]]

    # @rbs (Backend[untyped]) -> either[Error, Decorator[untyped]]
    def apply_decorators: (Backend[untyped]) -> either[Error, Decorator[untyped]]

    # @rbs (Backend[untyped]) -> either[Error, Backend[untyped]]
    def apply_instrumentation: (Backend[untyped]) -> either[Error, Backend[untyped]]
  end
end
