{
  "$schema": "http://json-schema.org/draft-07/schema",
  "title": "RuboCop configuration schema",
  "description": "Schema for RuboCop configuration files (e.g. .rubocop.yml), intended for helping IDEs provide autocompletion and validation.",
  "type": "object",
  "additionalProperties": false,
  "definitions": {
    "inherit_mode": {
      "type": "object",
      "minProperties": 1,
      "propertyNames": {
        "enum": ["merge", "override"]
      },
      "additionalProperties": {
        "type": "array",
        "minItems": 1,
        "items": {
          "type": "string"
        }
      }
    },
    "listOfFiles": {
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "severity": {
      "type": "string",
      "enum": ["info", "refactor", "convention", "warning", "error", "fatal"]
    },
    "stringOrStrings": {
      "oneOf": [
        {
          "type": "string"
        },
        {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      ]
    },
    "attributeName": {
      "type": "string",
      "pattern": "^[A-Z][A-Za-z]*$"
    }
  },
  "properties": {
    "inherit_from": {
      "$ref": "#/definitions/stringOrStrings"
    },
    "inherit_gem": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/stringOrStrings"
      }
    },
    "require": {
      "$ref": "#/definitions/stringOrStrings"
    },
    "inherit_mode": {
      "$ref": "#/definitions/inherit_mode",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "merge": {
          "type": "array",
          "description": "Default: Exclude"
        }
      }
    },
    "AllCops": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: node_modules/**/*, tmp/**/*, vendor/**/*, .git/**/*"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.rb, **/*.arb, **/*.axlsx, **/*.builder, **/*.fcgi, **/*.gemfile, **/*.gemspec, **/*.god, **/*.jb, **/*.jbuilder, **/*.mspec, **/*.opal, **/*.pluginspec, **/*.podspec, **/*.rabl, **/*.rake, **/*.rbuild, **/*.rbw, **/*.rbx, **/*.ru, **/*.ruby, **/*.schema, **/*.spec, **/*.thor, **/*.watchr, **/.irbrc, **/.pryrc, **/.simplecov, **/buildfile, **/Appraisals, **/Berksfile, **/Brewfile, **/Buildfile, **/Capfile, **/Cheffile, **/Dangerfile, **/Deliverfile, **/Fastfile, **/*Fastfile, **/Gemfile, **/Guardfile, **/Jarfile, **/Mavenfile, **/Podfile, **/Puppetfile, **/Rakefile, **/rakefile, **/Schemafile, **/Snapfile, **/Steepfile, **/Thorfile, **/Vagabondfile, **/Vagrantfile"
        },
        "NewCops": {
          "enum": ["enable", "disable"],
          "type": "string",
          "description": "Default: pending"
        },
        "EnabledByDefault": {
          "type": "boolean",
          "description": "Default: false"
        },
        "DisabledByDefault": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SuggestExtensions": {
          "type": "boolean",
          "description": "Default: {\"rubocop-rails\"=>[\"rails\"], \"rubocop-rspec\"=>[\"rspec\", \"rspec-rails\"], \"rubocop-minitest\"=>[\"minitest\"], \"rubocop-sequel\"=>[\"sequel\"], \"rubocop-rake\"=>[\"rake\"], \"rubocop-graphql\"=>[\"graphql\"], \"rubocop-capybara\"=>[\"capybara\"], \"rubocop-factory_bot\"=>[\"factory_bot\", \"factory_bot_rails\"], \"rubocop-rspec_rails\"=>[\"rspec-rails\"]}"
        },
        "TargetRubyVersion": {
          "type": "number"
        },
        "StyleGuideBaseURL": {
          "type": "string",
          "description": "Default: https://rubystyle.guide"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Enabled": {
          "type": "boolean"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "RubyInterpreters": {
          "type": "array",
          "description": "Default: ruby, macruby, rake, jruby, rbx"
        },
        "DefaultFormatter": {
          "type": "string",
          "description": "Default: progress"
        },
        "DisplayCopNames": {
          "type": "boolean",
          "description": "Default: true"
        },
        "DisplayStyleGuide": {
          "type": "boolean",
          "description": "Default: false"
        },
        "DocumentationBaseURL": {
          "type": "string",
          "description": "Default: https://docs.rubocop.org/rubocop"
        },
        "DocumentationExtension": {
          "type": "string",
          "description": "Default: .html"
        },
        "ExtraDetails": {
          "type": "boolean",
          "description": "Default: false"
        },
        "StyleGuideCopsOnly": {
          "type": "boolean",
          "description": "Default: false"
        },
        "UseCache": {
          "type": "boolean",
          "description": "Default: true"
        },
        "MaxFilesInCache": {
          "type": "integer",
          "description": "Default: 20000"
        },
        "CacheRootDirectory": {},
        "AllowSymlinksInCacheRootDirectory": {
          "type": "boolean",
          "description": "Default: false"
        },
        "ParserEngine": {
          "type": "string",
          "description": "Default: parser_whitequark"
        },
        "ActiveSupportExtensionsEnabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "StringLiteralsFrozenByDefault": {}
      },
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      }
    },
    "Bundler": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "'Bundler' department"
    },
    "Bundler/DuplicatedGem": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemfile, **/Gemfile, **/gems.rb"
        },
        "Severity": {
          "$ref": "#/definitions/severity",
          "description": "Default: warning"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "A Gem's requirements should be listed only once in a Gemfile."
    },
    "Bundler/DuplicatedGroup": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemfile, **/Gemfile, **/gems.rb"
        },
        "Severity": {
          "$ref": "#/definitions/severity",
          "description": "Default: warning"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "A Gem group, or a set of groups, should be listed only once in a Gemfile.\n\nFor example, if the values of `source`, `git`, `platforms`, or `path` surrounding `group` are different, no offense will be registered:\n\nplatforms :ruby do   group :default do     gem 'openssl'   end end  platforms :jruby do   group :default do     gem 'jruby-openssl'   end end"
    },
    "Bundler/GemComment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemfile, **/Gemfile, **/gems.rb"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "IgnoredGems": {
          "type": "array",
          "description": "Default: []"
        },
        "OnlyFor": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Each gem in the Gemfile should have a comment explaining its purpose in the project, or the reason for its version or source.\n\nThe optional \"OnlyFor\" configuration array can be used to only register offenses when the gems use certain options or have version specifiers.\n\nWhen \"version_specifiers\" is included, a comment will be enforced if the gem has any version specifier.\n\nWhen \"restrictive_version_specifiers\" is included, a comment will be enforced if the gem has a version specifier that holds back the version of the gem.\n\nFor any other value in the array, a comment will be enforced for a gem if an option by the same name is present. A useful use case is to enforce a comment when using options that change the source of a gem:\n\n - bitbucket\n\n - gist\n\n - git\n\n - github\n\n - source\n\nFor a full list of options supported by bundler, see https://bundler.io/man/gemfile.5.html ."
    },
    "Bundler/GemFilename": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/Gemfile, **/gems.rb, **/Gemfile.lock, **/gems.locked"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["Gemfile", "gems.rb"],
          "description": "Default: Gemfile"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: Gemfile, gems.rb"
        }
      },
      "description": "Verifies that a project contains Gemfile or gems.rb file and correct associated lock file based on the configuration."
    },
    "Bundler/GemVersion": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemfile, **/Gemfile, **/gems.rb"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["required", "forbidden"],
          "description": "Default: required"
        },
        "AllowedGems": {
          "type": "array",
          "description": "Default: []"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: required, forbidden"
        }
      },
      "description": "Enforce that Gem version specifications or a commit reference (branch, ref, or tag) are either required or forbidden."
    },
    "Bundler/InsecureProtocolSource": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemfile, **/Gemfile, **/gems.rb"
        },
        "Severity": {
          "$ref": "#/definitions/severity",
          "description": "Default: warning"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowHttpProtocol": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "Passing symbol arguments to `source` (e.g. `source :rubygems`) is deprecated because they default to using HTTP requests. Instead, specify `'https://rubygems.org'` if possible, or `'http://rubygems.org'` if not.\n\nWhen autocorrecting, this cop will replace symbol arguments with `'https://rubygems.org'`.\n\nThis cop will not replace existing sources that use `http://`. This may be necessary where HTTPS is not available. For example, where using an internal gem server via an intranet, or where HTTPS is prohibited. However, you should strongly prefer `https://` where possible, as it is more secure.\n\nIf you don't allow `http://`, please set `false` to `AllowHttpProtocol`. This option is `true` by default for safe autocorrection."
    },
    "Bundler/OrderedGems": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemfile, **/Gemfile, **/gems.rb"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "TreatCommentsAsGroupSeparators": {
          "type": "boolean",
          "description": "Default: true"
        },
        "ConsiderPunctuation": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Gems should be alphabetically sorted within groups."
    },
    "Gemspec": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "'Gemspec' department"
    },
    "Gemspec/AddRuntimeDependency": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemspec"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://github.com/rubygems/rubygems/issues/7799#issuecomment-2192720316"
        }
      },
      "description": "Prefer `add_dependency` over `add_runtime_dependency` as the latter is considered soft-deprecated."
    },
    "Gemspec/DependencyVersion": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemspec"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["required", "forbidden"],
          "description": "Default: required"
        },
        "AllowedGems": {
          "type": "array",
          "description": "Default: []"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: required, forbidden"
        }
      },
      "description": "Enforce that gem dependency version specifications or a commit reference (branch, ref, or tag) are either required or forbidden."
    },
    "Gemspec/DeprecatedAttributeAssignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemspec"
        },
        "Severity": {
          "$ref": "#/definitions/severity",
          "description": "Default: warning"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks that deprecated attributes are not set in a gemspec file. Removing deprecated attributes allows the user to receive smaller packed gems."
    },
    "Gemspec/DevelopmentDependencies": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemspec, **/Gemfile, **/gems.rb"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["Gemfile", "gems.rb", "gemspec"],
          "description": "Default: Gemfile"
        },
        "AllowedGems": {
          "type": "array",
          "description": "Default: []"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: Gemfile, gems.rb, gemspec"
        }
      },
      "description": "Enforce that development dependencies for a gem are specified in `Gemfile`, rather than in the `gemspec` using `add_development_dependency`. Alternatively, using `EnforcedStyle: gemspec`, enforce that all dependencies are specified in `gemspec`, rather than in `Gemfile`."
    },
    "Gemspec/DuplicatedAssignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemspec"
        },
        "Severity": {
          "$ref": "#/definitions/severity",
          "description": "Default: warning"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "An attribute assignment method calls should be listed only once in a gemspec.\n\nAssigning to an attribute with the same name using `spec.foo =` will be an unintended usage. On the other hand, duplication of methods such as `spec.requirements`, `spec.add_runtime_dependency`, and others are permitted because it is the intended use of appending values."
    },
    "Gemspec/OrderedDependencies": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemspec"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "TreatCommentsAsGroupSeparators": {
          "type": "boolean",
          "description": "Default: true"
        },
        "ConsiderPunctuation": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Dependencies in the gemspec should be alphabetically sorted."
    },
    "Gemspec/RequireMFA": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemspec"
        },
        "Severity": {
          "$ref": "#/definitions/severity",
          "description": "Default: warning"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "array",
          "description": "Default: https://guides.rubygems.org/mfa-requirement-opt-in/"
        }
      },
      "description": "Requires a gemspec to have `rubygems_mfa_required` metadata set.\n\nThis setting tells RubyGems that MFA (Multi-Factor Authentication) is required for accounts to be able perform privileged operations, such as (see RubyGems' documentation for the full list of privileged operations):\n\n - gem push\n\n - gem yank\n\n - gem owner --add/remove\n\n - adding or removing owners using gem ownership page\n\nThis helps make your gem more secure, as users can be more confident that gem updates were pushed by maintainers."
    },
    "Gemspec/RequiredRubyVersion": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemspec"
        },
        "Severity": {
          "$ref": "#/definitions/severity",
          "description": "Default: warning"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks that `required_ruby_version` in a gemspec file is set to a valid value (non-blank) and matches `TargetRubyVersion` as set in RuboCop's configuration for the gem.\n\nThis ensures that RuboCop is using the same Ruby version as the gem."
    },
    "Gemspec/RubyVersionGlobalsUsage": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemspec"
        },
        "Severity": {
          "$ref": "#/definitions/severity",
          "description": "Default: warning"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks that `RUBY_VERSION` constant is not used in gemspec. Using `RUBY_VERSION` is dangerous because value of the constant is determined by `rake release`. It's possible to have dependency based on ruby version used to execute `rake release` and not user's ruby version."
    },
    "Layout": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "'Layout' department"
    },
    "Layout/AccessModifierIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["outdent", "indent"],
          "description": "Default: indent"
        },
        "IndentationWidth": {
          "type": "integer",
          "description": "Default: <none>"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: outdent, indent"
        }
      },
      "description": "Bare access modifiers (those not applying to specific methods) should be indented as deep as method definitions, or as deep as the `class`/`module` keyword, depending on configuration."
    },
    "Layout/ArgumentAlignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["with_first_argument", "with_fixed_indentation"],
          "description": "Default: with_first_argument"
        },
        "IndentationWidth": {
          "type": "integer",
          "description": "Default: <none>"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: with_first_argument, with_fixed_indentation"
        }
      },
      "description": "Check that the arguments on a multi-line method call are aligned."
    },
    "Layout/ArrayAlignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["with_first_element", "with_fixed_indentation"],
          "description": "Default: with_first_element"
        },
        "IndentationWidth": {
          "type": "integer",
          "description": "Default: <none>"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: with_first_element, with_fixed_indentation"
        }
      },
      "description": "Check that the elements of a multi-line array literal are aligned."
    },
    "Layout/AssignmentIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "IndentationWidth": {
          "type": "integer",
          "description": "Default: <none>"
        }
      },
      "description": "Checks the indentation of the first line of the right-hand-side of a multi-line assignment.\n\nThe indentation of the remaining lines can be corrected with other cops such as `Layout/IndentationConsistency` and `Layout/EndAlignment`."
    },
    "Layout/BeginEndAlignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity",
          "description": "Default: warning"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyleAlignWith": {
          "enum": ["start_of_line", "begin"],
          "description": "Default: start_of_line"
        },
        "SupportedStylesAlignWith": {
          "type": "array",
          "description": "Default: start_of_line, begin"
        }
      },
      "description": "Checks whether the end keyword of `begin` is aligned properly.\n\nTwo modes are supported through the `EnforcedStyleAlignWith` configuration parameter. If it's set to `start_of_line` (which is the default), the `end` shall be aligned with the start of the line where the `begin` keyword is. If it's set to `begin`, the `end` shall be aligned with the `begin` keyword.\n\n`Layout/EndAlignment` cop aligns with keywords (e.g. `if`, `while`, `case`) by default. On the other hand, `||= begin` that this cop targets tends to align with the start of the line, it defaults to `EnforcedStyleAlignWith: start_of_line`. These style can be configured by each cop."
    },
    "Layout/BlockAlignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyleAlignWith": {
          "enum": ["either", "start_of_block", "start_of_line"],
          "description": "Default: either"
        },
        "SupportedStylesAlignWith": {
          "type": "array",
          "description": "Default: either, start_of_block, start_of_line"
        }
      },
      "description": "Checks whether the end keywords are aligned properly for do end blocks.\n\nThree modes are supported through the `EnforcedStyleAlignWith` configuration parameter:\n\n`start_of_block` : the `end` shall be aligned with the start of the line where the `do` appeared.\n\n`start_of_line` : the `end` shall be aligned with the start of the line where the expression started.\n\n`either` (which is the default) : the `end` is allowed to be in either location. The autocorrect will default to `start_of_line`."
    },
    "Layout/BlockEndNewline": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks whether the end statement of a do..end block is on its own line."
    },
    "Layout/CaseIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["case", "end"],
          "description": "Default: case"
        },
        "IndentOneStep": {
          "type": "boolean",
          "description": "Default: false"
        },
        "IndentationWidth": {
          "type": "integer",
          "description": "Default: <none>"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: case, end"
        }
      },
      "description": "Checks how the `when` and ``in``s of a `case` expression are indented in relation to its `case` or `end` keyword.\n\nIt will register a separate offense for each misaligned `when` and `in`."
    },
    "Layout/ClassStructure": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Categories": {
          "description": "Default: {\"module_inclusion\" ⇒ [\"include\", \"prepend\", \"extend\"]}"
        },
        "ExpectedOrder": {
          "type": "array",
          "description": "Default: module_inclusion, constants, public_class_methods, initializer, public_methods, protected_methods, private_methods"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks if the code style follows the `ExpectedOrder` configuration:\n\n`Categories` allows us to map macro names into a category.\n\nConsider an example of code style that covers the following order:\n\n - Module inclusion (include, prepend, extend)\n\n - Constants\n\n - Associations (has_one, has_many)\n\n - Public attribute macros (attr_accessor, attr_writer, attr_reader)\n\n - Other macros (validates, validate)\n\n - Public class methods\n\n - Initializer\n\n - Public instance methods\n\n - Protected attribute macros (attr_accessor, attr_writer, attr_reader)\n\n - Protected instance methods\n\n - Private attribute macros (attr_accessor, attr_writer, attr_reader)\n\n - Private instance methods\n\nYou can configure the following order:\n\n Layout/ClassStructure:    ExpectedOrder:      - module_inclusion      - constants      - association      - public_attribute_macros      - public_delegate      - macros      - public_class_methods      - initializer      - public_methods      - protected_attribute_macros      - protected_methods      - private_attribute_macros      - private_delegate      - private_methods\n\nInstead of putting all literals in the expected order, is also possible to group categories of macros. Visibility levels are handled automatically.\n\n Layout/ClassStructure:    Categories:      association:        - has_many        - has_one      attribute_macros:        - attr_accessor        - attr_reader        - attr_writer      macros:        - validates        - validate      module_inclusion:        - include        - prepend        - extend"
    },
    "Layout/ClosingHeredocIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks the indentation of here document closings."
    },
    "Layout/ClosingParenthesisIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks the indentation of hanging closing parentheses in method calls, method definitions, and grouped expressions. A hanging closing parenthesis means `)` preceded by a line break."
    },
    "Layout/CommentIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowForAlignment": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks the indentation of comments."
    },
    "Layout/ConditionPosition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for conditions that are not on the same line as if/while/until."
    },
    "Layout/DefEndAlignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity",
          "description": "Default: warning"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyleAlignWith": {
          "enum": ["start_of_line", "def"],
          "description": "Default: start_of_line"
        },
        "SupportedStylesAlignWith": {
          "type": "array",
          "description": "Default: start_of_line, def"
        }
      },
      "description": "Checks whether the end keywords of method definitions are aligned properly.\n\nTwo modes are supported through the EnforcedStyleAlignWith configuration parameter. If it's set to `start_of_line` (which is the default), the `end` shall be aligned with the start of the line where the `def` keyword is. If it's set to `def`, the `end` shall be aligned with the `def` keyword."
    },
    "Layout/DotPosition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["leading", "trailing"],
          "description": "Default: leading"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: leading, trailing"
        }
      },
      "description": "Checks the . position in multi-line method calls."
    },
    "Layout/ElseAlignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks the alignment of else keywords. Normally they should be aligned with an if/unless/while/until/begin/def/rescue keyword, but there are special cases when they should follow the same rules as the alignment of end."
    },
    "Layout/EmptyComment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowBorderComment": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowMarginComment": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AutoCorrect": {
          "type": "string",
          "description": "Default: contextual"
        }
      },
      "description": "Checks empty comment."
    },
    "Layout/EmptyLineAfterGuardClause": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Enforces empty line after guard clause.\n\nThis cop allows `# :nocov:` directive after guard clause because SimpleCov excludes code from the coverage report by wrapping it in `# :nocov:`:\n\ndef foo   # :nocov:   return if condition   # :nocov:   bar end\n\nRefer to SimpleCov's documentation for more details: https://github.com/simplecov-ruby/simplecov#ignoringskipping-code"
    },
    "Layout/EmptyLineAfterMagicComment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for a newline after the final magic comment."
    },
    "Layout/EmptyLineAfterMultilineCondition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "array",
          "description": "Default: https://github.com/airbnb/ruby#multiline-if-newline"
        }
      },
      "description": "Enforces empty line after multiline condition."
    },
    "Layout/EmptyLineBetweenDefs": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EmptyLineBetweenMethodDefs": {
          "type": "boolean",
          "description": "Default: true"
        },
        "EmptyLineBetweenClassDefs": {
          "type": "boolean",
          "description": "Default: true"
        },
        "EmptyLineBetweenModuleDefs": {
          "type": "boolean",
          "description": "Default: true"
        },
        "DefLikeMacros": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowAdjacentOneLineDefs": {
          "type": "boolean",
          "description": "Default: true"
        },
        "NumberOfEmptyLines": {
          "type": "integer",
          "description": "Default: 1"
        }
      },
      "description": "Checks whether class/module/method definitions are separated by one or more empty lines.\n\n`NumberOfEmptyLines` can be an integer (default is 1) or an array (e.g. [1, 2]) to specify a minimum and maximum number of empty lines permitted.\n\n`AllowAdjacentOneLineDefs` configures whether adjacent one-line definitions are considered an offense."
    },
    "Layout/EmptyLines": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for two or more consecutive blank lines."
    },
    "Layout/EmptyLinesAroundAccessModifier": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["around", "only_before"],
          "description": "Default: around"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: around, only_before"
        },
        "Reference": {
          "type": "array",
          "description": "Default: https://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html#follow-the-coding-conventions"
        }
      },
      "description": "Access modifiers should be surrounded by blank lines."
    },
    "Layout/EmptyLinesAroundArguments": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks if empty lines exist around the arguments of a method invocation."
    },
    "Layout/EmptyLinesAroundAttributeAccessor": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowAliasSyntax": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: alias_method, public, protected, private"
        }
      },
      "description": "Checks for a newline after an attribute accessor or a group of them. `alias` syntax and `alias_method`, `public`, `protected`, and `private` methods are allowed by default. These are customizable with `AllowAliasSyntax` and `AllowedMethods` options."
    },
    "Layout/EmptyLinesAroundBeginBody": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks if empty lines exist around the bodies of begin-end blocks."
    },
    "Layout/EmptyLinesAroundBlockBody": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["empty_lines", "no_empty_lines"],
          "description": "Default: no_empty_lines"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: empty_lines, no_empty_lines"
        }
      },
      "description": "Checks if empty lines around the bodies of blocks match the configuration."
    },
    "Layout/EmptyLinesAroundClassBody": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "empty_lines",
            "empty_lines_except_namespace",
            "empty_lines_special",
            "no_empty_lines",
            "beginning_only",
            "ending_only"
          ],
          "description": "Default: no_empty_lines"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: empty_lines, empty_lines_except_namespace, empty_lines_special, no_empty_lines, beginning_only, ending_only"
        }
      },
      "description": "Checks if empty lines around the bodies of classes match the configuration."
    },
    "Layout/EmptyLinesAroundExceptionHandlingKeywords": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks if empty lines exist around the bodies of `begin` sections. This cop doesn't check empty lines at `begin` body beginning/end and around method definition body. `Layout/EmptyLinesAroundBeginBody` or `Layout/EmptyLinesAroundMethodBody` can be used for this purpose."
    },
    "Layout/EmptyLinesAroundMethodBody": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks if empty lines exist around the bodies of methods."
    },
    "Layout/EmptyLinesAroundModuleBody": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "empty_lines",
            "empty_lines_except_namespace",
            "empty_lines_special",
            "no_empty_lines"
          ],
          "description": "Default: no_empty_lines"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: empty_lines, empty_lines_except_namespace, empty_lines_special, no_empty_lines"
        }
      },
      "description": "Checks if empty lines around the bodies of modules match the configuration."
    },
    "Layout/EndAlignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity",
          "description": "Default: warning"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyleAlignWith": {
          "enum": ["keyword", "variable", "start_of_line"],
          "description": "Default: keyword"
        },
        "SupportedStylesAlignWith": {
          "type": "array",
          "description": "Default: keyword, variable, start_of_line"
        }
      },
      "description": "Checks whether the end keywords are aligned properly.\n\nThree modes are supported through the `EnforcedStyleAlignWith` configuration parameter:\n\nIf it's set to `keyword` (which is the default), the `end` shall be aligned with the start of the keyword (if, class, etc.).\n\nIf it's set to `variable` the `end` shall be aligned with the left-hand-side of the variable assignment, if there is one.\n\nIf it's set to `start_of_line`, the `end` shall be aligned with the start of the line where the matching keyword appears.\n\nThis `Layout/EndAlignment` cop aligns with keywords (e.g. `if`, `while`, `case`) by default. On the other hand, `Layout/BeginEndAlignment` cop aligns with `EnforcedStyleAlignWith: start_of_line` by default due to `||= begin` tends to align with the start of the line. `Layout/DefEndAlignment` cop also aligns with `EnforcedStyleAlignWith: start_of_line` by default. These style can be configured by each cop."
    },
    "Layout/EndOfLine": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["native", "lf", "crlf"],
          "description": "Default: native"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: native, lf, crlf"
        }
      },
      "description": "Checks for Windows-style line endings in the source code."
    },
    "Layout/ExtraSpacing": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowForAlignment": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowBeforeTrailingComments": {
          "type": "boolean",
          "description": "Default: false"
        },
        "ForceEqualSignAlignment": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for extra/unnecessary whitespace."
    },
    "Layout/FirstArgumentIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "consistent",
            "consistent_relative_to_receiver",
            "special_for_inner_method_call",
            "special_for_inner_method_call_in_parentheses"
          ],
          "description": "Default: special_for_inner_method_call_in_parentheses"
        },
        "IndentationWidth": {
          "type": "integer",
          "description": "Default: <none>"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: consistent, consistent_relative_to_receiver, special_for_inner_method_call, special_for_inner_method_call_in_parentheses"
        }
      },
      "description": "Checks the indentation of the first argument in a method call. Arguments after the first one are checked by `Layout/ArgumentAlignment`, not by this cop.\n\nFor indenting the first parameter of method _definitions_, check out `Layout/FirstParameterIndentation`.\n\nThis cop will respect `Layout/ArgumentAlignment` and will not work when `EnforcedStyle: with_fixed_indentation` is specified for `Layout/ArgumentAlignment`."
    },
    "Layout/FirstArrayElementIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "special_inside_parentheses",
            "consistent",
            "align_brackets"
          ],
          "description": "Default: special_inside_parentheses"
        },
        "IndentationWidth": {
          "type": "integer",
          "description": "Default: <none>"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: special_inside_parentheses, consistent, align_brackets"
        }
      },
      "description": "Checks the indentation of the first element in an array literal where the opening bracket and the first element are on separate lines. The other elements' indentations are handled by `Layout/ArrayAlignment` cop.\n\nThis cop will respect `Layout/ArrayAlignment` and will not work when `EnforcedStyle: with_fixed_indentation` is specified for `Layout/ArrayAlignment`.\n\nBy default, array literals that are arguments in a method call with parentheses, and where the opening square bracket of the array is on the same line as the opening parenthesis of the method call, shall have their first element indented one step (two spaces) more than the position inside the opening parenthesis.\n\nOther array literals shall have their first element indented one step more than the start of the line where the opening square bracket is.\n\nThis default style is called 'special_inside_parentheses'. Alternative styles are 'consistent' and 'align_brackets'. Here are examples:"
    },
    "Layout/FirstArrayElementLineBreak": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowMultilineFinalElement": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for a line break before the first element in a multi-line array."
    },
    "Layout/FirstHashElementIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["special_inside_parentheses", "consistent", "align_braces"],
          "description": "Default: special_inside_parentheses"
        },
        "IndentationWidth": {
          "type": "integer",
          "description": "Default: <none>"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: special_inside_parentheses, consistent, align_braces"
        }
      },
      "description": "Checks the indentation of the first key in a hash literal where the opening brace and the first key are on separate lines. The other keys' indentations are handled by the HashAlignment cop.\n\nBy default, `Hash` literals that are arguments in a method call with parentheses, and where the opening curly brace of the hash is on the same line as the opening parenthesis of the method call, shall have their first key indented one step (two spaces) more than the position inside the opening parenthesis.\n\nOther hash literals shall have their first key indented one step more than the start of the line where the opening curly brace is.\n\nThis default style is called 'special_inside_parentheses'. Alternative styles are 'consistent' and 'align_braces'. Here are examples:"
    },
    "Layout/FirstHashElementLineBreak": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowMultilineFinalElement": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for a line break before the first element in a multi-line hash."
    },
    "Layout/FirstMethodArgumentLineBreak": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowMultilineFinalElement": {
          "type": "boolean",
          "description": "Default: false"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks for a line break before the first argument in a multi-line method call."
    },
    "Layout/FirstMethodParameterLineBreak": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowMultilineFinalElement": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for a line break before the first parameter in a multi-line method parameter definition."
    },
    "Layout/FirstParameterIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["consistent", "align_parentheses"],
          "description": "Default: consistent"
        },
        "IndentationWidth": {
          "type": "integer",
          "description": "Default: <none>"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: consistent, align_parentheses"
        }
      },
      "description": "Checks the indentation of the first parameter in a method definition. Parameters after the first one are checked by `Layout/ParameterAlignment`, not by this cop.\n\nFor indenting the first argument of method _calls_, check out `Layout/FirstArgumentIndentation`, which supports options related to nesting that are irrelevant for method _definitions_."
    },
    "Layout/HashAlignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedHashRocketStyle": {
          "enum": ["key", "separator", "table"],
          "description": "Default: key"
        },
        "EnforcedColonStyle": {
          "enum": ["key", "separator", "table"],
          "description": "Default: key"
        },
        "EnforcedLastArgumentHashStyle": {
          "enum": [
            "always_inspect",
            "always_ignore",
            "ignore_implicit",
            "ignore_explicit"
          ],
          "description": "Default: always_inspect"
        },
        "AllowMultipleStyles": {
          "type": "boolean",
          "description": "Default: true"
        },
        "SupportedHashRocketStyles": {
          "type": "array",
          "description": "Default: key, separator, table"
        },
        "SupportedColonStyles": {
          "type": "array",
          "description": "Default: key, separator, table"
        },
        "SupportedLastArgumentHashStyles": {
          "type": "array",
          "description": "Default: always_inspect, always_ignore, ignore_implicit, ignore_explicit"
        }
      },
      "description": "Check that the keys, separators, and values of a multi-line hash literal are aligned according to configuration. The configuration options are:\n\n - key (left align keys, one space before hash rockets and values)\n\n - separator (align hash rockets and colons, right align keys)\n\n - table (left align keys, hash rockets, and values)\n\nThe treatment of hashes passed as the last argument to a method call can also be configured. The options are:\n\n - always_inspect\n\n - always_ignore\n\n - ignore_implicit (without curly braces)\n\nAlternatively you can specify multiple allowed styles. That's done by passing a list of styles to EnforcedStyles."
    },
    "Layout/HeredocArgumentClosingParenthesis": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for the placement of the closing parenthesis in a method call that passes a HEREDOC string as an argument. It should be placed at the end of the line containing the opening HEREDOC tag."
    },
    "Layout/HeredocIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks the indentation of the here document bodies. The bodies are indented one step.\n\nWhen ``Layout/LineLength``'s `AllowHeredoc` is false (not default),       this cop does not add any offenses for long here documents to       avoid ``Layout/LineLength``'s offenses."
    },
    "Layout/IndentationConsistency": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["normal", "indented_internal_methods"],
          "description": "Default: normal"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: normal, indented_internal_methods"
        },
        "Reference": {
          "type": "array",
          "description": "Default: https://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html#follow-the-coding-conventions"
        }
      },
      "description": "Checks for inconsistent indentation.\n\nThe difference between `indented_internal_methods` and `normal` is that the `indented_internal_methods` style prescribes that in classes and modules the `protected` and `private` modifier keywords shall be indented the same as public methods and that protected and private members shall be indented one step more than the modifiers. Other than that, both styles mean that entities on the same logical depth shall have the same indentation."
    },
    "Layout/IndentationStyle": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "IndentationWidth": {
          "type": "integer",
          "description": "Default: <none>"
        },
        "EnforcedStyle": {
          "enum": ["spaces", "tabs"],
          "description": "Default: spaces"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: spaces, tabs"
        }
      },
      "description": "Checks that the indentation method is consistent. Either tabs only or spaces only are used for indentation."
    },
    "Layout/IndentationWidth": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Width": {
          "type": "integer",
          "description": "Default: 2"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks for indentation that doesn't use the specified number of spaces. The indentation width can be configured using the `Width` setting. The default width is 2.\n\nSee also the `Layout/IndentationConsistency` cop which is the companion to this one."
    },
    "Layout/InitialIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for indentation of the first non-blank non-comment line in a file."
    },
    "Layout/LeadingCommentSpace": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowDoxygenCommentStyle": {
          "type": "boolean",
          "description": "Default: false"
        },
        "AllowGemfileRubyComment": {
          "type": "boolean",
          "description": "Default: false"
        },
        "AllowRBSInlineAnnotation": {
          "type": "boolean",
          "description": "Default: false"
        },
        "AllowSteepAnnotation": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks whether comments have a leading space after the `#` denoting the start of the comment. The leading space is not required for some RDoc special syntax, like `#++`, `#--`, `#:nodoc`, `=begin`- and `=end` comments, \"shebang\" directives, or rackup options."
    },
    "Layout/LeadingEmptyLines": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for unnecessary leading blank lines at the beginning of a file."
    },
    "Layout/LineContinuationLeadingSpace": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["leading", "trailing"],
          "description": "Default: trailing"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: leading, trailing"
        }
      },
      "description": "Checks that strings broken over multiple lines (by a backslash) contain trailing spaces instead of leading spaces (default) or leading spaces instead of trailing spaces."
    },
    "Layout/LineContinuationSpacing": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["space", "no_space"],
          "description": "Default: space"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: space, no_space"
        }
      },
      "description": "Checks that the backslash of a line continuation is separated from preceding text by exactly one space (default) or zero spaces."
    },
    "Layout/LineEndStringConcatenationIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["aligned", "indented"],
          "description": "Default: aligned"
        },
        "IndentationWidth": {
          "type": "integer",
          "description": "Default: <none>"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: aligned, indented"
        }
      },
      "description": "Checks the indentation of the next line after a line that ends with a string literal and a backslash.\n\nIf `EnforcedStyle: aligned` is set, the concatenated string parts shall be aligned with the first part. There are some exceptions, such as implicit return values, where the concatenated string parts shall be indented regardless of `EnforcedStyle` configuration.\n\nIf `EnforcedStyle: indented` is set, it's the second line that shall be indented one step more than the first line. Lines 3 and forward shall be aligned with line 2."
    },
    "Layout/LineLength": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Max": {
          "type": "integer",
          "description": "Default: 120"
        },
        "AllowHeredoc": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowURI": {
          "type": "boolean",
          "description": "Default: true"
        },
        "URISchemes": {
          "type": "array",
          "description": "Default: http, https"
        },
        "IgnoreCopDirectives": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "SplitStrings": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks the length of lines in the source code. The maximum length is configurable. The tab size is configured in the `IndentationWidth` of the `Layout/IndentationStyle` cop. It also ignores a shebang line by default.\n\nThis cop has some autocorrection capabilities. It can programmatically shorten certain long lines by inserting line breaks into expressions that can be safely split across lines. These include arrays, hashes, and method calls with argument lists.\n\nIf autocorrection is enabled, the following cops are recommended to further format the broken lines. (Many of these are enabled by default.)\n\n - Layout/ArgumentAlignment\n\n - Layout/ArrayAlignment\n\n - Layout/BlockAlignment\n\n - Layout/BlockEndNewline\n\n - Layout/ClosingParenthesisIndentation\n\n - Layout/FirstArgumentIndentation\n\n - Layout/FirstArrayElementIndentation\n\n - Layout/FirstHashElementIndentation\n\n - Layout/FirstParameterIndentation\n\n - Layout/HashAlignment\n\n - Layout/IndentationWidth\n\n - Layout/MultilineArrayLineBreaks\n\n - Layout/MultilineBlockLayout\n\n - Layout/MultilineHashBraceLayout\n\n - Layout/MultilineHashKeyLineBreaks\n\n - Layout/MultilineMethodArgumentLineBreaks\n\n - Layout/MultilineMethodParameterLineBreaks\n\n - Layout/ParameterAlignment\n\n - Style/BlockDelimiters\n\nTogether, these cops will pretty print hashes, arrays, method calls, etc. For example, let's say the max columns is 25:"
    },
    "Layout/MultilineArrayBraceLayout": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["symmetrical", "new_line", "same_line"],
          "description": "Default: symmetrical"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: symmetrical, new_line, same_line"
        }
      },
      "description": "Checks that the closing brace in an array literal is either on the same line as the last array element or on a new line.\n\nWhen using the `symmetrical` (default) style:\n\nIf an array's opening brace is on the same line as the first element of the array, then the closing brace should be on the same line as the last element of the array.\n\nIf an array's opening brace is on the line above the first element of the array, then the closing brace should be on the line below the last element of the array.\n\nWhen using the `new_line` style:\n\nThe closing brace of a multi-line array literal must be on the line after the last element of the array.\n\nWhen using the `same_line` style:\n\nThe closing brace of a multi-line array literal must be on the same line as the last element of the array."
    },
    "Layout/MultilineArrayLineBreaks": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowMultilineFinalElement": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Ensures that each item in a multi-line array starts on a separate line."
    },
    "Layout/MultilineAssignmentLayout": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["same_line", "new_line"],
          "description": "Default: new_line"
        },
        "SupportedTypes": {
          "type": "array",
          "description": "Default: block, case, class, if, kwbegin, module"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: same_line, new_line"
        }
      },
      "description": "Checks whether the multiline assignments have a newline after the assignment operator."
    },
    "Layout/MultilineBlockLayout": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks whether the multiline do end blocks have a newline after the start of the block. Additionally, it checks whether the block arguments, if any, are on the same line as the start of the block. Putting block arguments on separate lines, because the whole line would otherwise be too long, is accepted."
    },
    "Layout/MultilineHashBraceLayout": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["symmetrical", "new_line", "same_line"],
          "description": "Default: symmetrical"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: symmetrical, new_line, same_line"
        }
      },
      "description": "Checks that the closing brace in a hash literal is either on the same line as the last hash element, or a new line.\n\nWhen using the `symmetrical` (default) style:\n\nIf a hash's opening brace is on the same line as the first element of the hash, then the closing brace should be on the same line as the last element of the hash.\n\nIf a hash's opening brace is on the line above the first element of the hash, then the closing brace should be on the line below the last element of the hash.\n\nWhen using the `new_line` style:\n\nThe closing brace of a multi-line hash literal must be on the line after the last element of the hash.\n\nWhen using the `same_line` style:\n\nThe closing brace of a multi-line hash literal must be on the same line as the last element of the hash."
    },
    "Layout/MultilineHashKeyLineBreaks": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowMultilineFinalElement": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Ensures that each key in a multi-line hash starts on a separate line."
    },
    "Layout/MultilineMethodArgumentLineBreaks": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowMultilineFinalElement": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Ensures that each argument in a multi-line method call starts on a separate line.\n\nThis cop does not move the first argument, if you want that to be on a separate line, see `Layout/FirstMethodArgumentLineBreak`."
    },
    "Layout/MultilineMethodCallBraceLayout": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["symmetrical", "new_line", "same_line"],
          "description": "Default: symmetrical"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: symmetrical, new_line, same_line"
        }
      },
      "description": "Checks that the closing brace in a method call is either on the same line as the last method argument, or a new line.\n\nWhen using the `symmetrical` (default) style:\n\nIf a method call's opening brace is on the same line as the first argument of the call, then the closing brace should be on the same line as the last argument of the call.\n\nIf a method call's opening brace is on the line above the first argument of the call, then the closing brace should be on the line below the last argument of the call.\n\nWhen using the `new_line` style:\n\nThe closing brace of a multi-line method call must be on the line after the last argument of the call.\n\nWhen using the `same_line` style:\n\nThe closing brace of a multi-line method call must be on the same line as the last argument of the call."
    },
    "Layout/MultilineMethodCallIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["aligned", "indented", "indented_relative_to_receiver"],
          "description": "Default: aligned"
        },
        "IndentationWidth": {
          "type": "integer",
          "description": "Default: <none>"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: aligned, indented, indented_relative_to_receiver"
        }
      },
      "description": "Checks the indentation of the method name part in method calls that span more than one line."
    },
    "Layout/MultilineMethodDefinitionBraceLayout": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["symmetrical", "new_line", "same_line"],
          "description": "Default: symmetrical"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: symmetrical, new_line, same_line"
        }
      },
      "description": "Checks that the closing brace in a method definition is either on the same line as the last method parameter, or a new line.\n\nWhen using the `symmetrical` (default) style:\n\nIf a method definition's opening brace is on the same line as the first parameter of the definition, then the closing brace should be on the same line as the last parameter of the definition.\n\nIf a method definition's opening brace is on the line above the first parameter of the definition, then the closing brace should be on the line below the last parameter of the definition.\n\nWhen using the `new_line` style:\n\nThe closing brace of a multi-line method definition must be on the line after the last parameter of the definition.\n\nWhen using the `same_line` style:\n\nThe closing brace of a multi-line method definition must be on the same line as the last parameter of the definition."
    },
    "Layout/MultilineMethodParameterLineBreaks": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowMultilineFinalElement": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Ensures that each parameter in a multi-line method definition starts on a separate line.\n\nThis cop does not move the first argument, if you want that to be on a separate line, see `Layout/FirstMethodParameterLineBreak`."
    },
    "Layout/MultilineOperationIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["aligned", "indented"],
          "description": "Default: aligned"
        },
        "IndentationWidth": {
          "type": "integer",
          "description": "Default: <none>"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: aligned, indented"
        }
      },
      "description": "Checks the indentation of the right hand side operand in binary operations that span more than one line.\n\nThe `aligned` style checks that operators are aligned if they are part of an `if` or `while` condition, an explicit `return` statement, etc. In other contexts, the second operand should be indented regardless of enforced style."
    },
    "Layout/ParameterAlignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["with_first_parameter", "with_fixed_indentation"],
          "description": "Default: with_first_parameter"
        },
        "IndentationWidth": {
          "type": "integer",
          "description": "Default: <none>"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: with_first_parameter, with_fixed_indentation"
        }
      },
      "description": "Check that the parameters on a multi-line method call or definition are aligned.\n\nTo set the alignment of the first argument, use the `Layout/FirstParameterIndentation` cop."
    },
    "Layout/RedundantLineBreak": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "InspectBlocks": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks whether certain expressions, e.g. method calls, that could fit completely on a single line, are broken up into multiple lines unnecessarily."
    },
    "Layout/RescueEnsureAlignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks whether the rescue and ensure keywords are aligned properly."
    },
    "Layout/SingleLineBlockChain": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks if method calls are chained onto single line blocks. It considers that a line break before the dot improves the readability of the code."
    },
    "Layout/SpaceAfterColon": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for colon (`:`) not followed by some kind of space. N.B. this cop does not handle spaces after a ternary operator, which are instead handled by `Layout/SpaceAroundOperators`."
    },
    "Layout/SpaceAfterComma": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for comma (`,`) not followed by some kind of space."
    },
    "Layout/SpaceAfterMethodName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for space between a method name and a left parenthesis in defs."
    },
    "Layout/SpaceAfterNot": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for space after `!`."
    },
    "Layout/SpaceAfterSemicolon": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for semicolon (`;`) not followed by some kind of space."
    },
    "Layout/SpaceAroundBlockParameters": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyleInsidePipes": {
          "enum": ["space", "no_space"],
          "description": "Default: no_space"
        },
        "SupportedStylesInsidePipes": {
          "type": "array",
          "description": "Default: space, no_space"
        }
      },
      "description": "Checks the spacing inside and after block parameters pipes. Line breaks inside parameter pipes are checked by `Layout/MultilineBlockLayout` and not by this cop."
    },
    "Layout/SpaceAroundEqualsInParameterDefault": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["space", "no_space"],
          "description": "Default: space"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: space, no_space"
        }
      },
      "description": "Checks that the equals signs in parameter default assignments have or don't have surrounding space depending on configuration."
    },
    "Layout/SpaceAroundKeyword": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks the spacing around the keywords."
    },
    "Layout/SpaceAroundMethodCallOperator": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks method call operators to not have spaces around them."
    },
    "Layout/SpaceAroundOperators": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowForAlignment": {
          "type": "boolean",
          "description": "Default: true"
        },
        "EnforcedStyleForExponentOperator": {
          "enum": ["space", "no_space"],
          "description": "Default: no_space"
        },
        "EnforcedStyleForRationalLiterals": {
          "enum": ["space", "no_space"],
          "description": "Default: no_space"
        },
        "SupportedStylesForExponentOperator": {
          "type": "array",
          "description": "Default: space, no_space"
        },
        "SupportedStylesForRationalLiterals": {
          "type": "array",
          "description": "Default: space, no_space"
        }
      },
      "description": "Checks that operators have space around them, except for ** which should or shouldn't have surrounding space depending on configuration. It allows vertical alignment consisting of one or more whitespace around operators.\n\nThis cop has `AllowForAlignment` option. When `true`, allows most uses of extra spacing if the intent is to align with an operator on the previous or next line, not counting empty lines or comment lines."
    },
    "Layout/SpaceBeforeBlockBraces": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["space", "no_space"],
          "description": "Default: space"
        },
        "EnforcedStyleForEmptyBraces": {
          "enum": ["space", "no_space"],
          "description": "Default: space"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: space, no_space"
        },
        "SupportedStylesForEmptyBraces": {
          "type": "array",
          "description": "Default: space, no_space"
        }
      },
      "description": "Checks that block braces have or don't have a space before the opening brace depending on configuration."
    },
    "Layout/SpaceBeforeBrackets": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for space between the name of a receiver and a left brackets."
    },
    "Layout/SpaceBeforeComma": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for comma (`,`) preceded by space."
    },
    "Layout/SpaceBeforeComment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for missing space between a token and a comment on the same line."
    },
    "Layout/SpaceBeforeFirstArg": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowForAlignment": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "Checks that exactly one space is used between a method name and the first argument for method calls without parentheses.\n\nAlternatively, extra spaces can be added to align the argument with something on a preceding or following line, if the AllowForAlignment config parameter is true."
    },
    "Layout/SpaceBeforeSemicolon": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for semicolon (`;`) preceded by space."
    },
    "Layout/SpaceInLambdaLiteral": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["require_no_space", "require_space"],
          "description": "Default: require_no_space"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: require_no_space, require_space"
        }
      },
      "description": "Checks for spaces between `->` and opening parameter parenthesis (`(`) in lambda literals."
    },
    "Layout/SpaceInsideArrayLiteralBrackets": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["space", "no_space", "compact"],
          "description": "Default: no_space"
        },
        "EnforcedStyleForEmptyBrackets": {
          "enum": ["space", "no_space"],
          "description": "Default: no_space"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: space, no_space, compact"
        },
        "SupportedStylesForEmptyBrackets": {
          "type": "array",
          "description": "Default: space, no_space"
        }
      },
      "description": "Checks that brackets used for array literals have or don't have surrounding space depending on configuration."
    },
    "Layout/SpaceInsideArrayPercentLiteral": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for unnecessary additional spaces inside array percent literals (i.e. %i/%w).\n\nNote that blank percent literals (e.g. `%i( )`) are checked by `Layout/SpaceInsidePercentLiteralDelimiters`."
    },
    "Layout/SpaceInsideBlockBraces": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["space", "no_space"],
          "description": "Default: space"
        },
        "EnforcedStyleForEmptyBraces": {
          "enum": ["space", "no_space"],
          "description": "Default: no_space"
        },
        "SpaceBeforeBlockParameters": {
          "type": "boolean",
          "description": "Default: true"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: space, no_space"
        },
        "SupportedStylesForEmptyBraces": {
          "type": "array",
          "description": "Default: space, no_space"
        }
      },
      "description": "Checks that block braces have or don't have surrounding space inside them on configuration. For blocks taking parameters, it checks that the left brace has or doesn't have trailing space depending on configuration."
    },
    "Layout/SpaceInsideHashLiteralBraces": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["space", "no_space", "compact"],
          "description": "Default: space"
        },
        "EnforcedStyleForEmptyBraces": {
          "enum": ["space", "no_space"],
          "description": "Default: no_space"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: space, no_space, compact"
        },
        "SupportedStylesForEmptyBraces": {
          "type": "array",
          "description": "Default: space, no_space"
        }
      },
      "description": "Checks that braces used for hash literals have or don't have surrounding space depending on configuration."
    },
    "Layout/SpaceInsideParens": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["space", "compact", "no_space"],
          "description": "Default: no_space"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: space, compact, no_space"
        }
      },
      "description": "Checks for spaces inside ordinary round parentheses."
    },
    "Layout/SpaceInsidePercentLiteralDelimiters": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for unnecessary additional spaces inside the delimiters of %i/%w/%x literals."
    },
    "Layout/SpaceInsideRangeLiteral": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for spaces inside range literals."
    },
    "Layout/SpaceInsideReferenceBrackets": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["space", "no_space"],
          "description": "Default: no_space"
        },
        "EnforcedStyleForEmptyBrackets": {
          "enum": ["space", "no_space"],
          "description": "Default: no_space"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: space, no_space"
        },
        "SupportedStylesForEmptyBrackets": {
          "type": "array",
          "description": "Default: space, no_space"
        }
      },
      "description": "Checks that reference brackets have or don't have surrounding space depending on configuration."
    },
    "Layout/SpaceInsideStringInterpolation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["space", "no_space"],
          "description": "Default: no_space"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: space, no_space"
        }
      },
      "description": "Checks for whitespace within string interpolations."
    },
    "Layout/TrailingEmptyLines": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["final_newline", "final_blank_line"],
          "description": "Default: final_newline"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: final_newline, final_blank_line"
        }
      },
      "description": "Looks for trailing blank lines and a final newline in the source code."
    },
    "Layout/TrailingWhitespace": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowInHeredoc": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Looks for trailing whitespace in the source code."
    },
    "Lint": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "'Lint' department"
    },
    "Lint/AmbiguousAssignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for mistyped shorthand assignments."
    },
    "Lint/AmbiguousBlockAssociation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks for ambiguous block association with method when param passed without parentheses.\n\nThis cop can customize allowed methods with `AllowedMethods`. By default, there are no methods to allowed."
    },
    "Lint/AmbiguousOperator": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for ambiguous operators in the first argument of a method invocation without parentheses."
    },
    "Lint/AmbiguousOperatorPrecedence": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Looks for expressions containing multiple binary operators where precedence is ambiguous due to lack of parentheses. For example, in `1 + 2 * 3`, the multiplication will happen before the addition, but lexically it appears that the addition will happen first.\n\nThe cop does not consider unary operators (ie. `!a` or `-b`) or comparison operators (ie. `a =~ b`) because those are not ambiguous.\n\nRanges are handled by `Lint/AmbiguousRange`."
    },
    "Lint/AmbiguousRange": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "RequireParenthesesForMethodChains": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for ambiguous ranges.\n\nRanges have quite low precedence, which leads to unexpected behavior when using a range with other operators. This cop avoids that by making ranges explicit by requiring parenthesis around complex range boundaries (anything that is not a literal: numerics, strings, symbols, etc.).\n\nThis cop can be configured with `RequireParenthesesForMethodChains` in order to specify whether method chains (including `self.foo`) should be wrapped in parens by this cop.\n\nRegardless of this configuration, if a method receiver is a basic literal value, it will be wrapped in order to prevent the ambiguity of `1..2.to_a`."
    },
    "Lint/AmbiguousRegexpLiteral": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for ambiguous regexp literals in the first argument of a method invocation without parentheses."
    },
    "Lint/ArrayLiteralInRegexp": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for an array literal interpolated inside a regexp.\n\nWhen interpolating an array literal, it is converted to a string. This means that when inside a regexp, it acts as a character class but with additional quotes, spaces and commas that are likely not intended. For example, `/#{%w[a b c]}/` parses as `/[\"a\", \"b\", \"c\"]/` (or `/[\"a, bc]/` without repeated characters).\n\nThe cop can autocorrect to a character class (if all items in the array are a single character) or alternation (if the array contains longer items).\n\nThis only considers interpolated arrays that contain only strings, symbols, integers, and floats. Any other type is not easily convertible to a character class or regexp alternation."
    },
    "Lint/AssignmentInCondition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowSafeAssignment": {
          "type": "boolean",
          "description": "Default: true"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for assignments in the conditions of if/while/until.\n\n`AllowSafeAssignment` option for safe assignment. By safe assignment we mean putting parentheses around an assignment to indicate \"I know I'm using an assignment as a condition. It's not a mistake.\""
    },
    "Lint/BigDecimalNew": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "`BigDecimal.new()` is deprecated since BigDecimal 1.3.3. This cop identifies places where `BigDecimal.new()` can be replaced by `BigDecimal()`."
    },
    "Lint/BinaryOperatorWithIdenticalOperands": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for places where binary operator has identical operands.\n\nIt covers comparison operators: `==`, `===`, `=~`, `>`, `>=`, `<`, ``<=``; bitwise operators: `|`, `^`, `&`; boolean operators: `&&`, `||` and \"spaceship\" operator - ``<=>``.\n\nSimple arithmetic operations are allowed by this cop: `+`, `*`, `**`, `<<` and `>>`. Although these can be rewritten in a different way, it should not be necessary to do so. Operations such as `-` or `/` where the result will always be the same (`x - x` will always be 0; `x / x` will always be 1) are offenses, but these are covered by `Lint/NumericOperationWithConstantResult` instead."
    },
    "Lint/BooleanSymbol": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for `:true` and `:false` symbols. In most cases it would be a typo."
    },
    "Lint/CircularArgumentReference": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for circular argument references in optional keyword arguments and optional ordinal arguments.\n\nThis cop mirrors a warning produced by MRI since 2.2.\n\nThis syntax is no longer valid on Ruby 2.7 or higher."
    },
    "Lint/ConstantDefinitionInBlock": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: enums"
        }
      },
      "description": "Do not define constants within a block, since the block's scope does not isolate or namespace the constant in any way.\n\nIf you are trying to define that constant once, define it outside of the block instead, or use a variable or method if defining the constant in the outer scope would be problematic.\n\nFor meta-programming, use `const_set`."
    },
    "Lint/ConstantOverwrittenInRescue": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for overwriting an exception with an exception result by use ``rescue =>``.\n\nYou intended to write as `rescue StandardError`. However, you have written `rescue => StandardError`. In that case, the result of `rescue` will overwrite `StandardError`."
    },
    "Lint/ConstantReassignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for constant reassignments.\n\nEmulates Ruby's runtime warning \"already initialized constant X\" when a constant is reassigned in the same file and namespace using the `NAME = value` syntax.\n\nThe cop cannot catch all offenses, like, for example, when a constant is reassigned in another file, or when using metaprogramming (`Module#const_set`).\n\nThe cop only takes into account constants assigned in a \"simple\" way: directly inside class/module definition, or within another constant. Other type of assignments (e.g., inside a conditional) are disregarded.\n\nThe cop also tracks constant removal using `Module#remove_const` with symbol or string argument."
    },
    "Lint/ConstantResolution": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Only": {
          "type": "array",
          "description": "Default: []"
        },
        "Ignore": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Check that certain constants are fully qualified.\n\nThis is not enabled by default because it would mark a lot of offenses unnecessarily.\n\nGenerally, gems should fully qualify all constants to avoid conflicts with the code that uses the gem. Enable this cop without using `Only`/`Ignore`\n\nLarge projects will over time end up with one or two constant names that are problematic because of a conflict with a library or just internally using the same name a namespace and a class. To avoid too many unnecessary offenses, Enable this cop with `Only: [The, Constant, Names, Causing, Issues]`\n\n`Style/RedundantConstantBase` cop is disabled if this cop is enabled to prevent conflicting rules. Because it respects user configurations that want to enable this cop which is disabled by default."
    },
    "Lint/CopDirectiveSyntax": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks that `# rubocop:enable ...` and `# rubocop:disable ...` statements are strictly formatted.\n\nA comment can be added to the directive by prefixing it with `--`."
    },
    "Lint/Debugger": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "DebuggerMethods": {
          "description": "Default: {\"Kernel\" ⇒ [\"binding.irb\", \"Kernel.binding.irb\"], \"Byebug\" ⇒ [\"byebug\", \"remote_byebug\", \"Kernel.byebug\", \"Kernel.remote_byebug\"], \"Capybara\" ⇒ [\"page.save_and_open_page\", \"page.save_and_open_screenshot\", \"page.save_page\", \"page.save_screenshot\", \"save_and_open_page\", \"save_and_open_screenshot\", \"save_page\", \"save_screenshot\"], \"debug.rb\" ⇒ [\"binding.b\", \"binding.break\", \"Kernel.binding.b\", \"Kernel.binding.break\"], \"Pry\" ⇒ [\"binding.pry\", \"binding.remote_pry\", \"binding.pry_remote\", \"Kernel.binding.pry\", \"Kernel.binding.remote_pry\", \"Kernel.binding.pry_remote\", \"Pry.rescue\", \"pry\"], \"Rails\" ⇒ [\"debugger\", \"Kernel.debugger\"], \"RubyJard\" ⇒ [\"jard\"], \"WebConsole\" ⇒ [\"binding.console\"]}"
        },
        "DebuggerRequires": {
          "description": "Default: {\"debug.rb\" ⇒ [\"debug/open\", \"debug/start\"]}"
        }
      },
      "description": "Checks for debug calls (such as `debugger` or `binding.pry`) that should not be kept for production code.\n\nThe cop can be configured using `DebuggerMethods`. By default, a number of gems debug entrypoints are configured (`Kernel`, `Byebug`, `Capybara`, `debug.rb`, `Pry`, `Rails`, `RubyJard`, and `WebConsole`). Additional methods can be added.\n\nSpecific default groups can be disabled if necessary:\n\nLint/Debugger:   DebuggerMethods:     WebConsole: ~\n\nYou can also add your own methods by adding a new category:\n\nLint/Debugger:   DebuggerMethods:     MyDebugger:       MyDebugger.debug_this\n\nSome gems also ship files that will start a debugging session when required, for example `require 'debug/start'` from `ruby/debug`. These requires can be configured through `DebuggerRequires`. It has the same structure as `DebuggerMethods`, which you can read about above."
    },
    "Lint/DeprecatedClassMethods": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for uses of the deprecated class method usages."
    },
    "Lint/DeprecatedConstants": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "DeprecatedConstants": {
          "description": "Default: {\"NIL\" ⇒ {\"Alternative\" ⇒ \"nil\", \"DeprecatedVersion\" ⇒ \"2.4\"}, \"TRUE\" ⇒ {\"Alternative\" ⇒ \"true\", \"DeprecatedVersion\" ⇒ \"2.4\"}, \"FALSE\" ⇒ {\"Alternative\" ⇒ \"false\", \"DeprecatedVersion\" ⇒ \"2.4\"}, \"Net::HTTPServerException\" ⇒ {\"Alternative\" ⇒ \"Net::HTTPClientException\", \"DeprecatedVersion\" ⇒ \"2.6\"}, \"Random::DEFAULT\" ⇒ {\"Alternative\" ⇒ \"Random.new\", \"DeprecatedVersion\" ⇒ \"3.0\"}, \"Struct::Group\" ⇒ {\"Alternative\" ⇒ \"Etc::Group\", \"DeprecatedVersion\" ⇒ \"3.0\"}, \"Struct::Passwd\" ⇒ {\"Alternative\" ⇒ \"Etc::Passwd\", \"DeprecatedVersion\" ⇒ \"3.0\"}}"
        }
      },
      "description": "Checks for deprecated constants.\n\nIt has `DeprecatedConstants` config. If there is an alternative method, you can set alternative value as `Alternative`. And you can set the deprecated version as `DeprecatedVersion`. These options can be omitted if they are not needed.\n\n  DeprecatedConstants:\n    'DEPRECATED_CONSTANT':\n      Alternative: 'alternative_value'\n      DeprecatedVersion: 'deprecated_version'\n\nBy default, `NIL`, `TRUE`, `FALSE`, `Net::HTTPServerException, `Random::DEFAULT`, `Struct::Group`, and `Struct::Passwd` are configured."
    },
    "Lint/DeprecatedOpenSSLConstant": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Algorithmic constants for `OpenSSL::Cipher` and `OpenSSL::Digest` deprecated since OpenSSL version 2.2.0. Prefer passing a string instead."
    },
    "Lint/DisjunctiveAssignmentInConstructor": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks constructors for disjunctive assignments (`||=`) that should be plain assignments.\n\nSo far, this cop is only concerned with disjunctive assignment of instance variables.\n\nIn ruby, an instance variable is nil until a value is assigned, so the disjunction is unnecessary. A plain assignment has the same effect."
    },
    "Lint/DuplicateBranch": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "IgnoreLiteralBranches": {
          "type": "boolean",
          "description": "Default: false"
        },
        "IgnoreConstantBranches": {
          "type": "boolean",
          "description": "Default: false"
        },
        "IgnoreDuplicateElseBranch": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks that there are no repeated bodies within `if/unless`, `case-when`, `case-in` and `rescue` constructs.\n\nWith `IgnoreLiteralBranches: true`, branches are not registered as offenses if they return a basic literal value (string, symbol, integer, float, rational, complex, `true`, `false`, or `nil`), or return an array, hash, regexp or range that only contains one of the above basic literal values.\n\nWith `IgnoreConstantBranches: true`, branches are not registered as offenses if they return a constant value.\n\nWith `IgnoreDuplicateElseBranch: true`, in conditionals with multiple branches, duplicate 'else' branches are not registered as offenses."
    },
    "Lint/DuplicateCaseCondition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks that there are no repeated conditions used in case 'when' expressions."
    },
    "Lint/DuplicateElsifCondition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks that there are no repeated conditions used in if 'elsif'."
    },
    "Lint/DuplicateHashKey": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for duplicated keys in hash literals. This cop considers both primitive types and constants for the hash keys.\n\nThis cop mirrors a warning in Ruby 2.2."
    },
    "Lint/DuplicateMagicComment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for duplicated magic comments."
    },
    "Lint/DuplicateMatchPattern": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks that there are no repeated patterns used in `in` keywords."
    },
    "Lint/DuplicateMethods": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for duplicated instance (or singleton) method definitions."
    },
    "Lint/DuplicateRegexpCharacterClassElement": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for duplicate elements in `Regexp` character classes."
    },
    "Lint/DuplicateRequire": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for duplicate ``require``s and ``require_relative``s."
    },
    "Lint/DuplicateRescueException": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks that there are no repeated exceptions used in 'rescue' expressions."
    },
    "Lint/DuplicateSetElement": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for duplicate literal, constant, or variable elements in `Set` and `SortedSet`."
    },
    "Lint/EachWithObjectArgument": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks if each_with_object is called with an immutable argument. Since the argument is the object that the given block shall make calls on to build something based on the enumerable that each_with_object iterates over, an immutable argument makes no sense. It's definitely a bug."
    },
    "Lint/ElseLayout": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for odd `else` block layout - like having an expression on the same line as the `else` keyword, which is usually a mistake.\n\nIts autocorrection tweaks layout to keep the syntax. So, this autocorrection is compatible correction for bad case syntax, but if your code makes a mistake with `elsif` and `else`, you will have to correct it manually."
    },
    "Lint/EmptyBlock": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowComments": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowEmptyLambdas": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "Checks for blocks without a body. Such empty blocks are typically an oversight or we should provide a comment to clarify what we're aiming for.\n\nEmpty lambdas and procs are ignored by default.\n\nFor backwards compatibility, the configuration that allows/disallows empty lambdas and procs is called `AllowEmptyLambdas`, even though it also applies to procs."
    },
    "Lint/EmptyClass": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowComments": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for classes and metaclasses without a body. Such empty classes and metaclasses are typically an oversight or we should provide a comment to be clearer what we're aiming for."
    },
    "Lint/EmptyConditionalBody": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowComments": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AutoCorrect": {
          "type": "string",
          "description": "Default: contextual"
        }
      },
      "description": "Checks for the presence of `if`, `elsif` and `unless` branches without a body.\n\nempty `else` branches are handled by `Style/EmptyElse`."
    },
    "Lint/EmptyEnsure": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "string",
          "description": "Default: contextual"
        }
      },
      "description": "Checks for empty `ensure` blocks."
    },
    "Lint/EmptyExpression": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for the presence of empty expressions."
    },
    "Lint/EmptyFile": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowComments": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "Enforces that Ruby source files are not empty."
    },
    "Lint/EmptyInPattern": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowComments": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "Checks for the presence of `in` pattern branches without a body."
    },
    "Lint/EmptyInterpolation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "string",
          "description": "Default: contextual"
        }
      },
      "description": "Checks for empty interpolation."
    },
    "Lint/EmptyWhen": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowComments": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "Checks for the presence of `when` branches without a body."
    },
    "Lint/EnsureReturn": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for `return` from an `ensure` block. `return` from an ensure block is a dangerous code smell as it will take precedence over any exception being raised, and the exception will be silently thrown away as if it were rescued.\n\nIf you want to rescue some (or all) exceptions, best to do it explicitly"
    },
    "Lint/ErbNewArguments": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Emulates the following Ruby warnings in Ruby 2.6.\n\n$ cat example.rb ERB.new('hi', nil, '-', '@output_buffer') $ ruby -rerb example.rb example.rb:1: warning: Passing safe_level with the 2nd argument of ERB.new is deprecated. Do not use it, and specify other arguments as keyword arguments. example.rb:1: warning: Passing trim_mode with the 3rd argument of ERB.new is deprecated. Use keyword argument like ERB.new(str, trim_mode:...) instead. example.rb:1: warning: Passing eoutvar with the 4th argument of ERB.new is deprecated. Use keyword argument like ERB.new(str, eoutvar: ...) instead.\n\nNow non-keyword arguments other than first one are softly deprecated and will be removed when Ruby 2.5 becomes EOL. `ERB.new` with non-keyword arguments is deprecated since ERB 2.2.0. Use `:trim_mode` and `:eoutvar` keyword arguments to `ERB.new`. This cop identifies places where `ERB.new(str, trim_mode, eoutvar)` can be replaced by `ERB.new(str, :trim_mode: trim_mode, eoutvar: eoutvar)`."
    },
    "Lint/FlipFlop": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Looks for uses of flip-flop operator based on the Ruby Style Guide.\n\nHere is the history of flip-flops in Ruby. flip-flop operator is deprecated in Ruby 2.6.0 and the deprecation has been reverted by Ruby 2.7.0 and backported to Ruby 2.6. See: https://bugs.ruby-lang.org/issues/5400"
    },
    "Lint/FloatComparison": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for the presence of precise comparison of floating point numbers.\n\nFloating point values are inherently inaccurate, and comparing them for exact equality is almost never the desired semantics. Comparison via the `==/!=` operators checks floating-point value representation to be exactly the same, which is very unlikely if you perform any arithmetic operations involving precision loss."
    },
    "Lint/FloatOutOfRange": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Identifies `Float` literals which are, like, really really really really really really really really big. Too big. No-one needs Floats that big. If you need a float that big, something is wrong with you."
    },
    "Lint/FormatParameterMismatch": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "This lint sees if there is a mismatch between the number of expected fields for format/sprintf/#% and what is actually passed as arguments.\n\nIn addition, it checks whether different formats are used in the same format string. Do not mix numbered, unnumbered, and named formats in the same format string."
    },
    "Lint/HashCompareByIdentity": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Prefer using `Hash#compare_by_identity` rather than using `object_id` for hash keys.\n\nThis cop looks for hashes being keyed by objects' `object_id`, using one of these methods: `key?`, `has_key?`, `fetch`, `[]` and `[]=`."
    },
    "Lint/HashNewWithKeywordArgumentsAsDefault": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for the deprecated use of keyword arguments as a default in `Hash.new`.\n\nThis usage raises a warning in Ruby 3.3 and results in an error in Ruby 3.4. In Ruby 3.4, keyword arguments will instead be used to change the behavior of a hash. For example, the capacity option can be passed to create a hash with a certain size if you know it in advance, for better performance.\n\nThe following corner case may result in a false negative when upgrading from Ruby 3.3 or earlier, but it is intentionally not detected to respect the expected usage in Ruby 3.4.\n\nHash.new(capacity: 42)"
    },
    "Lint/HeredocMethodCallPosition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for the ordering of a method call where the receiver of the call is a HEREDOC."
    },
    "Lint/IdentityComparison": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Prefer `equal?` over `==` when comparing `object_id`.\n\n`Object#equal?` is provided to compare objects for identity, and in contrast `Object#==` is provided for the purpose of doing value comparison."
    },
    "Lint/ImplicitStringConcatenation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for implicit string concatenation of string literals which are on the same line."
    },
    "Lint/IncompatibleIoSelectWithFiberScheduler": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for `IO.select` that is incompatible with Fiber Scheduler since Ruby 3.0.\n\nWhen an array of IO objects waiting for an exception (the third argument of `IO.select`) is used as an argument, there is no alternative API, so offenses are not registered.\n\nWhen the method is successful the return value of `IO.select` is `[[IO]]`, and the return value of `io.wait_readable` and `io.wait_writable` are `self`. They are not autocorrected when assigning a return value because these types are different. It's up to user how to handle the return value."
    },
    "Lint/IneffectiveAccessModifier": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for `private` or `protected` access modifiers which are applied to a singleton method. These access modifiers do not make singleton methods private/protected. `private_class_method` can be used for that."
    },
    "Lint/InheritException": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["standard_error", "runtime_error"],
          "description": "Default: standard_error"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: standard_error, runtime_error"
        }
      },
      "description": "Looks for error classes inheriting from `Exception`. It is configurable to suggest using either `StandardError` (default) or `RuntimeError` instead."
    },
    "Lint/InterpolationCheck": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for interpolation in a single quoted string."
    },
    "Lint/ItWithoutArgumentsInBlock": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://bugs.ruby-lang.org/issues/18980"
        }
      },
      "description": "Emulates the following Ruby warning in Ruby 3.3.\n\n$ ruby -e '0.times { it }' -e:1: warning: `it` calls without arguments will refer to the first block param in Ruby 3.4; use it() or self.it\n\n`it` calls without arguments will refer to the first block param in Ruby 3.4. So use `it()` or `self.it` to ensure compatibility."
    },
    "Lint/LambdaWithoutLiteralBlock": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks uses of lambda without a literal block. It emulates the following warning in Ruby 3.0:\n\n  $ ruby -vwe 'lambda(&proc {})'\n  ruby 3.0.0p0 (2020-12-25 revision 95aff21468) [x86_64-darwin19]\n  -e:1: warning: lambda without a literal block is deprecated; use the proc without\n  lambda instead\n\nThis way, proc object is never converted to lambda. Autocorrection replaces with compatible proc argument."
    },
    "Lint/LiteralAsCondition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "string",
          "description": "Default: contextual"
        }
      },
      "description": "Checks for literals used as the conditions or as operands in and/or expressions serving as the conditions of if/while/until/case-when/case-in.\n\nLiterals in `case-in` condition where the match variable is used in `in` are accepted as a pattern matching."
    },
    "Lint/LiteralAssignmentInCondition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for literal assignments in the conditions of `if`, `while`, and `until`. It emulates the following Ruby warning:\n\n$ ruby -we 'if x = true; end' -e:1: warning: found `= literal' in conditional, should be ==\n\nAs a lint cop, it cannot be determined if `==` is appropriate as intended, therefore this cop does not provide autocorrection."
    },
    "Lint/LiteralInInterpolation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for interpolated literals.\n\nArray literals interpolated in regexps are not handled by this cop, but by `Lint/ArrayLiteralInRegexp` instead."
    },
    "Lint/Loop": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for uses of `begin...end while/until something`."
    },
    "Lint/MissingCopEnableDirective": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "MaximumRangeSize": {
          "type": "number",
          "description": "Default: Infinity"
        }
      },
      "description": "Checks that there is an `# rubocop:enable ...` statement after a `# rubocop:disable ...` statement. This will prevent leaving cop disables on wide ranges of code, that latter contributors to a file wouldn't be aware of."
    },
    "Lint/MissingSuper": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedParentClasses": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks for the presence of constructors and lifecycle callbacks without calls to `super`.\n\nThis cop does not consider `method_missing` (and `respond_to_missing?`) because in some cases it makes sense to overtake what is considered a missing method. In other cases, the theoretical ideal handling could be challenging or verbose for no actual gain.\n\nAutocorrection is not supported because the position of `super` cannot be determined automatically.\n\n`Object` and `BasicObject` are allowed by this cop because of their stateless nature. However, sometimes you might want to allow other parent classes from this cop, for example in the case of an abstract class that is not meant to be called with `super`. In those cases, you can use the `AllowedParentClasses` option to specify which classes should be allowed *in addition to* `Object` and `BasicObject`."
    },
    "Lint/MixedCaseRange": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for mixed-case character ranges since they include likely unintended characters.\n\nOffenses are registered for regexp character classes like `/[A-z]/` as well as range objects like `('A'..'z')`.\n\n`Range` objects cannot be autocorrected."
    },
    "Lint/MixedRegexpCaptureTypes": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Do not mix named captures and numbered captures in a `Regexp` literal because numbered capture is ignored if they're mixed. Replace numbered captures with non-capturing groupings or named captures."
    },
    "Lint/MultipleComparison": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "In math and Python, we can use `x < y < z` style comparison to compare multiple value. However, we can't use the comparison in Ruby. However, the comparison is not syntax error. This cop checks the bad usage of comparison operators."
    },
    "Lint/NestedMethodDefinition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks for nested method definitions."
    },
    "Lint/NestedPercentLiteral": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for nested percent literals."
    },
    "Lint/NextWithoutAccumulator": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Don't omit the accumulator when calling `next` in a `reduce` block."
    },
    "Lint/NoReturnInBeginEndBlocks": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for the presence of a `return` inside a `begin..end` block in assignment contexts. In this situation, the `return` will result in an exit from the current method, possibly leading to unexpected behavior."
    },
    "Lint/NonAtomicFileOperation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for non-atomic file operation. And then replace it with a nearly equivalent and atomic method.\n\nThese can cause problems that are difficult to reproduce, especially in cases of frequent file operations in parallel, such as test runs with parallel_rspec.\n\nFor examples: creating a directory if there is none, has the following problems\n\nAn exception occurs when the directory didn't exist at the time of `exist?`, but someone else created it before `mkdir` was executed.\n\nSubsequent processes are executed without the directory that should be there when the directory existed at the time of `exist?`, but someone else deleted it shortly afterwards."
    },
    "Lint/NonDeterministicRequireOrder": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "`Dir[...]` and `Dir.glob(...)` do not make any guarantees about the order in which files are returned. The final order is determined by the operating system and file system. This means that using them in cases where the order matters, such as requiring files, can lead to intermittent failures that are hard to debug. To ensure this doesn't happen, always sort the list.\n\n`Dir.glob` and `Dir[]` sort globbed results by default in Ruby 3.0. So all bad cases are acceptable when Ruby 3.0 or higher are used.\n\nThis cop will be deprecated and removed when supporting only Ruby 3.0 and higher."
    },
    "Lint/NonLocalExitFromIterator": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for non-local exits from iterators without a return value. It registers an offense under these conditions:\n\n - No value is returned,\n\n - the block is preceded by a method chain,\n\n - the block has arguments,\n\n - the method which receives the block is not define_method or define_singleton_method,\n\n - the return is not contained in an inner scope, e.g. a lambda or a method definition."
    },
    "Lint/NumberConversion": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "IgnoredClasses": {
          "type": "array",
          "description": "Default: Time, DateTime"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Warns the usage of unsafe number conversions. Unsafe number conversion can cause unexpected error if auto type conversion fails. Cop prefer parsing with number class instead.\n\nConversion with `Integer`, `Float`, etc. will raise an `ArgumentError` if given input that is not numeric (eg. an empty string), whereas `to_i`, etc. will try to convert regardless of input (``''.to_i => 0``). As such, this cop is disabled by default because it's not necessarily always correct to raise if a value is not numeric.\n\nSome values cannot be converted properly using one of the `Kernel` method (for instance, `Time` and `DateTime` values are allowed by this cop by default). Similarly, Rails' duration methods do not work well with `Integer()` and can be allowed with `AllowedMethods`. By default, there are no methods to allowed."
    },
    "Lint/NumberedParameterAssignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for uses of numbered parameter assignment. It emulates the following warning in Ruby 2.7:\n\n  $ ruby -ve '_1 = :value'\n  ruby 2.7.2p137 (2020-10-01 revision 5445e04352) [x86_64-darwin19]\n  -e:1: warning: `_1' is reserved for numbered parameter; consider another name\n\nAssigning to a numbered parameter (from `_1` to `_9`) causes an error in Ruby 3.0.\n\n  $ ruby -ve '_1 = :value'\n  ruby 3.0.0p0 (2020-12-25 revision 95aff21468) [x86_64-darwin19]\n  -e:1: _1 is reserved for numbered parameter\n\nThe parametered parameters are from `_1` to `_9`. This cop checks `_0`, and over `_10` as well to prevent confusion."
    },
    "Lint/NumericOperationWithConstantResult": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Certain numeric operations have a constant result, usually 0 or 1. Multiplying a number by 0 will always return 0. Dividing a number by itself or raising it to the power of 0 will always return 1. As such, they can be replaced with that result. These are probably leftover from debugging, or are mistakes. Other numeric operations that are similarly leftover from debugging or mistakes are handled by `Lint/UselessNumericOperation`.\n\nThis cop doesn't detect offenses for the `-` and `%` operator because it can't determine the type of `x`. If `x` is an `Array` or `String`, it doesn't perform a numeric operation."
    },
    "Lint/OrAssignmentToConstant": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for unintended or-assignment to a constant.\n\nConstants should always be assigned in the same location. And its value should always be the same. If constants are assigned in multiple locations, the result may vary depending on the order of `require`."
    },
    "Lint/OrderedMagicComments": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks the proper ordering of magic comments and whether a magic comment is not placed before a shebang."
    },
    "Lint/OutOfRangeRegexpRef": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Looks for references of `Regexp` captures that are out of range and thus always returns nil."
    },
    "Lint/ParenthesesAsGroupedExpression": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for space between the name of a called method and a left parenthesis."
    },
    "Lint/PercentStringArray": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for quotes and commas in %w, e.g. `%w('foo', \"bar\")`\n\nIt is more likely that the additional characters are unintended (for example, mistranslating an array of literals to percent string notation) rather than meant to be part of the resulting strings."
    },
    "Lint/PercentSymbolArray": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for colons and commas in %i, e.g. `%i(:foo, :bar)`\n\nIt is more likely that the additional characters are unintended (for example, mistranslating an array of literals to percent string notation) rather than meant to be part of the resulting symbols."
    },
    "Lint/RaiseException": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedImplicitNamespaces": {
          "type": "array",
          "description": "Default: Gem"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for `raise` or `fail` statements which are raising `Exception` class.\n\nYou can specify a module name that will be an implicit namespace using `AllowedImplicitNamespaces` option. The cop cause a false positive for namespaced `Exception` when a namespace is omitted. This option can prevent the false positive by specifying a namespace to be omitted for `Exception`. Alternatively, make `Exception` a fully qualified class name with an explicit namespace."
    },
    "Lint/RandOne": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for `rand(1)` calls. Such calls always return `0`."
    },
    "Lint/RedundantCopDisableDirective": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Detects instances of rubocop:disable comments that can be removed without causing any offenses to be reported. It's implemented as a cop in that it inherits from the Cop base class and calls add_offense. The unusual part of its implementation is that it doesn't have any on_* methods or an investigate method. This means that it doesn't take part in the investigation phase when the other cops do their work. Instead, it waits until it's called in a later stage of the execution. The reason it can't be implemented as a normal cop is that it depends on the results of all other cops to do its work."
    },
    "Lint/RedundantCopEnableDirective": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Detects instances of rubocop:enable comments that can be removed.\n\nWhen comment enables all cops at once `rubocop:enable all` that cop checks whether any cop was actually enabled."
    },
    "Lint/RedundantDirGlobSort": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Sort globbed results by default in Ruby 3.0. This cop checks for redundant `sort` method to `Dir.glob` and `Dir[]`."
    },
    "Lint/RedundantRegexpQuantifiers": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for redundant quantifiers inside `Regexp` literals.\n\nIt is always allowed when interpolation is used in a regexp literal, because it's unknown what kind of string will be expanded as a result:\n\n/(?:a*#{interpolation})?/x"
    },
    "Lint/RedundantRequireStatement": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for unnecessary `require` statement.\n\nThe following features are unnecessary `require` statement because they are already loaded. e.g. Ruby 2.2:\n\n  ruby -ve 'p $LOADED_FEATURES.reject { |feature| %r|/| =~ feature }'\n  ruby 2.2.8p477 (2017-09-14 revision 59906) [x86_64-darwin13]\n  [\"enumerator.so\", \"rational.so\", \"complex.so\", \"thread.rb\"]\n\nBelow are the features that each `TargetRubyVersion` targets.\n\n - 2.0+ …​ enumerator\n\n - 2.1+ …​ thread\n\n - 2.2+ …​ Add rational and complex above\n\n - 2.7+ …​ Add ruby2_keywords above\n\n - 3.1+ …​ Add fiber above\n\n - 3.2+ …​ set\n\nThis cop target those features."
    },
    "Lint/RedundantSafeNavigation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: instance_of?, kind_of?, is_a?, eql?, respond_to?, equal?"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for redundant safe navigation calls. Use cases where a constant, named in camel case for classes and modules is `nil` are rare, and an offense is not detected when the receiver is a constant. The detection also applies to `self`, and to literal receivers, except for `nil`.\n\nFor all receivers, the `instance_of?`, `kind_of?`, `is_a?`, `eql?`, `respond_to?`, and `equal?` methods are checked by default. These are customizable with `AllowedMethods` option.\n\nThe `AllowedMethods` option specifies nil-safe methods, in other words, it is a method that is allowed to skip safe navigation. Note that the `AllowedMethod` option is not an option that specifies methods for which to suppress (allow) this cop's check.\n\nIn the example below, the safe navigation operator (`&.`) is unnecessary because `NilClass` has methods like `respond_to?` and `is_a?`."
    },
    "Lint/RedundantSplatExpansion": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowPercentLiteralArrayArgument": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "Checks for unneeded usages of splat expansion."
    },
    "Lint/RedundantStringCoercion": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for string conversion in string interpolation, `print`, `puts`, and `warn` arguments, which is redundant."
    },
    "Lint/RedundantTypeConversion": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for redundant uses of `to_s`, `to_sym`, `to_i`, `to_f`, `to_d`, `to_r`, `to_c`, `to_a`, `to_h`, and `to_set`.\n\nWhen one of these methods is called on an object of the same type, that object is returned, making the call unnecessary. The cop detects conversion methods called on object literals, class constructors, class `[]` methods, and the `Kernel` methods `String()`, `Integer()`, `Float()`, BigDecimal(), `Rational()`, `Complex()`, and `Array()`.\n\nSpecifically, these cases are detected for each conversion method:\n\n - to_s when called on a string literal, interpolated string, heredoc, or with String.new or String().\n\n - to_sym when called on a symbol literal or interpolated symbol.\n\n - to_i when called on an integer literal or with Integer().\n\n - to_f when called on a float literal of with Float().\n\n - to_r when called on a rational literal or with Rational().\n\n - to_c when called on a complex literal of with Complex().\n\n - to_a when called on an array literal, or with Array.new, Array() or Array[].\n\n - to_h when called on a hash literal, or with Hash.new, Hash() or Hash[].\n\n - to_set when called on Set.new or Set[].\n\nIn all cases, chaining one same `to_*` conversion methods listed above is redundant.\n\nThe cop can also register an offense for chaining conversion methods on methods that are expected to return a specific type regardless of receiver (eg. `foo.inspect.to_s`)."
    },
    "Lint/RedundantWithIndex": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for redundant `with_index`."
    },
    "Lint/RedundantWithObject": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for redundant `with_object`."
    },
    "Lint/RefinementImportMethods": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks if `include` or `prepend` is called in `refine` block. These methods are deprecated and should be replaced with `Refinement#import_methods`.\n\nIt emulates deprecation warnings in Ruby 3.1. Functionality has been removed in Ruby 3.2."
    },
    "Lint/RegexpAsCondition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for regexp literals used as `match-current-line`. If a regexp literal is in condition, the regexp matches `$_` implicitly."
    },
    "Lint/RequireParentheses": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for expressions where there is a call to a predicate method with at least one argument, where no parentheses are used around the parameter list, and a boolean operator, && or ||, is used in the last argument.\n\nThe idea behind warning for these constructs is that the user might be under the impression that the return value from the method call is an operand of &&/||."
    },
    "Lint/RequireRangeParentheses": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks that a range literal is enclosed in parentheses when the end of the range is at a line break.\n\nThe following is maybe intended for `(42..)`. But, compatible is `42..do_something`. So, this cop does not provide autocorrection because it is left to user.\n\ncase condition when 42..   do_something end"
    },
    "Lint/RequireRelativeSelfPath": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for uses a file requiring itself with `require_relative`."
    },
    "Lint/RescueException": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for `rescue` blocks targeting the `Exception` class."
    },
    "Lint/RescueType": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Check for arguments to `rescue` that will result in a `TypeError` if an exception is raised."
    },
    "Lint/ReturnInVoidContext": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for the use of a return with a value in a context where the value will be ignored. (initialize and setter methods)"
    },
    "Lint/SafeNavigationChain": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: present?, blank?, presence, try, try!, in?"
        }
      },
      "description": "The safe navigation operator returns nil if the receiver is nil. If you chain an ordinary method call after a safe navigation operator, it raises NoMethodError. We should use a safe navigation operator after a safe navigation operator. This cop checks for the problem outlined above."
    },
    "Lint/SafeNavigationConsistency": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: present?, blank?, presence, try, try!"
        }
      },
      "description": "Check to make sure that if safe navigation is used in an `&&` or `||` condition, consistent and appropriate safe navigation, without excess or deficiency, is used for all method calls on the same object."
    },
    "Lint/SafeNavigationWithEmpty": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks to make sure safe navigation isn't used with `empty?` in a conditional.\n\nWhile the safe navigation operator is generally a good idea, when checking `foo&.empty?` in a conditional, `foo` being `nil` will actually do the opposite of what the author intends."
    },
    "Lint/ScriptPermission": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks if a file which has a shebang line as its first line is granted execute permission."
    },
    "Lint/SelfAssignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for self-assignments."
    },
    "Lint/SendWithMixinArgument": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for `send`, `public_send`, and `__send__` methods when using mix-in.\n\n`include` and `prepend` methods were private methods until Ruby 2.0, they were mixed-in via `send` method. This cop uses Ruby 2.1 or higher style that can be called by public methods. And `extend` method that was originally a public method is also targeted for style unification."
    },
    "Lint/ShadowedArgument": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "IgnoreImplicitReferences": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for shadowed arguments.\n\nThis cop has `IgnoreImplicitReferences` configuration option. It means argument shadowing is used in order to pass parameters to zero arity `super` when `IgnoreImplicitReferences` is `true`."
    },
    "Lint/ShadowedException": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for a rescued exception that get shadowed by a less specific exception being rescued before a more specific exception is rescued.\n\nAn exception is considered shadowed if it is rescued after its ancestor is, or if it and its ancestor are both rescued in the same `rescue` statement. In both cases, the more specific rescue is unnecessary because it is covered by rescuing the less specific exception. (ie. `rescue Exception, StandardError` has the same behavior whether `StandardError` is included or not, because all ``StandardError``s are rescued by `rescue Exception`)."
    },
    "Lint/ShadowingOuterLocalVariable": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for the use of local variable names from an outer scope in block arguments or block-local variables. This mirrors the warning given by `ruby -cw` prior to Ruby 2.6: \"shadowing outer local variable - foo\".\n\nShadowing of variables in block passed to `Ractor.new` is allowed because `Ractor` should not access outer variables. eg. following style is encouraged:\n\nworker_id, pipe = env Ractor.new(worker_id, pipe) do |worker_id, pipe| end"
    },
    "Lint/SharedMutableDefault": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for `Hash` creation with a mutable default value. Creating a `Hash` in such a way will share the default value across all keys, causing unexpected behavior when modifying it.\n\nFor example, when the `Hash` was created with an `Array` as the argument, calling `hash[:foo] << 'bar'` will also change the value of all other keys that have not been explicitly assigned to."
    },
    "Lint/StructNewOverride": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks unexpected overrides of the `Struct` built-in methods via `Struct.new`."
    },
    "Lint/SuppressedException": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowComments": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowNil": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "Checks for `rescue` blocks with no body."
    },
    "Lint/SuppressedExceptionInNumberConversion": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for cases where exceptions unrelated to the numeric constructors `Integer()`, `Float()`, `BigDecimal()`, `Complex()`, and `Rational()` may be unintentionally swallowed."
    },
    "Lint/SymbolConversion": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["strict", "consistent"],
          "description": "Default: strict"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: strict, consistent"
        }
      },
      "description": "Checks for uses of literal strings converted to a symbol where a literal symbol could be used instead.\n\nThere are two possible styles for this cop. `strict` (default) will register an offense for any incorrect usage. `consistent` additionally requires hashes to use the same style for every symbol key (ie. if any symbol key needs to be quoted it requires all keys to be quoted)."
    },
    "Lint/Syntax": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Repacks Parser's diagnostics/errors into RuboCop's offenses."
    },
    "Lint/ToEnumArguments": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Ensures that `to_enum`/`enum_for`, called for the current method, has correct arguments."
    },
    "Lint/ToJSON": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks to make sure `#to_json` includes an optional argument. When overriding `#to_json`, callers may invoke JSON generation via `JSON.generate(your_obj)`.  Since `JSON#generate` allows for an optional argument, your method should too."
    },
    "Lint/TopLevelReturnWithArgument": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.jb"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for top level return with arguments. If there is a top-level return statement with an argument, then the argument is always ignored. This is detected automatically since Ruby 2.7."
    },
    "Lint/TrailingCommaInAttributeDeclaration": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "string",
          "description": "Default: contextual"
        }
      },
      "description": "Checks for trailing commas in attribute declarations, such as `#attr_reader`. Leaving a trailing comma will nullify the next method definition by overriding it with a getter method."
    },
    "Lint/TripleQuotes": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for \"triple quotes\" (strings delimited by any odd number of quotes greater than 1).\n\nRuby allows multiple strings to be implicitly concatenated by just being adjacent in a statement (ie. `\"foo\"\"bar\" == \"foobar\"`). This sometimes gives the impression that there is something special about triple quotes, but in fact it is just extra unnecessary quotes and produces the same string. Each pair of quotes produces an additional concatenated empty string, so the result is still only the \"actual\" string within the delimiters.\n\nAlthough this cop is called triple quotes, the same behavior is present for strings delimited by 5, 7, etc. quotation marks."
    },
    "Lint/UnderscorePrefixedVariableName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowKeywordBlockArguments": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for underscore-prefixed variables that are actually used.\n\nSince block keyword arguments cannot be arbitrarily named at call sites, the `AllowKeywordBlockArguments` will allow use of underscore- prefixed block keyword arguments."
    },
    "Lint/UnescapedBracketInRegexp": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for Regexpes (both literals and via `Regexp.new` / `Regexp.compile`) that contain unescaped `]` characters.\n\nIt emulates the following Ruby warning:\n\n$ ruby -e '/abc]123/' -e:1: warning: regular expression has ']' without escape: /abc]123/"
    },
    "Lint/UnexpectedBlockArity": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Methods": {
          "description": "Default: {\"chunk_while\" ⇒ 2, \"each_with_index\" ⇒ 2, \"each_with_object\" ⇒ 2, \"inject\" ⇒ 2, \"max\" ⇒ 2, \"min\" ⇒ 2, \"minmax\" ⇒ 2, \"reduce\" ⇒ 2, \"slice_when\" ⇒ 2, \"sort\" ⇒ 2}"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for a block that is known to need more positional block arguments than are given (by default this is configured for `Enumerable` methods needing 2 arguments). Optional arguments are allowed, although they don't generally make sense as the default value will be used. Blocks that have no receiver, or take splatted arguments (ie. `*args`) are always accepted.\n\nKeyword arguments (including `**kwargs`) do not get counted towards this, as they are not used by the methods in question.\n\nMethod names and their expected arity can be configured like this:\n\nMethods:   inject: 2   reduce: 2"
    },
    "Lint/UnifiedInteger": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for using Fixnum or Bignum constant."
    },
    "Lint/UnmodifiedReduceAccumulator": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Looks for `reduce` or `inject` blocks where the value returned (implicitly or explicitly) does not include the accumulator. A block is considered valid as long as at least one return value includes the accumulator.\n\nIf the accumulator is not included in the return value, then the entire block will just return a transformation of the last element value, and could be rewritten as such without a loop.\n\nAlso catches instances where an index of the accumulator is returned, as this may change the type of object being retained.\n\nFor the purpose of reducing false positives, this cop only flags returns in `reduce` blocks where the element is the only variable in the expression (since we will not be able to tell what other variables relate to via static analysis)."
    },
    "Lint/UnreachableCode": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for unreachable code. The check are based on the presence of flow of control statement in non-final position in `begin` (implicit) blocks."
    },
    "Lint/UnreachableLoop": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: (?-mix:(exactly|at_least|at_most)\\(\\d+\\)\\.times)"
        }
      },
      "description": "Checks for loops that will have at most one iteration.\n\nA loop that can never reach the second iteration is a possible error in the code. In rare cases where only one iteration (or at most one iteration) is intended behavior, the code should be refactored to use `if` conditionals.\n\nBlock methods that are used with ``Enumerable``s are considered to be loops.\n\n`AllowedPatterns` can be used to match against the block receiver in order to allow code that would otherwise be registered as an offense (eg. `times` used not in an `Enumerable` context)."
    },
    "Lint/UnusedBlockArgument": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "IgnoreEmptyBlocks": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowUnusedKeywordArguments": {
          "type": "boolean",
          "description": "Default: false"
        },
        "AutoCorrect": {
          "type": "string",
          "description": "Default: contextual"
        }
      },
      "description": "Checks for unused block arguments."
    },
    "Lint/UnusedMethodArgument": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowUnusedKeywordArguments": {
          "type": "boolean",
          "description": "Default: false"
        },
        "IgnoreEmptyMethods": {
          "type": "boolean",
          "description": "Default: true"
        },
        "IgnoreNotImplementedMethods": {
          "type": "boolean",
          "description": "Default: true"
        },
        "NotImplementedExceptions": {
          "type": "array",
          "description": "Default: NotImplementedError"
        },
        "AutoCorrect": {
          "type": "string",
          "description": "Default: contextual"
        }
      },
      "description": "Checks for unused method arguments."
    },
    "Lint/UriEscapeUnescape": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Identifies places where `URI.escape` can be replaced by `CGI.escape`, `URI.encode_www_form`, or `URI.encode_www_form_component` depending on your specific use case. Also this cop identifies places where `URI.unescape` can be replaced by `CGI.unescape`, `URI.decode_www_form`, or `URI.decode_www_form_component` depending on your specific use case."
    },
    "Lint/UriRegexp": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Identifies places where `URI.regexp` is obsolete and should not be used.\n\nFor Ruby 3.3 or lower, use `URI::DEFAULT_PARSER.make_regexp`. For Ruby 3.4 or higher, use `URI::RFC2396_PARSER.make_regexp`.\n\nIf you need to support both Ruby 3.3 and lower as well as Ruby 3.4 and higher, consider manually changing the code as follows:\n\ndefined?(URI::RFC2396_PARSER) ? URI::RFC2396_PARSER : URI::DEFAULT_PARSER"
    },
    "Lint/UselessAccessModifier": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "ContextCreatingMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "MethodCreatingMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "AutoCorrect": {
          "type": "string",
          "description": "Default: contextual"
        }
      },
      "description": "Checks for redundant access modifiers, including those with no code, those which are repeated, and leading `public` modifiers in a class or module body. Conditionally-defined methods are considered as always being defined, and thus access modifiers guarding such methods are not redundant.\n\nThis cop has `ContextCreatingMethods` option. The default setting value is an empty array that means no method is specified. This setting is an array of methods which, when called, are known to create its own context in the module's current access context.\n\nIt also has `MethodCreatingMethods` option. The default setting value is an empty array that means no method is specified. This setting is an array of methods which, when called, are known to create other methods in the module's current access context."
    },
    "Lint/UselessAssignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "string",
          "description": "Default: contextual"
        }
      },
      "description": "Checks for every useless assignment to local variable in every scope. The basic idea for this cop was from the warning of `ruby -cw`:\n\nassigned but unused variable - foo\n\nCurrently this cop has advanced logic that detects unreferenced reassignments and properly handles varied cases such as branch, loop, rescue, ensure, etc.\n\nThis cop's autocorrection avoids cases like `a ||= 1` because removing assignment from operator assignment can cause `NameError` if this assignment has been used to declare a local variable. For example, replacing `a ||= 1` with `a || 1` may cause \"undefined local variable or method `a' for main:Object (NameError)\".\n\nGiven the assignment `foo = 1, bar = 2`, removing unused variables can lead to a syntax error, so this case is not autocorrected."
    },
    "Lint/UselessConstantScoping": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for useless constant scoping. Private constants must be defined using `private_constant`. Even if `private` access modifier is used, it is public scope despite its appearance.\n\nIt does not support autocorrection due to behavior change and multiple ways to fix it. Or a public constant may be intended."
    },
    "Lint/UselessDefined": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for calls to `defined?` with strings or symbols as the argument. Such calls will always return `'expression'`, you probably meant to check for the existence of a constant, method, or variable instead.\n\n`defined?` is part of the Ruby syntax and doesn't behave like normal methods. You can safely pass in what you are checking for directly, without encountering a `NameError`.\n\nWhen interpolation is used, oftentimes it is not possible to write the code with `defined?`. In these cases, switch to one of the more specific methods:\n\n - class_variable_defined?\n\n - const_defined?\n\n - method_defined?\n\n - instance_variable_defined?\n\n - binding.local_variable_defined?"
    },
    "Lint/UselessElseWithoutRescue": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for useless `else` in `begin..end` without `rescue`.\n\nThis syntax is no longer valid on Ruby 2.6 or higher."
    },
    "Lint/UselessMethodDefinition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "string",
          "description": "Default: contextual"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for useless method definitions, specifically: empty constructors and methods just delegating to `super`."
    },
    "Lint/UselessNumericOperation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Certain numeric operations have no impact, being: Adding or subtracting 0, multiplying or dividing by 1 or raising to the power of 1. These are probably leftover from debugging, or are mistakes."
    },
    "Lint/UselessRescue": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for useless `rescue`s, which only reraise rescued exceptions."
    },
    "Lint/UselessRuby2Keywords": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Looks for `ruby2_keywords` calls for methods that do not need it.\n\n`ruby2_keywords` should only be called on methods that accept an argument splat (`\\*args`) but do not explicit keyword arguments (`k:` or `k: true`) or a keyword splat (`**kwargs`)."
    },
    "Lint/UselessSetterCall": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for setter call to local variable as the final expression of a function definition."
    },
    "Lint/UselessTimes": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        },
        "AutoCorrect": {
          "type": "string",
          "description": "Default: contextual"
        }
      },
      "description": "Checks for uses of `Integer#times` that will never yield (when the integer ``<= 0``) or that will only ever yield once (`1.times`)."
    },
    "Lint/Void": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "CheckForMethodsWithNoSideEffects": {
          "type": "boolean",
          "description": "Default: false"
        },
        "AutoCorrect": {
          "type": "string",
          "description": "Default: contextual"
        }
      },
      "description": "Checks for operators, variables, literals, lambda, proc and nonmutating methods used in void context.\n\n`each` blocks are allowed to prevent false positives. For example, the expression inside the `each` block below. It's not void, especially when the receiver is an `Enumerator`:\n\nenumerator = [1, 2, 3].filter enumerator.each { |item| item >= 2 } #=> [2, 3]"
    },
    "Metrics": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "'Metrics' department"
    },
    "Metrics/AbcSize": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "CountRepeatedAttributes": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Max": {
          "type": "integer",
          "description": "Default: 17"
        },
        "Reference": {
          "type": "array",
          "description": "Default: http://c2.com/cgi/wiki?AbcMetric, https://en.wikipedia.org/wiki/ABC_Software_Metric"
        }
      },
      "description": "Checks that the ABC size of methods is not higher than the configured maximum. The ABC size is based on assignments, branches (method calls), and conditions. See http://c2.com/cgi/wiki?AbcMetric and https://en.wikipedia.org/wiki/ABC_Software_Metric.\n\nInterpreting ABC size:\n\n - ⇐ 17 satisfactory\n\n - 18..30 unsatisfactory\n\n - > 30 dangerous\n\nYou can have repeated \"attributes\" calls count as a single \"branch\". For this purpose, attributes are any method with no argument; no attempt is meant to distinguish actual `attr_reader` from other methods.\n\nThis cop also takes into account `AllowedMethods` (defaults to `[]`) And `AllowedPatterns` (defaults to `[]`)"
    },
    "Metrics/BlockLength": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemspec"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "CountComments": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Max": {
          "type": "integer",
          "description": "Default: 25"
        },
        "CountAsOne": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: refine"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "inherit_mode": {
          "description": "Default: {\"merge\"=>[\"Exclude\"]}"
        }
      },
      "description": "Checks if the length of a block exceeds some maximum value. Comment lines can optionally be ignored. The maximum allowed length is configurable. The cop can be configured to ignore blocks passed to certain methods.\n\nYou can set constructs you want to fold with `CountAsOne`.\n\nAvailable are: 'array', 'hash', 'heredoc', and 'method_call'. Each construct will be counted as one line regardless of its actual size.\n\nThis cop does not apply for `Struct` definitions.\n\nThe `ExcludedMethods` configuration is deprecated and only kept for backwards compatibility. Please use `AllowedMethods` and `AllowedPatterns` instead. By default, there are no methods to allowed."
    },
    "Metrics/BlockNesting": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "CountBlocks": {
          "type": "boolean",
          "description": "Default: false"
        },
        "CountModifierForms": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Max": {
          "type": "integer",
          "description": "Default: 3"
        }
      },
      "description": "Checks for excessive nesting of conditional and looping constructs.\n\nYou can configure if blocks are considered using the `CountBlocks` and `CountModifierForms` options. When both are set to `false` (the default) blocks and modifier forms are not counted towards the nesting level. Set them to `true` to include these in the nesting level calculation as well.\n\nThe maximum level of nesting allowed is configurable."
    },
    "Metrics/ClassLength": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "CountComments": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Max": {
          "type": "integer",
          "description": "Default: 100"
        },
        "CountAsOne": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks if the length of a class exceeds some maximum value. Comment lines can optionally be ignored. The maximum allowed length is configurable.\n\nYou can set constructs you want to fold with `CountAsOne`.\n\nAvailable are: 'array', 'hash', 'heredoc', and 'method_call'. Each construct will be counted as one line regardless of its actual size.\n\nThis cop also applies for `Struct` definitions."
    },
    "Metrics/CollectionLiteralLength": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "LengthThreshold": {
          "type": "integer",
          "description": "Default: 250"
        }
      },
      "description": "Checks for literals with extremely many entries. This is indicative of configuration or data that may be better extracted somewhere else, like a database, fetched from an API, or read from a non-code file (CSV, JSON, YAML, etc.)."
    },
    "Metrics/CyclomaticComplexity": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "Max": {
          "type": "integer",
          "description": "Default: 7"
        }
      },
      "description": "Checks that the cyclomatic complexity of methods is not higher than the configured maximum. The cyclomatic complexity is the number of linearly independent paths through a method. The algorithm counts decision points and adds one.\n\nAn if statement (or unless or ?:) increases the complexity by one. An else branch does not, since it doesn't add a decision point. The && operator (or keyword and) can be converted to a nested if statement, and ||/or is shorthand for a sequence of ifs, so they also add one. Loops can be said to have an exit condition, so they add one. Blocks that are calls to builtin iteration methods (e.g. `ary.map{...}`) also add one, others are ignored."
    },
    "Metrics/MethodLength": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "CountComments": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Max": {
          "type": "integer",
          "description": "Default: 10"
        },
        "CountAsOne": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks if the length of a method exceeds some maximum value. Comment lines can optionally be allowed. The maximum allowed length is configurable.\n\nYou can set constructs you want to fold with `CountAsOne`.\n\nAvailable are: 'array', 'hash', 'heredoc', and 'method_call'. Each construct will be counted as one line regardless of its actual size.\n\nThe `ExcludedMethods` and `IgnoredMethods` configuration is deprecated and only kept for backwards compatibility. Please use `AllowedMethods` and `AllowedPatterns` instead. By default, there are no methods to allowed."
    },
    "Metrics/ModuleLength": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "CountComments": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Max": {
          "type": "integer",
          "description": "Default: 100"
        },
        "CountAsOne": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks if the length of a module exceeds some maximum value. Comment lines can optionally be ignored. The maximum allowed length is configurable.\n\nYou can set constructs you want to fold with `CountAsOne`.\n\nAvailable are: 'array', 'hash', 'heredoc', and 'method_call'. Each construct will be counted as one line regardless of its actual size."
    },
    "Metrics/ParameterLists": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Max": {
          "type": "integer",
          "description": "Default: 5"
        },
        "CountKeywordArgs": {
          "type": "boolean",
          "description": "Default: true"
        },
        "MaxOptionalParameters": {
          "type": "integer",
          "description": "Default: 3"
        }
      },
      "description": "Checks for methods with too many parameters.\n\nThe maximum number of parameters is configurable. Keyword arguments can optionally be excluded from the total count, as they add less complexity than positional or optional parameters.\n\nAny number of arguments for `initialize` method inside a block of `Struct.new` and `Data.define` like this is always allowed:\n\nStruct.new(:one, :two, :three, :four, :five, keyword_init: true) do   def initialize(one:, two:, three:, four:, five:)   end end\n\nThis is because checking the number of arguments of the `initialize` method does not make sense.\n\nExplicit block argument `&block` is not counted to prevent erroneous change that is avoided by making block argument implicit.\n\nThis cop also checks for the maximum number of optional parameters. This can be configured using the `MaxOptionalParameters` config option."
    },
    "Metrics/PerceivedComplexity": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "Max": {
          "type": "integer",
          "description": "Default: 8"
        }
      },
      "description": "Tries to produce a complexity score that's a measure of the complexity the reader experiences when looking at a method. For that reason it considers `when` nodes as something that doesn't add as much complexity as an `if` or a `&&`. Except if it's one of those special `case`/`when` constructs where there's no expression after `case`. Then the cop treats it as an `if`/`elsif`/`elsif`... and lets all the `when` nodes count. In contrast to the CyclomaticComplexity cop, this cop considers `else` nodes as adding complexity."
    },
    "Migration": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "'Migration' department"
    },
    "Migration/DepartmentName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Check that cop names in rubocop:disable comments are given with department name."
    },
    "Naming": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "'Naming' department"
    },
    "Naming/AccessorMethodName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Avoid prefixing accessor method names with `get_` or `set_`. Applies to both instance and class methods.\n\nMethod names starting with `get_` or `set_` only register an offense when the methods match the expected arity for getters and setters respectively. Getters (`get_attribute`) must have no arguments to be registered, and setters (`set_attribute(value)`) must have exactly one."
    },
    "Naming/AsciiIdentifiers": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AsciiConstants": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "Checks for non-ascii characters in identifier and constant names. Identifiers are always checked and whether constants are checked can be controlled using AsciiConstants config."
    },
    "Naming/BinaryOperatorParameterName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Makes sure that certain binary operator methods have their sole  parameter named `other`."
    },
    "Naming/BlockForwarding": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["anonymous", "explicit"],
          "description": "Default: anonymous"
        },
        "BlockForwardingName": {
          "type": "string",
          "description": "Default: block"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: anonymous, explicit"
        }
      },
      "description": "In Ruby 3.1, anonymous block forwarding has been added.\n\nThis cop identifies places where `do_something(&block)` can be replaced by `do_something(&)`.\n\nIt also supports the opposite style by alternative `explicit` option. You can specify the block variable name for autocorrection with `BlockForwardingName`. The default variable name is `block`. If the name is already in use, it will not be autocorrected.\n\n"
    },
    "Naming/BlockParameterName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "MinNameLength": {
          "type": "integer",
          "description": "Default: 1"
        },
        "AllowNamesEndingInNumbers": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowedNames": {
          "type": "array",
          "description": "Default: []"
        },
        "ForbiddenNames": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks block parameter names for how descriptive they are. It is highly configurable.\n\nThe `MinNameLength` config option takes an integer. It represents the minimum amount of characters the name must be. Its default is 1. The `AllowNamesEndingInNumbers` config option takes a boolean. When set to false, this cop will register offenses for names ending with numbers. Its default is false. The `AllowedNames` config option takes an array of permitted names that will never register an offense. The `ForbiddenNames` config option takes an array of restricted names that will always register an offense."
    },
    "Naming/ClassAndModuleCamelCase": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedNames": {
          "type": "array",
          "description": "Default: module_parent"
        }
      },
      "description": "Checks for class and module names with an underscore in them.\n\n`AllowedNames` config takes an array of permitted names. Its default value is `['module_parent']`. These names can be full class/module names or part of the name. eg. Adding `my_class` to the `AllowedNames` config will allow names like `my_class`, `my_class::User`, `App::my_class`, `App::my_class::User`, etc."
    },
    "Naming/ConstantName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks whether constant names are written using SCREAMING_SNAKE_CASE.\n\nTo avoid false positives, it ignores cases in which we cannot know for certain the type of value that would be assigned to a constant."
    },
    "Naming/FileName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: Rakefile.rb"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "ExpectMatchingDefinition": {
          "type": "boolean",
          "description": "Default: false"
        },
        "CheckDefinitionPathHierarchy": {
          "type": "boolean",
          "description": "Default: true"
        },
        "CheckDefinitionPathHierarchyRoots": {
          "type": "array",
          "description": "Default: lib, spec, test, src"
        },
        "Regex": {
          "description": "Default: <none>"
        },
        "IgnoreExecutableScripts": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowedAcronyms": {
          "type": "array",
          "description": "Default: CLI, DSL, ACL, API, ASCII, CPU, CSS, DNS, EOF, GUID, HTML, HTTP, HTTPS, ID, IP, JSON, LHS, QPS, RAM, RHS, RPC, SLA, SMTP, SQL, SSH, TCP, TLS, TTL, UDP, UI, UID, UUID, URI, URL, UTF8, VM, XML, XMPP, XSRF, XSS"
        }
      },
      "description": "Makes sure that Ruby source files have snake_case names. Ruby scripts (i.e. source files with a shebang in the first line) are ignored.\n\nThe cop also ignores `.gemspec` files, because Bundler recommends using dashes to separate namespaces in nested gems (i.e. `bundler-console` becomes `Bundler::Console`). As such, the gemspec is supposed to be named `bundler-console.gemspec`.\n\nWhen `ExpectMatchingDefinition` (default: `false`) is `true`, the cop requires each file to have a class, module or `Struct` defined in it that matches the filename. This can be further configured using `CheckDefinitionPathHierarchy` (default: `true`) to determine whether the path should match the namespace of the above definition.\n\nWhen `IgnoreExecutableScripts` (default: `true`) is `true`, files that start with a shebang line are not considered by the cop.\n\nWhen `Regex` is set, the cop will flag any filename that does not match the regular expression."
    },
    "Naming/HeredocDelimiterCase": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["lowercase", "uppercase"],
          "description": "Default: uppercase"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: lowercase, uppercase"
        }
      },
      "description": "Checks that your heredocs are using the configured case. By default it is configured to enforce uppercase heredocs."
    },
    "Naming/HeredocDelimiterNaming": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "ForbiddenDelimiters": {
          "type": "array",
          "description": "Default: (?i-mx:(^|\\s)(EO[A-Z]{1}|END)(\\s|$))"
        }
      },
      "description": "Checks that your heredocs are using meaningful delimiters. By default it disallows `END` and `EO*`, and can be configured through forbidden listing additional delimiters."
    },
    "Naming/InclusiveLanguage": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "CheckIdentifiers": {
          "type": "boolean",
          "description": "Default: true"
        },
        "CheckConstants": {
          "type": "boolean",
          "description": "Default: true"
        },
        "CheckVariables": {
          "type": "boolean",
          "description": "Default: true"
        },
        "CheckStrings": {
          "type": "boolean",
          "description": "Default: false"
        },
        "CheckSymbols": {
          "type": "boolean",
          "description": "Default: true"
        },
        "CheckComments": {
          "type": "boolean",
          "description": "Default: true"
        },
        "CheckFilepaths": {
          "type": "boolean",
          "description": "Default: true"
        },
        "FlaggedTerms": {
          "description": "Default: {\"whitelist\" ⇒ {\"Regex\" ⇒ /white[-\\s]?list/, \"Suggestions\" ⇒ [\"allowlist\", \"permit\"]}, \"blacklist\" ⇒ {\"Regex\" ⇒ /black[-\\s]?list/, \"Suggestions\" ⇒ [\"denylist\", \"block\"]}, \"slave\" ⇒ {\"WholeWord\" ⇒ true, \"Suggestions\" ⇒ [\"replica\", \"secondary\", \"follower\"]}}"
        }
      },
      "description": "Recommends the use of inclusive language instead of problematic terms. The cop can check the following locations for offenses:\n\n - identifiers\n\n - constants\n\n - variables\n\n - strings\n\n - symbols\n\n - comments\n\n - file paths\n\nEach of these locations can be individually enabled/disabled via configuration, for example CheckIdentifiers = true/false.\n\nFlagged terms are configurable for the cop. For each flagged term an optional Regex can be specified to identify offenses. Suggestions for replacing a flagged term can be configured and will be displayed as part of the offense message. An AllowedRegex can be specified for a flagged term to exempt allowed uses of the term. `WholeWord: true` can be set on a flagged term to indicate the cop should only match when a term matches the whole word (partial matches will not be offenses).\n\nThe cop supports autocorrection when there is only one suggestion. When there are multiple suggestions, the best suggestion cannot be identified and will not be autocorrected."
    },
    "Naming/MemoizedInstanceVariableName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyleForLeadingUnderscores": {
          "enum": ["disallowed", "required", "optional"],
          "description": "Default: disallowed"
        },
        "SupportedStylesForLeadingUnderscores": {
          "type": "array",
          "description": "Default: disallowed, required, optional"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for memoized methods whose instance variable name does not match the method name. Applies to both regular methods (defined with `def`) and dynamic methods (defined with `define_method` or `define_singleton_method`).\n\nThis cop can be configured with the EnforcedStyleForLeadingUnderscores directive. It can be configured to allow for memoized instance variables prefixed with an underscore. Prefixing ivars with an underscore is a convention that is used to implicitly indicate that an ivar should not be set or referenced outside of the memoization method."
    },
    "Naming/MethodName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["snake_case", "camelCase"],
          "description": "Default: snake_case"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: snake_case, camelCase"
        }
      },
      "description": "Makes sure that all methods use the configured style, snake_case or camelCase, for their names.\n\nThis cop has `AllowedPatterns` configuration option.\n\n  Naming/MethodName:\n    AllowedPatterns:\n      - '\\AonSelectionBulkChange\\z'\n      - '\\AonSelectionCleared\\z'\n\nMethod names matching patterns are always allowed."
    },
    "Naming/MethodParameterName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "MinNameLength": {
          "type": "integer",
          "description": "Default: 3"
        },
        "AllowNamesEndingInNumbers": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowedNames": {
          "type": "array",
          "description": "Default: as, at, by, cc, db, id, if, in, io, ip, of, on, os, pp, to"
        },
        "ForbiddenNames": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks method parameter names for how descriptive they are. It is highly configurable.\n\nThe `MinNameLength` config option takes an integer. It represents the minimum amount of characters the name must be. Its default is 3. The `AllowNamesEndingInNumbers` config option takes a boolean. When set to false, this cop will register offenses for names ending with numbers. Its default is false. The `AllowedNames` config option takes an array of permitted names that will never register an offense. The `ForbiddenNames` config option takes an array of restricted names that will always register an offense."
    },
    "Naming/PredicateName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: spec/**/*"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "NamePrefix": {
          "type": "array",
          "description": "Default: is_, has_, have_"
        },
        "ForbiddenPrefixes": {
          "type": "array",
          "description": "Default: is_, has_, have_"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: is_a?"
        },
        "MethodDefinitionMacros": {
          "type": "array",
          "description": "Default: define_method, define_singleton_method"
        },
        "UseSorbetSigs": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks that predicate method names end with a question mark and do not start with a forbidden prefix.\n\nA method is determined to be a predicate method if its name starts with one of the prefixes listed in the `NamePrefix` configuration. The list defaults to `is_`, `has_`, and `have_` but may be overridden.\n\nPredicate methods must end with a question mark.\n\nWhen `ForbiddenPrefixes` is also set (as it is by default), predicate methods which begin with a forbidden prefix are not allowed, even if they end with a `?`. These methods should be changed to remove the prefix.\n\nWhen `UseSorbetSigs` set to true (optional), the cop will only report offenses if the method has a Sorbet `sig` with a return type of `T::Boolean`. Dynamic methods are not supported with this configuration."
    },
    "Naming/RescuedExceptionsVariableName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "PreferredName": {
          "type": "string",
          "description": "Default: e"
        }
      },
      "description": "Makes sure that rescued exceptions variables are named as expected.\n\nThe `PreferredName` config option takes a `String`. It represents the required name of the variable. Its default is `e`.\n\nThis cop does not consider nested rescues because it cannot guarantee that the variable from the outer rescue is not used within the inner rescue (in which case, changing the inner variable would shadow the outer variable)."
    },
    "Naming/VariableName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["snake_case", "camelCase"],
          "description": "Default: snake_case"
        },
        "AllowedIdentifiers": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "ForbiddenIdentifiers": {
          "type": "array",
          "description": "Default: []"
        },
        "ForbiddenPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: snake_case, camelCase"
        }
      },
      "description": "Checks that the configured style (snake_case or camelCase) is used for all variable names. This includes local variables, instance variables, class variables, method arguments (positional, keyword, rest or block), and block arguments.\n\nThe cop can also be configured to forbid using specific names for variables, using `ForbiddenIdentifiers` or `ForbiddenPatterns`. In addition to the above, this applies to global variables as well.\n\nMethod definitions and method calls are not affected by this cop."
    },
    "Naming/VariableNumber": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["snake_case", "normalcase", "non_integer"],
          "description": "Default: normalcase"
        },
        "CheckMethodNames": {
          "type": "boolean",
          "description": "Default: true"
        },
        "CheckSymbols": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowedIdentifiers": {
          "type": "array",
          "description": "Default: TLS1_1, TLS1_2, capture3, iso8601, rfc1123_date, rfc822, rfc2822, rfc3339, x86_64"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: snake_case, normalcase, non_integer"
        }
      },
      "description": "Makes sure that all numbered variables use the configured style, snake_case, normalcase, or non_integer, for their numbering.\n\nAdditionally, `CheckMethodNames` and `CheckSymbols` configuration options can be used to specify whether method names and symbols should be checked. Both are enabled by default."
    },
    "Security": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "'Security' department"
    },
    "Security/CompoundHash": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for implementations of the `hash` method which combine values using custom logic instead of delegating to `Array#hash`.\n\nManually combining hashes is error prone and hard to follow, especially when there are many values. Poor implementations may also introduce performance or security concerns if they are prone to collisions. Delegating to `Array#hash` is clearer and safer, although it might be slower depending on the use case."
    },
    "Security/Eval": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for the use of `Kernel#eval` and `Binding#eval`."
    },
    "Security/IoMethods": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for the first argument to `IO.read`, `IO.binread`, `IO.write`, `IO.binwrite`, `IO.foreach`, and `IO.readlines`.\n\nIf argument starts with a pipe character (`'|'`) and the receiver is the `IO` class, a subprocess is created in the same way as `Kernel#open`, and its output is returned. `Kernel#open` may allow unintentional command injection, which is the reason these `IO` methods are a security risk. Consider to use `File.read` to disable the behavior of subprocess invocation."
    },
    "Security/JSONLoad": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://ruby-doc.org/stdlib-2.7.0/libdoc/json/rdoc/JSON.html#method-i-load"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for the use of JSON class methods which have potential security issues."
    },
    "Security/MarshalLoad": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://ruby-doc.org/core-2.7.0/Marshal.html#module-Marshal-label-Security+considerations"
        }
      },
      "description": "Checks for the use of Marshal class methods which have potential security issues leading to remote code execution when loading from an untrusted source."
    },
    "Security/Open": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for the use of `Kernel#open` and `URI.open` with dynamic data.\n\n`Kernel#open` and `URI.open` enable not only file access but also process invocation by prefixing a pipe symbol (e.g., `open(\"| ls\")`). So, it may lead to a serious security risk by using variable input to the argument of `Kernel#open` and `URI.open`. It would be better to use `File.open`, `IO.popen` or `URI.parse#open` explicitly.\n\n`open` and `URI.open` with literal strings are not flagged by this cop."
    },
    "Security/YAMLLoad": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://ruby-doc.org/stdlib-2.7.0/libdoc/yaml/rdoc/YAML.html#module-YAML-label-Security"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for the use of YAML class methods which have potential security issues leading to remote code execution when loading from an untrusted source.\n\nRuby 3.1+ (Psych 4) uses `Psych.load` as `Psych.safe_load` by default."
    },
    "Style": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "'Style' department"
    },
    "Style/AccessModifierDeclarations": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["inline", "group"],
          "description": "Default: group"
        },
        "AllowModifiersOnSymbols": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowModifiersOnAttrs": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowModifiersOnAliasMethod": {
          "type": "boolean",
          "description": "Default: true"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: inline, group"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Access modifiers should be declared to apply to a group of methods or inline before each method, depending on configuration. EnforcedStyle config covers only method definitions. Applications of visibility methods to symbols can be controlled using AllowModifiersOnSymbols config. Also, the visibility of `attr*` methods can be controlled using AllowModifiersOnAttrs config.\n\nIn Ruby 3.0, `attr*` methods now return an array of defined method names as symbols. So we can write the modifier and `attr*` in inline style. AllowModifiersOnAttrs config allows `attr*` methods to be written in inline style without modifying applications that have been maintained for a long time in group style. Furthermore, developers who are not very familiar with Ruby may know that the modifier applies to `def`, but they may not know that it also applies to `attr*` methods. It would be easier to understand if we could write `attr*` methods in inline style."
    },
    "Style/AccessorGrouping": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["separated", "grouped"],
          "description": "Default: grouped"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: separated, grouped"
        }
      },
      "description": "Checks for grouping of accessors in `class` and `module` bodies. By default it enforces accessors to be placed in grouped declarations, but it can be configured to enforce separating them in multiple declarations.\n\nIf there is a method call before the accessor method it is always allowed as it might be intended like Sorbet.\n\nIf there is a RBS::Inline annotation comment just after the accessor method it is always allowed."
    },
    "Style/Alias": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["prefer_alias", "prefer_alias_method"],
          "description": "Default: prefer_alias"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: prefer_alias, prefer_alias_method"
        }
      },
      "description": "Enforces the use of either `#alias` or `#alias_method` depending on configuration. It also flags uses of `alias :symbol` rather than `alias bareword`.\n\nHowever, it will always enforce `method_alias` when used `alias` in an instance method definition and in a singleton method definition. If used in a block, always enforce `alias_method` unless it is an `instance_eval` block."
    },
    "Style/AmbiguousEndlessMethodDefinition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Looks for endless methods inside operations of lower precedence (`and`, `or`, and modifier forms of `if`, `unless`, `while`, `until`) that are ambiguous due to lack of parentheses. This may lead to unexpected behavior as the code may appear to use these keywords as part of the method but in fact they modify the method definition itself.\n\nIn these cases, using a normal method definition is more clear."
    },
    "Style/AndOr": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["always", "conditionals"],
          "description": "Default: conditionals"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: always, conditionals"
        }
      },
      "description": "Checks for uses of `and` and `or`, and suggests using `&&` and `||` instead. It can be configured to check only in conditions or in all contexts."
    },
    "Style/ArgumentsForwarding": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowOnlyRestArgument": {
          "type": "boolean",
          "description": "Default: true"
        },
        "UseAnonymousForwarding": {
          "type": "boolean",
          "description": "Default: true"
        },
        "RedundantRestArgumentNames": {
          "type": "array",
          "description": "Default: args, arguments"
        },
        "RedundantKeywordRestArgumentNames": {
          "type": "array",
          "description": "Default: kwargs, options, opts"
        },
        "RedundantBlockArgumentNames": {
          "type": "array",
          "description": "Default: blk, block, proc"
        }
      },
      "description": "In Ruby 2.7, arguments forwarding has been added.\n\nThis cop identifies places where `do_something(*args, &block)` can be replaced by `do_something(...)`.\n\nIn Ruby 3.1, anonymous block forwarding has been added.\n\nThis cop identifies places where `do_something(&block)` can be replaced by `do_something(&)`; if desired, this functionality can be disabled by setting `UseAnonymousForwarding: false`.\n\nIn Ruby 3.2, anonymous args/kwargs forwarding has been added.\n\nThis cop also identifies places where `use_args(*args)`/`use_kwargs(**kwargs)` can be replaced by `use_args(*)`/`use_kwargs(**)`; if desired, this functionality can be disabled by setting `UseAnonymousForwarding: false`.\n\nAnd this cop has `RedundantRestArgumentNames`, `RedundantKeywordRestArgumentNames`, and `RedundantBlockArgumentNames` options. This configuration is a list of redundant names that are sufficient for anonymizing meaningless naming.\n\nMeaningless names that are commonly used can be anonymized by default: e.g., `*args`, `**options`, `&block`, and so on.\n\nNames not on this list are likely to be meaningful and are allowed by default.\n\nThis cop handles not only method forwarding but also forwarding to `super`.\n\n"
    },
    "Style/ArrayCoercion": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Enforces the use of `Array()` instead of explicit `Array` check or `[*var]`.\n\nThe cop is disabled by default due to safety concerns."
    },
    "Style/ArrayFirstLast": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: #first-and-last"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Identifies usages of `arr[0]` and `arr[-1]` and suggests to change them to use `arr.first` and `arr.last` instead.\n\nThe cop is disabled by default due to safety concerns."
    },
    "Style/ArrayIntersect": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "In Ruby 3.1, `Array#intersect?` has been added.\n\nThis cop identifies places where `(array1 & array2).any?` can be replaced by `array1.intersect?(array2)`.\n\nThe `array1.intersect?(array2)` method is faster than `(array1 & array2).any?` and is more readable.\n\nIn cases like the following, compatibility is not ensured, so it will not be detected when using block argument.\n\n([1] & [1,2]).any? { |x| false }    # => false [1].intersect?([1,2]) { |x| false } # => true"
    },
    "Style/ArrayJoin": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for uses of \"*\" as a substitute for _join_.\n\nNot all cases can reliably checked, due to Ruby's dynamic types, so we consider only cases when the first argument is an array literal or the second is a string literal."
    },
    "Style/AsciiComments": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedChars": {
          "type": "array",
          "description": "Default: ©"
        }
      },
      "description": "Checks for non-ascii (non-English) characters in comments. You could set an array of allowed non-ascii chars in `AllowedChars` attribute (copyright notice \"©\" by default)."
    },
    "Style/Attr": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for uses of Module#attr."
    },
    "Style/AutoResourceCleanup": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for cases when you could use a block accepting version of a method that does automatic resource cleanup."
    },
    "Style/BarePercentLiterals": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["percent_q", "bare_percent"],
          "description": "Default: bare_percent"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: percent_q, bare_percent"
        }
      },
      "description": "Checks if usage of %() or %Q() matches configuration."
    },
    "Style/BeginBlock": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for BEGIN blocks."
    },
    "Style/BisectedAttrAccessor": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for places where `attr_reader` and `attr_writer` for the same method can be combined into single `attr_accessor`."
    },
    "Style/BitwisePredicate": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Prefer bitwise predicate methods over direct comparison operations."
    },
    "Style/BlockComments": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Looks for uses of block comments (=begin...=end)."
    },
    "Style/BlockDelimiters": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "line_count_based",
            "semantic",
            "braces_for_chaining",
            "always_braces"
          ],
          "description": "Default: line_count_based"
        },
        "ProceduralMethods": {
          "type": "array",
          "description": "Default: benchmark, bm, bmbm, create, each_with_object, measure, new, realtime, tap, with_object"
        },
        "FunctionalMethods": {
          "type": "array",
          "description": "Default: let, let!, subject, watch"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: lambda, proc, it"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowBracesOnProceduralOneLiners": {
          "type": "boolean",
          "description": "Default: false"
        },
        "BracesRequiredMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: line_count_based, semantic, braces_for_chaining, always_braces"
        }
      },
      "description": "Check for uses of braces or do/end around single line or multi-line blocks.\n\nMethods that can be either procedural or functional and cannot be categorised from their usage alone is ignored. `lambda`, `proc`, and `it` are their defaults. Additional methods can be added to the `AllowedMethods`."
    },
    "Style/CaseEquality": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowOnConstant": {
          "type": "boolean",
          "description": "Default: false"
        },
        "AllowOnSelfClass": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "If `AllowOnSelfClass` option is enabled, the cop will ignore violations when the receiver of the case equality operator is `self.class`. Note intermediate variables are not accepted."
    },
    "Style/CaseLikeIf": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "MinBranchesCount": {
          "type": "integer",
          "description": "Default: 3"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Identifies places where `if-elsif` constructions can be replaced with `case-when`."
    },
    "Style/CharacterLiteral": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for uses of the character literal ?x. Starting with Ruby 1.9 character literals are essentially one-character strings, so this syntax is mostly redundant at this point.\n\n? character literal can be used to express meta and control character. That's a good use case of ? literal so it doesn't count it as an offense."
    },
    "Style/ClassAndModuleChildren": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["nested", "compact"],
          "description": "Default: nested"
        },
        "EnforcedStyleForClasses": {
          "enum": ["<none>", "nested", "compact"],
          "description": "Default: <none>"
        },
        "EnforcedStyleForModules": {
          "enum": ["<none>", "nested", "compact"],
          "description": "Default: <none>"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: nested, compact"
        },
        "SupportedStylesForClasses": {
          "type": "array",
          "description": "Default: , nested, compact"
        },
        "SupportedStylesForModules": {
          "type": "array",
          "description": "Default: , nested, compact"
        }
      },
      "description": "Checks that namespaced classes and modules are defined with a consistent style.\n\nWith `nested` style, classes and modules should be defined separately (one constant on each line, without `::`). With `compact` style, classes and modules should be defined with fully qualified names (using `::` for namespaces).\n\nThe style chosen will affect `Module.nesting` for the class or module. Using `nested` style will result in each level being added, whereas `compact` style will only include the fully qualified class or module name.\n\nBy default, `EnforcedStyle` applies to both classes and modules. If desired, separate styles can be defined for classes and modules by using `EnforcedStyleForClasses` and `EnforcedStyleForModules` respectively. If not set, or set to nil, the `EnforcedStyle` value will be used.\n\nThe compact style is only forced for classes/modules with one child."
    },
    "Style/ClassCheck": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["is_a?", "kind_of?"],
          "description": "Default: is_a?"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: is_a?, kind_of?"
        }
      },
      "description": "Enforces consistent use of `Object#is_a?` or `Object#kind_of?`."
    },
    "Style/ClassEqualityComparison": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: ==, equal?, eql?"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Enforces the use of `Object#instance_of?` instead of class comparison for equality. `==`, `equal?`, and `eql?` custom method definitions are allowed by default. These are customizable with `AllowedMethods` option."
    },
    "Style/ClassMethods": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for uses of the class/module name instead of self, when defining class/module methods."
    },
    "Style/ClassMethodsDefinitions": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["def_self", "self_class"],
          "description": "Default: def_self"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: def_self, self_class"
        }
      },
      "description": "Enforces using `def self.method_name` or `class << self` to define class methods."
    },
    "Style/ClassVars": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for uses of class variables. Offenses are signaled only on assignment to class variables to reduce the number of offenses that would be reported.\n\nYou have to be careful when setting a value for a class variable; if a class has been inherited, changing the value of a class variable also affects the inheriting classes. This means that it's almost always better to use a class instance variable instead."
    },
    "Style/CollectionCompact": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedReceivers": {
          "type": "array",
          "description": "Default: []"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for places where custom logic on rejection nils from arrays and hashes can be replaced with `{Array,Hash}#{compact,compact!}`."
    },
    "Style/CollectionMethods": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "PreferredMethods": {
          "description": "Default: {\"collect\" ⇒ \"map\", \"collect!\" ⇒ \"map!\", \"collect_concat\" ⇒ \"flat_map\", \"inject\" ⇒ \"reduce\", \"detect\" ⇒ \"find\", \"find_all\" ⇒ \"select\", \"member?\" ⇒ \"include?\"}"
        },
        "MethodsAcceptingSymbol": {
          "type": "array",
          "description": "Default: inject, reduce"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Enforces the use of consistent method names from the Enumerable module.\n\nYou can customize the mapping from undesired method to desired method.\n\ne.g. to use `detect` over `find`:\n\n  Style/CollectionMethods:\n    PreferredMethods:\n      find: detect"
    },
    "Style/ColonMethodCall": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for methods invoked via the `::` operator instead of the `.` operator (like `FileUtils::rmdir` instead of `FileUtils.rmdir`)."
    },
    "Style/ColonMethodDefinition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for class methods that are defined using the `::` operator instead of the `.` operator."
    },
    "Style/CombinableDefined": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for multiple `defined?` calls joined by `&&` that can be combined into a single `defined?`.\n\nWhen checking that a nested constant or chained method is defined, it is not necessary to check each ancestor or component of the chain."
    },
    "Style/CombinableLoops": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for places where multiple consecutive loops over the same data can be combined into a single loop. It is very likely that combining them will make the code more efficient and more concise.\n\nAutocorrection is not applied when the block variable names differ in separate loops, as it is impossible to determine which variable name should be prioritized."
    },
    "Style/CommandLiteral": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["backticks", "percent_x", "mixed"],
          "description": "Default: backticks"
        },
        "AllowInnerBackticks": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: backticks, percent_x, mixed"
        }
      },
      "description": "Enforces using `` or %x around command literals."
    },
    "Style/CommentAnnotation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Keywords": {
          "type": "array",
          "description": "Default: TODO, FIXME, OPTIMIZE, HACK, REVIEW, NOTE"
        },
        "RequireColon": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "Checks that comment annotation keywords are written according to guidelines.\n\nAnnotation keywords can be specified by overriding the cop's `Keywords` configuration. Keywords are allowed to be single words or phrases.\n\nWith a multiline comment block (where each line is only a comment), only the first line will be able to register an offense, even if an annotation keyword starts another line. This is done to prevent incorrect registering of keywords (eg. `review`) inside a paragraph as an annotation."
    },
    "Style/CommentedKeyword": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for comments put on the same line as some keywords. These keywords are: `class`, `module`, `def`, `begin`, `end`.\n\nNote that some comments (`:nodoc:`, `:yields:`, `rubocop:disable` and `rubocop:todo`), RBS::Inline annotation, and Steep annotation (`steep:ignore`) are allowed.\n\nAutocorrection removes comments from `end` keyword and keeps comments for `class`, `module`, `def` and `begin` above the keyword."
    },
    "Style/ComparableBetween": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for logical comparison which can be replaced with `Comparable#between?`.\n\n`Comparable#between?` is on average slightly slower than logical comparison, although the difference generally isn't observable. If you require maximum performance, consider using logical comparison."
    },
    "Style/ComparableClamp": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Enforces the use of `Comparable#clamp` instead of comparison by minimum and maximum.\n\nThis cop supports autocorrection for `if/elsif/else` bad style only. Because `ArgumentError` occurs if the minimum and maximum of `clamp` arguments are reversed. When these are variables, it is not possible to determine which is the minimum and maximum:\n\n[1, [2, 3].max].min # => 1 1.clamp(3, 1)       # => min argument must be smaller than max argument (ArgumentError)"
    },
    "Style/ConcatArrayLiterals": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Enforces the use of `Array#push(item)` instead of `Array#concat([item])` to avoid redundant array literals."
    },
    "Style/ConditionalAssignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["assign_to_condition", "assign_inside_condition"],
          "description": "Default: assign_to_condition"
        },
        "SingleLineConditionsOnly": {
          "type": "boolean",
          "description": "Default: true"
        },
        "IncludeTernaryExpressions": {
          "type": "boolean",
          "description": "Default: true"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: assign_to_condition, assign_inside_condition"
        }
      },
      "description": "Check for `if` and `case` statements where each branch is used for both the assignment and comparison of the same variable when using the return of the condition can be used instead."
    },
    "Style/ConstantVisibility": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "IgnoreModules": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks that constants defined in classes and modules have an explicit visibility declaration. By default, Ruby makes all class- and module constants public, which litters the public API of the class or module. Explicitly declaring a visibility makes intent more clear, and prevents outside actors from touching private state."
    },
    "Style/Copyright": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Notice": {
          "type": "string",
          "description": "Default: ^Copyright (\\(c\\) )?2[0-9]{3} .+"
        },
        "AutocorrectNotice": {
          "type": "string",
          "description": "Default: ``"
        }
      },
      "description": "Check that a copyright notice was given in each source file.\n\nThe default regexp for an acceptable copyright notice can be found in config/default.yml. The default can be changed as follows:\n\nStyle/Copyright:   Notice: '^Copyright (\\(c\\) )?2\\d{3} Acme Inc'\n\nThis regex string is treated as an unanchored regex. For each file that RuboCop scans, a comment that matches this regex must be found or an offense is reported."
    },
    "Style/DataInheritance": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for inheritance from `Data.define` to avoid creating the anonymous parent class."
    },
    "Style/DateTime": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowCoercion": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for consistent usage of the `DateTime` class over the `Time` class. This cop is disabled by default since these classes, although highly overlapping, have particularities that make them not replaceable in certain situations when dealing with multiple timezones and/or DST."
    },
    "Style/DefWithParentheses": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for parentheses in the definition of a method, that does not take any arguments. Both instance and class/singleton methods are checked."
    },
    "Style/DigChain": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Check for chained `dig` calls that can be collapsed into a single `dig`."
    },
    "Style/Dir": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for places where the `#\\_\\_dir\\_\\_` method can replace more complex constructs to retrieve a canonicalized absolute path to the current file."
    },
    "Style/DirEmpty": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Prefer to use `Dir.empty?('path/to/dir')` when checking if a directory is empty."
    },
    "Style/DisableCopsWithinSourceCodeDirective": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedCops": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Detects comments to enable/disable RuboCop. This is useful if want to make sure that every RuboCop error gets fixed and not quickly disabled with a comment.\n\nSpecific cops can be allowed with the `AllowedCops` configuration. Note that if this configuration is set, `rubocop:disable all` is still disallowed."
    },
    "Style/DocumentDynamicEvalDefinition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "When using `class_eval` (or other `eval`) with string interpolation, add a comment block showing its appearance if interpolated (a practice used in Rails code)."
    },
    "Style/Documentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: spec/**/*, test/**/*"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedConstants": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks for missing top-level documentation of classes and modules. Classes with no body are exempt from the check and so are namespace modules - modules that have nothing in their bodies except classes, other modules, constant definitions or constant visibility declarations.\n\nThe documentation requirement is annulled if the class or module has a `#:nodoc:` comment next to it. Likewise, `#:nodoc: all` does the same for all its children."
    },
    "Style/DocumentationMethod": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: spec/**/*, test/**/*"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "RequireForNonPublicMethods": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for missing documentation comment for public methods. It can optionally be configured to also require documentation for non-public methods.\n\nThis cop allows `initialize` method because `initialize` is a special method called from `new`. In some programming languages they are called constructor to distinguish it from method."
    },
    "Style/DoubleCopDisableDirective": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Detects double disable comments on one line. This is mostly to catch automatically generated comments that need to be regenerated."
    },
    "Style/DoubleNegation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["allowed_in_returns", "forbidden"],
          "description": "Default: allowed_in_returns"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: allowed_in_returns, forbidden"
        }
      },
      "description": "Checks for uses of double negation (`!!`) to convert something to a boolean value.\n\nWhen using `EnforcedStyle: allowed_in_returns`, allow double negation in contexts that use boolean as a return value. When using `EnforcedStyle: forbidden`, double negation should be forbidden always.\n\nwhen `something` is a boolean value `!!something` and `!something.nil?` are not the same thing. As you're unlikely to write code that can accept values of any type this is rarely a problem in practice."
    },
    "Style/EachForSimpleLoop": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for loops which iterate a constant number of times, using a `Range` literal and `#each`. This can be done more readably using `Integer#times`.\n\nThis check only applies if the block takes no parameters."
    },
    "Style/EachWithObject": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Looks for inject / reduce calls where the passed in object is returned at the end and so could be replaced by each_with_object without the need to return the object at the end.\n\nHowever, we can't replace with each_with_object if the accumulator parameter is assigned to within the block."
    },
    "Style/EmptyBlockParameter": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for pipes for empty block parameters. Pipes for empty block parameters do not cause syntax errors, but they are redundant."
    },
    "Style/EmptyCaseCondition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for case statements with an empty condition."
    },
    "Style/EmptyElse": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["empty", "nil", "both"],
          "description": "Default: both"
        },
        "AllowComments": {
          "type": "boolean",
          "description": "Default: false"
        },
        "AutoCorrect": {
          "type": "string",
          "description": "Default: contextual"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: empty, nil, both"
        }
      },
      "description": "Checks for empty else-clauses, possibly including comments and/or an explicit `nil` depending on the EnforcedStyle."
    },
    "Style/EmptyHeredoc": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "string",
          "description": "Default: contextual"
        }
      },
      "description": "Checks for using empty heredoc to reduce redundancy."
    },
    "Style/EmptyLambdaParameter": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for parentheses for empty lambda parameters. Parentheses for empty lambda parameters do not cause syntax errors, but they are redundant."
    },
    "Style/EmptyLiteral": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for the use of a method, the result of which would be a literal, like an empty array, hash, or string."
    },
    "Style/EmptyMethod": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["compact", "expanded"],
          "description": "Default: compact"
        },
        "AutoCorrect": {
          "type": "string",
          "description": "Default: contextual"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: compact, expanded"
        }
      },
      "description": "Checks for the formatting of empty method definitions. By default it enforces empty method definitions to go on a single line (compact style), but it can be configured to enforce the `end` to go on its own line (expanded style).\n\nA method definition is not considered empty if it contains comments.\n\nAutocorrection will not be applied for the `compact` style if the resulting code is longer than the `Max` configuration for `Layout/LineLength`, but an offense will still be registered."
    },
    "Style/Encoding": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks ensures source files have no utf-8 encoding comments."
    },
    "Style/EndBlock": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for END blocks."
    },
    "Style/EndlessMethod": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "allow_single_line",
            "allow_always",
            "disallow",
            "require_single_line",
            "require_always"
          ],
          "description": "Default: allow_single_line"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: allow_single_line, allow_always, disallow, require_single_line, require_always"
        }
      },
      "description": "Checks for endless methods.\n\nIt can enforce endless method definitions whenever possible or with single line methods. It can also disallow multiline endless method definitions or all endless definitions.\n\n`require_single_line` style enforces endless method definitions for single line methods. `require_always` style enforces endless method definitions for single statement methods.\n\nOther method definition types are not considered by this cop.\n\nThe supported styles are:\n\n - allow_single_line (default) - only single line endless method definitions are allowed.\n\n - allow_always - all endless method definitions are allowed.\n\n - disallow - all endless method definitions are disallowed.\n\n - require_single_line - endless method definitions are required for single line methods.\n\n - require_always - all endless method definitions are required.\n\nIncorrect endless method definitions will always be corrected to a multi-line definition."
    },
    "Style/EnvHome": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for consistent usage of `ENV['HOME']`. If `nil` is used as the second argument of `ENV.fetch`, it is treated as a bad case like `ENV[]`."
    },
    "Style/EvalWithLocation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Ensures that eval methods (`eval`, `instance_eval`, `class_eval` and `module_eval`) are given filename and line number values (`\\_\\_FILE\\_\\_` and `\\_\\_LINE\\_\\_`). This data is used to ensure that any errors raised within the evaluated code will be given the correct identification in a backtrace.\n\nThe cop also checks that the line number given relative to `\\_\\_LINE\\_\\_` is correct.\n\nThis cop will autocorrect incorrect or missing filename and line number values. However, if `eval` is called without a binding argument, the cop will not attempt to automatically add a binding, or add filename and line values.\n\nThis cop works only when a string literal is given as a code string. No offense is reported if a string variable is given as below:\n\ncode = <<-RUBY   def do_something   end RUBY eval code # not checked."
    },
    "Style/EvenOdd": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for places where `Integer#even?` or `Integer#odd?` can be used."
    },
    "Style/ExactRegexpMatch": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for exact regexp match inside `Regexp` literals."
    },
    "Style/ExpandPathArguments": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for use of the `File.expand_path` arguments. Likewise, it also checks for the `Pathname.new` argument.\n\nContrastive bad case and good case are alternately shown in the following examples."
    },
    "Style/ExplicitBlockArgument": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Enforces the use of explicit block argument to avoid writing block literal that just passes its arguments to another block.\n\nThis cop only registers an offense if the block args match the yield args exactly."
    },
    "Style/ExponentialNotation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["scientific", "engineering", "integral"],
          "description": "Default: scientific"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: scientific, engineering, integral"
        }
      },
      "description": "Enforces consistency when using exponential notation for numbers in the code (eg 1.2e4). Different styles are supported:\n\n - scientific which enforces a mantissa between 1 (inclusive) and 10 (exclusive).\n\n - engineering which enforces the exponent to be a multiple of 3 and the mantissa to be between 0.1 (inclusive) and 1000 (exclusive).\n\n - integral which enforces the mantissa to always be a whole number without trailing zeroes."
    },
    "Style/FetchEnvVar": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedVars": {
          "type": "array",
          "description": "Default: []"
        },
        "Reference": {
          "type": "array",
          "description": "Default: https://rubystyle.guide/#hash-fetch-defaults"
        }
      },
      "description": "Suggests `ENV.fetch` for the replacement of `ENV[]`. `ENV[]` silently fails and returns `nil` when the environment variable is unset, which may cause unexpected behaviors when the developer forgets to set it. On the other hand, `ENV.fetch` raises `KeyError` or returns the explicitly specified default value."
    },
    "Style/FileEmpty": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Prefer to use `File.empty?('path/to/file')` when checking if a file is empty."
    },
    "Style/FileNull": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Use `File::NULL` instead of hardcoding the null device (`/dev/null` on Unix-like OSes, `NUL` or `NUL:` on Windows), so that code is platform independent. Only looks for full string matches, substrings within a longer string are not considered.\n\nHowever, only files that use the string `'/dev/null'` are targeted for detection. This is because the string `'NUL'` is not limited to the null device. This behavior results in false negatives when the `'/dev/null'` string is not used, but it is a trade-off to avoid false positives. `NULL:` Unlike `'NUL'`, `'NUL:'` is regarded as something like `C:` and is always detected.\n\nUses inside arrays and hashes are ignored."
    },
    "Style/FileRead": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Favor `File.(bin)read` convenience methods."
    },
    "Style/FileTouch": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for usage of `File.open` in append mode with empty block.\n\nSuch a usage only creates a new file, but it doesn't update timestamps for an existing file, which might have been the intention.\n\nFor example, for an existing file `foo.txt`:\n\n  ruby -e \"puts File.mtime('foo.txt')\"\n  # 2024-11-26 12:17:23 +0100\n\n  ruby -e \"File.open('foo.txt', 'a') {}\"\n\n  ruby -e \"puts File.mtime('foo.txt')\"\n  # 2024-11-26 12:17:23 +0100 -> unchanged\n\nIf the intention was to update timestamps, `FileUtils.touch('foo.txt')` should be used instead."
    },
    "Style/FileWrite": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Favor `File.(bin)write` convenience methods.\n\nThere are different method signatures between `File.write` (class method) and `File#write` (instance method). The following case will be allowed because static analysis does not know the contents of the splat argument:\n\nFile.open(filename, 'w') do |f|   f.write(*objects) end"
    },
    "Style/FloatDivision": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["left_coerce", "right_coerce", "single_coerce", "fdiv"],
          "description": "Default: single_coerce"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://blog.rubystyle.guide/ruby/2019/06/21/float-division.html"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: left_coerce, right_coerce, single_coerce, fdiv"
        }
      },
      "description": "Checks for division with integers coerced to floats. It is recommended to either always use `fdiv` or coerce one side only. This cop also provides other options for code consistency."
    },
    "Style/For": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["each", "for"],
          "description": "Default: each"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: each, for"
        }
      },
      "description": "Looks for uses of the `for` keyword or `each` method. The preferred alternative is set in the EnforcedStyle configuration parameter. An `each` call with a block on a single line is always allowed."
    },
    "Style/FormatString": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["format", "sprintf", "percent"],
          "description": "Default: format"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: format, sprintf, percent"
        }
      },
      "description": "Enforces the use of a single string formatting utility. Valid options include `Kernel#format`, `Kernel#sprintf`, and `String#%`.\n\nThe detection of `String#%` cannot be implemented in a reliable manner for all cases, so only two scenarios are considered - if the first argument is a string literal and if the second argument is an array literal.\n\nAutocorrection will be applied when using argument is a literal or known built-in conversion methods such as `to_d`, `to_f`, `to_h`, `to_i`, `to_r`, `to_s`, and `to_sym` on variables, provided that their return value is not an array. For example, when using `to_s`, `'%s' % [1, 2, 3].to_s` can be autocorrected without any incompatibility:\n\n'%s' % [1, 2, 3]        #=> '1' format('%s', [1, 2, 3]) #=> '[1, 2, 3]' '%s' % [1, 2, 3].to_s   #=> '[1, 2, 3]'"
    },
    "Style/FormatStringToken": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["annotated", "template", "unannotated"],
          "description": "Default: annotated"
        },
        "MaxUnannotatedPlaceholdersAllowed": {
          "type": "integer",
          "description": "Default: 1"
        },
        "Mode": {
          "type": "string",
          "description": "Default: aggressive"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: annotated, template, unannotated"
        }
      },
      "description": "Use a consistent style for tokens within a format string.\n\nBy default, all strings are evaluated. In some cases, this may be undesirable, as they could be used as arguments to a method that does not consider them to be tokens, but rather other identifiers or just part of the string.\n\n`AllowedMethods` or `AllowedPatterns` can be configured with in order to mark specific methods as always allowed, thereby avoiding an offense from the cop. By default, there are no allowed methods.\n\nAdditionally, the cop can be made conservative by configuring it with `Mode: conservative` (default `aggressive`). In this mode, tokens (regardless of `EnforcedStyle`) are only considered if used in the format string argument to the methods `printf`, `sprintf`, `format` and `%`.\n\nTokens in the `unannotated` style (eg. `%s`) are always treated as if configured with `Conservative: true`. This is done in order to prevent false positives, because this format is very similar to encoded URLs or Date/Time formatting strings.\n\nIt is allowed to contain unannotated token if the number of them is less than or equals to `MaxUnannotatedPlaceholdersAllowed`."
    },
    "Style/FrozenStringLiteralComment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.arb"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["always", "always_true", "never"],
          "description": "Default: always"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: always, always_true, never"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Helps you transition from mutable string literals to frozen string literals. It will add the `# frozen_string_literal: true` magic comment to the top of files to enable frozen string literals. Frozen string literals may be default in future Ruby. The comment will be added below a shebang and encoding comment. The frozen string literal comment is only valid in Ruby 2.3+.\n\nNote that the cop will accept files where the comment exists but is set to `false` instead of `true`.\n\nTo require a blank line after this comment, please see `Layout/EmptyLineAfterMagicComment` cop."
    },
    "Style/GlobalStdStream": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Enforces the use of `$stdout/$stderr/$stdin` instead of `STDOUT/STDERR/STDIN`. `STDOUT/STDERR/STDIN` are constants, and while you can actually reassign (possibly to redirect some stream) constants in Ruby, you'll get an interpreter warning if you do so."
    },
    "Style/GlobalVars": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedVariables": {
          "type": "array",
          "description": "Default: []"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.zenspider.com/ruby/quickref.html"
        }
      },
      "description": "Looks for uses of global variables. It does not report offenses for built-in global variables. Built-in global variables are allowed by default. Additionally users can allow additional variables via the AllowedVariables option.\n\nNote that backreferences like $1, $2, etc are not global variables."
    },
    "Style/GuardClause": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "MinBodyLength": {
          "type": "integer",
          "description": "Default: 1"
        },
        "AllowConsecutiveConditionals": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Use a guard clause instead of wrapping the code inside a conditional expression\n\nA condition with an `elsif` or `else` branch is allowed unless one of `return`, `break`, `next`, `raise`, or `fail` is used in the body of the conditional expression.\n\nAutocorrect works in most cases except with if-else statements   that contain logical operators such as `foo || raise('exception')`"
    },
    "Style/HashAsLastArrayItem": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["braces", "no_braces"],
          "description": "Default: braces"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: braces, no_braces"
        }
      },
      "description": "Checks for presence or absence of braces around hash literal as a last array item depending on configuration.\n\nThis cop will ignore arrays where all items are hashes, regardless of EnforcedStyle."
    },
    "Style/HashConversion": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowSplatArgument": {
          "type": "boolean",
          "description": "Default: true"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks the usage of pre-2.1 `Hash[args]` method of converting enumerables and sequences of values to hashes.\n\nCorrection code from splat argument (`Hash[*ary]`) is not simply determined. For example, `Hash[*ary]` can be replaced with `ary.each_slice(2).to_h` but it will be complicated. So, `AllowSplatArgument` option is true by default to allow splat argument for simple code."
    },
    "Style/HashEachMethods": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedReceivers": {
          "type": "array",
          "description": "Default: Thread.current"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for uses of `each_key` and `each_value` `Hash` methods.\n\nIf you have an array of two-element arrays, you can put   parentheses around the block arguments to indicate that you're not   working with a hash, and suppress RuboCop offenses."
    },
    "Style/HashExcept": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for usages of `Hash#reject`, `Hash#select`, and `Hash#filter` methods that can be replaced with `Hash#except` method.\n\nThis cop should only be enabled on Ruby version 3.0 or higher. (`Hash#except` was added in Ruby 3.0.)\n\nFor safe detection, it is limited to commonly used string and symbol comparisons when using `==` or `!=`.\n\nThis cop doesn't check for `Hash#delete_if` and `Hash#keep_if` because they modify the receiver."
    },
    "Style/HashLikeCase": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "MinBranchesCount": {
          "type": "integer",
          "description": "Default: 3"
        }
      },
      "description": "Checks for places where `case-when` represents a simple 1:1 mapping and can be replaced with a hash lookup."
    },
    "Style/HashSlice": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for usages of `Hash#reject`, `Hash#select`, and `Hash#filter` methods that can be replaced with `Hash#slice` method.\n\nThis cop should only be enabled on Ruby version 2.5 or higher. (`Hash#slice` was added in Ruby 2.5.)\n\nFor safe detection, it is limited to commonly used string and symbol comparisons when using `==` or `!=`.\n\nThis cop doesn't check for `Hash#delete_if` and `Hash#keep_if` because they modify the receiver."
    },
    "Style/HashSyntax": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "ruby19",
            "hash_rockets",
            "no_mixed_keys",
            "ruby19_no_mixed_keys"
          ],
          "description": "Default: ruby19"
        },
        "EnforcedShorthandSyntax": {
          "enum": [
            "always",
            "never",
            "either",
            "consistent",
            "either_consistent"
          ],
          "description": "Default: either"
        },
        "UseHashRocketsWithSymbolValues": {
          "type": "boolean",
          "description": "Default: false"
        },
        "PreferHashRocketsForNonAlnumEndingSymbols": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: ruby19, hash_rockets, no_mixed_keys, ruby19_no_mixed_keys"
        },
        "SupportedShorthandSyntax": {
          "type": "array",
          "description": "Default: always, never, either, consistent, either_consistent"
        }
      },
      "description": "Checks hash literal syntax.\n\nIt can enforce either the use of the class hash rocket syntax or the use of the newer Ruby 1.9 syntax (when applicable).\n\nA separate offense is registered for each problematic pair.\n\nThe supported styles are:\n\n - ruby19 - forces use of the 1.9 syntax (e.g. {a: 1}) when hashes have all symbols for keys\n\n - hash_rockets - forces use of hash rockets for all hashes\n\n - no_mixed_keys - simply checks for hashes with mixed syntaxes\n\n - ruby19_no_mixed_keys - forces use of ruby 1.9 syntax and forbids mixed syntax hashes\n\nThis cop has `EnforcedShorthandSyntax` option. It can enforce either the use of the explicit hash value syntax or the use of Ruby 3.1's hash value shorthand syntax.\n\nThe supported styles are:\n\n - always - forces use of the 3.1 syntax (e.g. {foo:})\n\n - never - forces use of explicit hash literal value\n\n - either - accepts both shorthand and explicit use of hash literal value\n\n - consistent - forces use of the 3.1 syntax only if all values can be omitted in the hash\n\n - either_consistent - accepts both shorthand and explicit use of hash literal value, but they must be consistent"
    },
    "Style/HashTransformKeys": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Looks for uses of `\\_.each_with_object({}) {...}`, `\\_.map {...}.to_h`, and `Hash[\\_.map {...}]` that are actually just transforming the keys of a hash, and tries to use a simpler & faster call to `transform_keys` instead. It should only be enabled on Ruby version 2.5 or newer. (`transform_keys` was added in Ruby 2.5.)"
    },
    "Style/HashTransformValues": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Looks for uses of `\\_.each_with_object({}) {...}`, `\\_.map {...}.to_h`, and `Hash[\\_.map {...}]` that are actually just transforming the values of a hash, and tries to use a simpler & faster call to `transform_values` instead."
    },
    "Style/IdenticalConditionalBranches": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for identical expressions at the beginning or end of each branch of a conditional expression. Such expressions should normally be placed outside the conditional expression - before or after it.\n\nThe cop is poorly named and some people might think that it actually checks for duplicated conditional branches. The name will probably be changed in a future major RuboCop release."
    },
    "Style/IfInsideElse": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowIfModifier": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "If the `else` branch of a conditional consists solely of an `if` node, it can be combined with the `else` to become an `elsif`. This helps to keep the nesting level from getting too deep."
    },
    "Style/IfUnlessModifier": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for `if` and `unless` statements that would fit on one line if written as modifier `if`/`unless`. The cop also checks for modifier `if`/`unless` lines that exceed the maximum line length.\n\nThe maximum line length is configured in the `Layout/LineLength` cop. The tab size is configured in the `IndentationWidth` of the `Layout/IndentationStyle` cop.\n\nOne-line pattern matching is always allowed. To ensure that there are few cases where the match variable is not used, and to prevent oversights. The variable `x` becomes undefined and raises `NameError` when the following example is changed to the modifier form:\n\nif [42] in [x]   x # `x` is undefined when using modifier form. end\n\nIt is allowed when `defined?` argument has an undefined value, because using the modifier form causes the following incompatibility:\n\nunless defined?(undefined_foo)   undefined_foo = 'default_value' end undefined_foo # => 'default_value'  undefined_bar = 'default_value' unless defined?(undefined_bar) undefined_bar # => nil"
    },
    "Style/IfUnlessModifierOfIfUnless": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for if and unless statements used as modifiers of other if or unless statements."
    },
    "Style/IfWithBooleanLiteralBranches": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: nonzero?"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for redundant `if` with boolean literal branches. It checks only conditions to return boolean value (`true` or `false`) for safe detection. The conditions to be checked are comparison methods, predicate methods, and double negation (!!). `nonzero?` method is allowed by default. These are customizable with `AllowedMethods` option.\n\nThis cop targets only `if`s with a single `elsif` or `else` branch. The following code will be allowed, because it has two `elsif` branches:\n\nif foo   true elsif bar > baz   true elsif qux > quux # Single `elsif` is warned, but two or more `elsif`s are not.   true else   false end"
    },
    "Style/IfWithSemicolon": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for uses of semicolon in if statements."
    },
    "Style/ImplicitRuntimeError": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for `raise` or `fail` statements which do not specify an explicit exception class. (This raises a `RuntimeError`. Some projects might prefer to use exception classes which more precisely identify the nature of the error.)"
    },
    "Style/InPatternThen": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for `in;` uses in `case` expressions."
    },
    "Style/InfiniteLoop": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Use `Kernel#loop` for infinite loops."
    },
    "Style/InlineComment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for trailing inline comments."
    },
    "Style/InverseMethods": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "InverseMethods": {
          "description": "Default: {any?: :none?, even?: :odd?, \"==\": :!=, \"=~\": :!~, \"<\": :>=, \">\": :⇐}"
        },
        "InverseBlocks": {
          "description": "Default: {select: :reject, select!: :reject!}"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Check for usages of not (`not` or `!`) called on a method when an inverse of that method can be used instead.\n\nMethods that can be inverted by a not (`not` or `!`) should be defined in `InverseMethods`.\n\nMethods that are inverted by inverting the return of the block that is passed to the method should be defined in `InverseBlocks`."
    },
    "Style/InvertibleUnlessCondition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "InverseMethods": {
          "description": "Default: {\"!=\": :==, \">\": :⇐, \"⇐\": :>, \"<\": :>=, \">=\": :<, \"!~\": :=~, zero?: :nonzero?, nonzero?: :zero?, any?: :none?, none?: :any?, even?: :odd?, odd?: :even?}"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for usages of `unless` which can be replaced by `if` with inverted condition. Code without `unless` is easier to read, but that is subjective, so this cop is disabled by default.\n\nMethods that can be inverted should be defined in `InverseMethods`. Note that the relationship of inverse methods needs to be defined in both directions. For example,\n\nInverseMethods:   :!=: :==   :even?: :odd?   :odd?: :even?\n\nwill suggest both `even?` and `odd?` to be inverted, but only `!=` (and not `==`)."
    },
    "Style/IpAddresses": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemfile, **/Gemfile, **/gems.rb, **/*.gemspec"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedAddresses": {
          "type": "array",
          "description": "Default: ::"
        }
      },
      "description": "Checks for hardcoded IP addresses, which can make code brittle. IP addresses are likely to need to be changed when code is deployed to a different server or environment, which may break a deployment if forgotten. Prefer setting IP addresses in ENV or other configuration."
    },
    "Style/ItAssignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for assignments to a local `it` variable inside a block where `it` can refer to the first anonymous parameter as of Ruby 3.4.\n\nAlthough Ruby allows reassigning `it` in these cases, it could cause confusion if `it` is used as a block parameter elsewhere. For consistency, this also applies to numblocks and blocks with parameters, even though `it` cannot be used in those cases."
    },
    "Style/KeywordArgumentsMerging": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "When passing an existing hash as keyword arguments, provide additional arguments directly rather than using `merge`.\n\nProviding arguments directly is more performant than using `merge`, and also leads to shorter and simpler code."
    },
    "Style/KeywordParametersOrder": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Enforces that optional keyword parameters are placed at the end of the parameters list.\n\nThis improves readability, because when looking through the source, it is expected to find required parameters at the beginning of parameters list and optional parameters at the end."
    },
    "Style/Lambda": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["line_count_dependent", "lambda", "literal"],
          "description": "Default: line_count_dependent"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: line_count_dependent, lambda, literal"
        }
      },
      "description": "(by default) checks for uses of the lambda literal syntax for single line lambdas, and the method call syntax for multiline lambdas. It is configurable to enforce one of the styles for both single line and multiline lambdas as well."
    },
    "Style/LambdaCall": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["call", "braces"],
          "description": "Default: call"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: call, braces"
        }
      },
      "description": "Checks for use of the lambda.(args) syntax."
    },
    "Style/LineEndConcatenation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for string literal concatenation at the end of a line."
    },
    "Style/MagicCommentFormat": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["snake_case", "kebab_case"],
          "description": "Default: snake_case"
        },
        "DirectiveCapitalization": {
          "type": "string",
          "description": "Default: lowercase"
        },
        "ValueCapitalization": {
          "description": "Default: <none>"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: snake_case, kebab_case"
        },
        "SupportedCapitalizations": {
          "type": "array",
          "description": "Default: lowercase, uppercase"
        }
      },
      "description": "Ensures magic comments are written consistently throughout your code base. Looks for discrepancies in separators (`-` vs `_`) and capitalization for both magic comment directives and values.\n\nRequired capitalization can be set with the `DirectiveCapitalization` and `ValueCapitalization` configuration keys.\n\nIf one of these configuration is set to nil, any capitalization is allowed."
    },
    "Style/MapCompactWithConditionalBlock": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Prefer `select` or `reject` over `map { ... }.compact`. This cop also handles `filter_map { ... }`, similar to `map { ... }.compact`."
    },
    "Style/MapIntoArray": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for usages of `each` with `<<`, `push`, or `append` which can be replaced by `map`.\n\nIf `PreferredMethods` is configured for `map` in `Style/CollectionMethods`, this cop uses the specified method for replacement.\n\nThe return value of `Enumerable#each` is `self`, whereas the return value of `Enumerable#map` is an `Array`. They are not autocorrected when a return value could be used because these types differ.\n\nIt only detects when the mapping destination is either: * a local variable initialized as an empty array and referred to only by the pushing operation; * or, if it is the single block argument to a `[].tap` block. This is because, if not, it's challenging to statically guarantee that the mapping destination variable remains an empty array:\n\nret = [] src.each { |e| ret << e * 2 } # `<<` method may mutate `ret`  dest = [] src.each { |e| dest << transform(e, dest) } # `transform` method may mutate `dest`"
    },
    "Style/MapToHash": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Looks for uses of `map.to_h` or `collect.to_h` that could be written with just `to_h` in Ruby >= 2.6.\n\n`Style/HashTransformKeys` and `Style/HashTransformValues` will also change this pattern if only hash keys or hash values are being transformed."
    },
    "Style/MapToSet": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Looks for uses of `map.to_set` or `collect.to_set` that could be written with just `to_set`."
    },
    "Style/MethodCallWithArgsParentheses": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "IgnoreMacros": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "IncludedMacros": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowParenthesesInMultilineCall": {
          "type": "boolean",
          "description": "Default: false"
        },
        "AllowParenthesesInChaining": {
          "type": "boolean",
          "description": "Default: false"
        },
        "AllowParenthesesInCamelCaseMethod": {
          "type": "boolean",
          "description": "Default: false"
        },
        "AllowParenthesesInStringInterpolation": {
          "type": "boolean",
          "description": "Default: false"
        },
        "EnforcedStyle": {
          "enum": ["require_parentheses", "omit_parentheses"],
          "description": "Default: require_parentheses"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: require_parentheses, omit_parentheses"
        }
      },
      "description": "Enforces the presence (default) or absence of parentheses in method calls containing arguments.\n\nIn the default style (require_parentheses), macro methods are allowed. Additional methods can be added to the `AllowedMethods` or `AllowedPatterns` list. These options are valid only in the default style. Macros can be included by either setting `IgnoreMacros` to false or adding specific macros to the `IncludedMacros` list.\n\nPrecedence of options is as follows:\n\n  1. AllowedMethods\n\n  2. AllowedPatterns\n\n  3. IncludedMacros\n\nIf a method is listed in both `IncludedMacros` and `AllowedMethods`, then the latter takes precedence (that is, the method is allowed).\n\nIn the alternative style (omit_parentheses), there are three additional options.\n\n  1. AllowParenthesesInChaining is false by default. Setting it to true allows the presence of parentheses in the last call during method chaining.\n\n  2. AllowParenthesesInMultilineCall is false by default. Setting it to true allows the presence of parentheses in multi-line method calls.\n\n  3. AllowParenthesesInCamelCaseMethod is false by default. This allows the presence of parentheses when calling a method whose name begins with a capital letter and which has no arguments. Setting it to true allows the presence of parentheses in such a method call even with arguments.\n\nThe style of `omit_parentheses` allows parentheses in cases where omitting them results in ambiguous or syntactically incorrect code.\n\nNon-exhaustive list of examples:\n\n - Parentheses are required allowed in method calls with arguments inside literals, logical operators, setting default values in position and keyword arguments, chaining and more.\n\n - Parentheses are allowed in method calls with arguments inside operators to avoid ambiguity. triple-dot syntax introduced in Ruby 2.7 as omitting them starts an endless range.\n\n - Parentheses are allowed when forwarding arguments with the triple-dot syntax introduced in Ruby 2.7 as omitting them starts an endless range.\n\n - Parentheses are required in calls with arguments when inside an endless method definition introduced in Ruby 3.0.\n\n - Ruby 3.1’s hash omission syntax allows parentheses if the method call is in conditionals and requires parentheses if the call is not the value-returning expression. See https://bugs.ruby-lang.org/issues/18396.\n\n - Parentheses are required in anonymous arguments, keyword arguments and block passing in Ruby 3.2.\n\n - Parentheses are required when the first argument is a beginless range or the last argument is an endless range."
    },
    "Style/MethodCallWithoutArgsParentheses": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks for unwanted parentheses in parameterless method calls.\n\nThis cop's allowed methods can be customized with `AllowedMethods`. By default, there are no allowed methods.\n\nThis cop allows the use of `it()` without arguments in blocks, as in `0.times { it() }`, following `Lint/ItWithoutArgumentsInBlock` cop."
    },
    "Style/MethodCalledOnDoEndBlock": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for methods called on a do...end block. The point of this check is that it's easy to miss the call tacked on to the block when reading code."
    },
    "Style/MethodDefParentheses": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "require_parentheses",
            "require_no_parentheses",
            "require_no_parentheses_except_multiline"
          ],
          "description": "Default: require_parentheses"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: require_parentheses, require_no_parentheses, require_no_parentheses_except_multiline"
        }
      },
      "description": "Checks for parentheses around the arguments in method definitions. Both instance and class/singleton methods are checked.\n\nRegardless of style, parentheses are necessary for:\n\n  1. Endless methods\n\n  2. Argument lists containing a forward-arg (…​)\n\n  3. Argument lists containing an anonymous rest arguments forwarding (*)\n\n  4. Argument lists containing an anonymous keyword rest arguments forwarding (**)\n\n  5. Argument lists containing an anonymous block forwarding (&)\n\nRemoving the parens would be a syntax error here."
    },
    "Style/MinMax": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for potential uses of `Enumerable#minmax`."
    },
    "Style/MinMaxComparison": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Enforces the use of `max` or `min` instead of comparison for greater or less.\n\nIt can be used if you want to present limit or threshold in Ruby 2.7+. That it is slow though. So autocorrection will apply generic `max` or `min`:\n\na.clamp(b..) # Same as `[a, b].max` a.clamp(..b) # Same as `[a, b].min`"
    },
    "Style/MissingElse": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["if", "case", "both"],
          "description": "Default: both"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: if, case, both"
        }
      },
      "description": "Checks for `if` expressions that do not have an `else` branch.\n\nPattern matching is allowed to have no `else` branch because unlike `if` and `case`, it raises `NoMatchingPatternError` if the pattern doesn't match and without having `else`.\n\nSupported styles are: if, case, both."
    },
    "Style/MissingRespondToMissing": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for the presence of `method_missing` without also defining `respond_to_missing?`.\n\nNot defining `respond_to_missing?` will cause metaprogramming methods like `respond_to?` to behave unexpectedly:\n\nclass StringDelegator   def initialize(string)     @string = string   end    def method_missing(name, *args)     @string.send(name, *args)   end end  delegator = StringDelegator.new(\"foo\") # Claims to not respond to `upcase`. delegator.respond_to?(:upcase) # => false # But you can call it. delegator.upcase # => FOO"
    },
    "Style/MixinGrouping": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["separated", "grouped"],
          "description": "Default: separated"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: separated, grouped"
        }
      },
      "description": "Checks for grouping of mixins in `class` and `module` bodies. By default it enforces mixins to be placed in separate declarations, but it can be configured to enforce grouping them in one declaration."
    },
    "Style/MixinUsage": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks that `include`, `extend` and `prepend` statements appear inside classes and modules, not at the top level, so as to not affect the behavior of `Object`."
    },
    "Style/ModuleFunction": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["module_function", "extend_self", "forbidden"],
          "description": "Default: module_function"
        },
        "Autocorrect": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: module_function, extend_self, forbidden"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for use of `extend self` or `module_function` in a module.\n\nSupported styles are: `module_function` (default), `extend_self` and `forbidden`.\n\nA couple of things to keep in mind:\n\n - forbidden style prohibits the usage of both styles\n\n - in default mode (module_function), the cop won’t be activated when the module contains any private methods"
    },
    "Style/MultilineBlockChain": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for chaining of a block after another block that spans multiple lines."
    },
    "Style/MultilineIfModifier": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for uses of if/unless modifiers with multiple-lines bodies."
    },
    "Style/MultilineIfThen": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for uses of the `then` keyword in multi-line if statements."
    },
    "Style/MultilineInPatternThen": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks uses of the `then` keyword in multi-line `in` statement."
    },
    "Style/MultilineMemoization": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["keyword", "braces"],
          "description": "Default: keyword"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: keyword, braces"
        }
      },
      "description": "Checks expressions wrapping styles for multiline memoization."
    },
    "Style/MultilineMethodSignature": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for method signatures that span multiple lines."
    },
    "Style/MultilineTernaryOperator": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for multi-line ternary op expressions.\n\n`return if ... else ... end` is syntax error. If `return` is used before multiline ternary operator expression, it will be autocorrected to single-line ternary operator. The same is true for `break`, `next`, and method call."
    },
    "Style/MultilineWhenThen": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks uses of the `then` keyword in multi-line when statements."
    },
    "Style/MultipleComparison": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowMethodComparison": {
          "type": "boolean",
          "description": "Default: true"
        },
        "ComparisonsThreshold": {
          "type": "integer",
          "description": "Default: 2"
        }
      },
      "description": "Checks against comparing a variable with multiple items, where `Array#include?`, `Set#include?` or a `case` could be used instead to avoid code repetition. It accepts comparisons of multiple method calls to avoid unnecessary method calls by default. It can be configured by `AllowMethodComparison` option."
    },
    "Style/MutableConstant": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["literals", "strict"],
          "description": "Default: literals"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: literals, strict"
        }
      },
      "description": "Checks whether some constant value isn't a mutable literal (e.g. array or hash).\n\nStrict mode can be used to freeze all constants, rather than just literals. Strict mode is considered an experimental feature. It has not been updated with an exhaustive list of all methods that will produce frozen objects so there is a decent chance of getting some false positives. Luckily, there is no harm in freezing an already frozen object.\n\nFrom Ruby 3.0, this cop honours the magic comment 'shareable_constant_value'. When this magic comment is set to any acceptable value other than none, it will suppress the offenses raised by this cop. It enforces frozen state.\n\n`Regexp` and `Range` literals are frozen objects since Ruby 3.0.\n\nFrom Ruby 3.0, interpolated strings are not frozen when `# frozen-string-literal: true` is used, so this cop enforces explicit freezing for such strings.\n\nFrom Ruby 3.0, this cop allows explicit freezing of constants when the `shareable_constant_value` directive is used."
    },
    "Style/NegatedIf": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["both", "prefix", "postfix"],
          "description": "Default: both"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: both, prefix, postfix"
        }
      },
      "description": "Checks for uses of if with a negated condition. Only ifs without else are considered. There are three different styles:\n\n - both\n\n - prefix\n\n - postfix"
    },
    "Style/NegatedIfElseCondition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for uses of `if-else` and ternary operators with a negated condition which can be simplified by inverting condition and swapping branches."
    },
    "Style/NegatedUnless": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["both", "prefix", "postfix"],
          "description": "Default: both"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: both, prefix, postfix"
        }
      },
      "description": "Checks for uses of unless with a negated condition. Only unless without else are considered. There are three different styles:\n\n - both\n\n - prefix\n\n - postfix"
    },
    "Style/NegatedWhile": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for uses of while with a negated condition."
    },
    "Style/NestedFileDirname": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for nested `File.dirname`. It replaces nested `File.dirname` with the level argument introduced in Ruby 3.1."
    },
    "Style/NestedModifier": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for nested use of if, unless, while and until in their modifier form."
    },
    "Style/NestedParenthesizedCalls": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: be, be_a, be_an, be_between, be_falsey, be_kind_of, be_instance_of, be_truthy, be_within, eq, eql, end_with, include, match, raise_error, respond_to, start_with"
        }
      },
      "description": "Checks for unparenthesized method calls in the argument list of a parenthesized method call. `be`, `be_a`, `be_an`, `be_between`, `be_falsey`, `be_kind_of`, `be_instance_of`, `be_truthy`, `be_within`, `eq`, `eql`, `end_with`, `include`, `match`, `raise_error`, `respond_to`, and `start_with` methods are allowed by default. These are customizable with `AllowedMethods` option."
    },
    "Style/NestedTernaryOperator": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for nested ternary op expressions."
    },
    "Style/Next": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["skip_modifier_ifs", "always"],
          "description": "Default: skip_modifier_ifs"
        },
        "MinBodyLength": {
          "type": "integer",
          "description": "Default: 3"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: skip_modifier_ifs, always"
        }
      },
      "description": "Use `next` to skip iteration instead of a condition at the end."
    },
    "Style/NilComparison": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["predicate", "comparison"],
          "description": "Default: predicate"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: predicate, comparison"
        }
      },
      "description": "Checks for comparison of something with nil using `==` and `nil?`.\n\nSupported styles are: predicate, comparison."
    },
    "Style/NilLambda": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for lambdas and procs that always return nil, which can be replaced with an empty lambda or proc instead."
    },
    "Style/NonNilCheck": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "IncludeSemanticChanges": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for non-nil checks, which are usually redundant.\n\nWith `IncludeSemanticChanges` set to `false` by default, this cop does not report offenses for `!x.nil?` and does no changes that might change behavior. Also `IncludeSemanticChanges` set to `false` with `EnforcedStyle: comparison` of `Style/NilComparison` cop, this cop does not report offenses for `x != nil` and does no changes to `!x.nil?` style.\n\nWith `IncludeSemanticChanges` set to `true`, this cop reports offenses for `!x.nil?` and autocorrects that and `x != nil` to solely `x`, which is *usually* OK, but might change behavior."
    },
    "Style/Not": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for uses of the keyword `not` instead of `!`."
    },
    "Style/NumberedParameters": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["allow_single_line", "disallow"],
          "description": "Default: allow_single_line"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: allow_single_line, disallow"
        }
      },
      "description": "Checks for numbered parameters.\n\nIt can either restrict the use of numbered parameters to single-lined blocks, or disallow completely numbered parameters."
    },
    "Style/NumberedParametersLimit": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Max": {
          "type": "integer",
          "description": "Default: 1"
        }
      },
      "description": "Detects use of an excessive amount of numbered parameters in a single block. Having too many numbered parameters can make code too cryptic and hard to read.\n\nThe cop defaults to registering an offense if there is more than 1 numbered parameter but this maximum can be configured by setting `Max`."
    },
    "Style/NumericLiteralPrefix": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedOctalStyle": {
          "enum": ["zero_with_o", "zero_only"],
          "description": "Default: zero_with_o"
        },
        "SupportedOctalStyles": {
          "type": "array",
          "description": "Default: zero_with_o, zero_only"
        }
      },
      "description": "Checks for octal, hex, binary, and decimal literals using uppercase prefixes and corrects them to lowercase prefix or no prefix (in case of decimals)."
    },
    "Style/NumericLiterals": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "MinDigits": {
          "type": "integer",
          "description": "Default: 5"
        },
        "Strict": {
          "type": "boolean",
          "description": "Default: false"
        },
        "AllowedNumbers": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks for big numeric literals without `_` between groups of digits in them.\n\nAdditional allowed patterns can be added by adding regexps to the `AllowedPatterns` configuration. All regexps are treated as anchored even if the patterns do not contain anchors (so `\\d{4}_\\d{4}` will allow `1234_5678` but not `1234_5678_9012`).\n\nEven if `AllowedPatterns` are given, autocorrection will only correct to the standard pattern of an `_` every 3 digits."
    },
    "Style/NumericPredicate": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: spec/**/*"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["predicate", "comparison"],
          "description": "Default: predicate"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: predicate, comparison"
        }
      },
      "description": "Checks for usage of comparison operators (`==`, `>`, `<`) to test numbers as zero, positive, or negative. These can be replaced by their respective predicate methods. This cop can also be configured to do the reverse.\n\nThis cop's allowed methods can be customized with `AllowedMethods`. By default, there are no allowed methods.\n\nThis cop disregards `#nonzero?` as its value is truthy or falsey, but not `true` and `false`, and thus not always interchangeable with `!= 0`.\n\nThis cop allows comparisons to global variables, since they are often populated with objects which can be compared with integers, but are not themselves `Integer` polymorphic."
    },
    "Style/ObjectThen": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["then", "yield_self"],
          "description": "Default: then"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: then, yield_self"
        }
      },
      "description": "Enforces the use of consistent method names `Object#yield_self` or `Object#then`."
    },
    "Style/OneLineConditional": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AlwaysCorrectToMultiline": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for uses of if/then/else/end constructs on a single line. `AlwaysCorrectToMultiline` config option can be set to true to autocorrect all offenses to multi-line constructs. When `AlwaysCorrectToMultiline` is false (default case) the autocorrect will first try converting them to ternary operators."
    },
    "Style/OpenStructUse": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "array",
          "description": "Default: https://docs.ruby-lang.org/en/3.0.0/OpenStruct.html#class-OpenStruct-label-Caveats"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Flags uses of `OpenStruct`, as it is now officially discouraged to be used for performance, version compatibility, and potential security issues."
    },
    "Style/OperatorMethodCall": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for redundant dot before operator method call. The target operator methods are `|`, `^`, `&`, ``<=>``, `==`, `===`, `=~`, `>`, `>=`, `<`, ``<=``, `<<`, `>>`, `+`, `-`, `*`, `/`, `%`, `**`, `~`, `!`, `!=`, and `!~`."
    },
    "Style/OptionHash": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SuspiciousParamNames": {
          "type": "array",
          "description": "Default: options, opts, args, params, parameters"
        },
        "Allowlist": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks for options hashes and discourages them if the current Ruby version supports keyword arguments."
    },
    "Style/OptionalArguments": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for optional arguments to methods that do not come at the end of the argument list."
    },
    "Style/OptionalBooleanParameter": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: respond_to_missing?"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for places where keyword arguments can be used instead of boolean arguments when defining methods. `respond_to_missing?` method is allowed by default. These are customizable with `AllowedMethods` option."
    },
    "Style/OrAssignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for potential usage of the `||=` operator."
    },
    "Style/ParallelAssignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for simple usages of parallel assignment. This will only complain when the number of variables being assigned matched the number of assigning variables."
    },
    "Style/ParenthesesAroundCondition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowSafeAssignment": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowInMultilineConditions": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for the presence of superfluous parentheses around the condition of if/unless/while/until.\n\n`AllowSafeAssignment` option for safe assignment. By safe assignment we mean putting parentheses around an assignment to indicate \"I know I'm using an assignment as a condition. It's not a mistake.\""
    },
    "Style/PercentLiteralDelimiters": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "PreferredDelimiters": {
          "description": "Default: {\"default\" ⇒ \"()\", \"%i\" ⇒ \"[]\", \"%I\" ⇒ \"[]\", \"%r\" ⇒ \"{}\", \"%w\" ⇒ \"[]\", \"%W\" ⇒ \"[]\"}"
        }
      },
      "description": "Enforces the consistent usage of `%`-literal delimiters.\n\nSpecify the 'default' key to set all preferred delimiters at once. You can continue to specify individual preferred delimiters to override the default."
    },
    "Style/PercentQLiterals": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["lower_case_q", "upper_case_q"],
          "description": "Default: lower_case_q"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: lower_case_q, upper_case_q"
        }
      },
      "description": "Checks for usage of the %Q() syntax when %q() would do."
    },
    "Style/PerlBackrefs": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Looks for uses of Perl-style regexp match backreferences and their English versions like $1, $2, $&, &+, $MATCH, $PREMATCH, etc."
    },
    "Style/PreferredHashMethods": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["short", "verbose"],
          "description": "Default: short"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: short, verbose"
        }
      },
      "description": "Checks for uses of methods `Hash#has_key?` and `Hash#has_value?`, and suggests using `Hash#key?` and `Hash#value?` instead.\n\nIt is configurable to enforce the verbose method names, by using the `EnforcedStyle: verbose` configuration."
    },
    "Style/Proc": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for uses of Proc.new where Kernel#proc would be more appropriate."
    },
    "Style/QuotedSymbols": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["same_as_string_literals", "single_quotes", "double_quotes"],
          "description": "Default: same_as_string_literals"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: same_as_string_literals, single_quotes, double_quotes"
        }
      },
      "description": "Checks if the quotes used for quoted symbols match the configured defaults. By default uses the same configuration as `Style/StringLiterals`; if that cop is not enabled, the default `EnforcedStyle` is `single_quotes`.\n\nString interpolation is always kept in double quotes.\n\n`Lint/SymbolConversion` can be used in parallel to ensure that symbols are not quoted that don't need to be. This cop is for configuring the quoting style to use for symbols that require quotes."
    },
    "Style/RaiseArgs": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["compact", "exploded"],
          "description": "Default: exploded"
        },
        "AllowedCompactTypes": {
          "type": "array",
          "description": "Default: []"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: compact, exploded"
        }
      },
      "description": "Checks the args passed to `fail` and `raise`. For exploded style (default), it recommends passing the exception class and message to `raise`, rather than construct an instance of the error. It will still allow passing just a message, or the construction of an error with more than one argument.\n\nThe exploded style works identically, but with the addition that it will also suggest constructing error objects when the exception is passed multiple arguments.\n\nThe exploded style has an `AllowedCompactTypes` configuration option that takes an `Array` of exception name Strings."
    },
    "Style/RandomWithOffset": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for the use of randomly generated numbers, added/subtracted with integer literals, as well as those with Integer#succ and Integer#pred methods. Prefer using ranges instead, as it clearly states the intentions."
    },
    "Style/RedundantArgument": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Methods": {
          "description": "Default: {\"join\" ⇒ \"\", \"sum\" ⇒ 0, \"exit\" ⇒ true, \"exit!\" ⇒ false, \"split\" ⇒ \" \", \"chomp\" ⇒ \"\\n\", \"chomp!\" ⇒ \"\\n\"}"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for a redundant argument passed to certain methods.\n\nThis cop is limited to methods with single parameter.\n\nMethod names and their redundant arguments can be configured like this:\n\nMethods:   join: ''   sum: 0   split: ' '   chomp: \"\\n\"   chomp!: \"\\n\"   foo: 2"
    },
    "Style/RedundantArrayConstructor": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for the instantiation of array using redundant `Array` constructor. Autocorrect replaces to array literal which is the simplest and fastest."
    },
    "Style/RedundantAssignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for redundant assignment before returning."
    },
    "Style/RedundantBegin": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for redundant `begin` blocks.\n\nCurrently it checks for code like this:"
    },
    "Style/RedundantCapitalW": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for usage of the %W() syntax when %w() would do."
    },
    "Style/RedundantCondition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: nonzero?"
        }
      },
      "description": "Checks for unnecessary conditional expressions.\n\nSince the intention of the comment cannot be automatically determined, autocorrection is not applied when a comment is used, as shown below:\n\nif b   # Important note.   b else   c end"
    },
    "Style/RedundantConditional": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for redundant returning of true/false in conditionals."
    },
    "Style/RedundantConstantBase": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Avoid redundant `::` prefix on constant.\n\nHow Ruby searches constant is a bit complicated, and it can often be difficult to understand from the code whether the `::` is intended or not. Where `Module.nesting` is empty, there is no need to prepend `::`, so it would be nice to consistently avoid such meaningless `::` prefix to avoid confusion.\n\nThis cop is disabled if `Lint/ConstantResolution` cop is enabled to prevent conflicting rules. Because it respects user configurations that want to enable `Lint/ConstantResolution` cop which is disabled by default."
    },
    "Style/RedundantCurrentDirectoryInPath": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for paths given to `require_relative` that start with the current directory (`./`), which can be omitted."
    },
    "Style/RedundantDoubleSplatHashBraces": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for redundant uses of double splat hash braces."
    },
    "Style/RedundantEach": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for redundant `each`."
    },
    "Style/RedundantException": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for `RuntimeError` as the argument of `raise`/`fail`."
    },
    "Style/RedundantFetchBlock": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeForConstants": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://github.com/fastruby/fast-ruby#hashfetch-with-argument-vs-hashfetch--block-code"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Identifies places where `fetch(key) { value }` can be replaced by `fetch(key, value)`.\n\nIn such cases `fetch(key, value)` method is faster than `fetch(key) { value }`.\n\nThe block string `'value'` in `hash.fetch(:key) { 'value' }` is detected when frozen string literal magic comment is enabled (i.e. `# frozen_string_literal: true`), but not when disabled."
    },
    "Style/RedundantFileExtensionInRequire": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for the presence of superfluous `.rb` extension in the filename provided to `require` and `require_relative`.\n\nIf the extension is omitted, Ruby tries adding '.rb', '.so',       and so on to the name until found. If the file named cannot be found,       a `LoadError` will be raised.       There is an edge case where `foo.so` file is loaded instead of a `LoadError`       if `foo.so` file exists when `require 'foo.rb'` will be changed to `require 'foo'`,       but that seems harmless."
    },
    "Style/RedundantFilterChain": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Identifies usages of `any?`, `empty?` or `none?` predicate methods chained to `select`/`filter`/`find_all` and change them to use predicate method instead."
    },
    "Style/RedundantFormat": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for calls to `Kernel#format` or `Kernel#sprintf` that are redundant.\n\nCalling `format` with only a single string argument is redundant, as it can be replaced by the string itself.\n\nAlso looks for `format` calls where the arguments are literals that can be inlined into a string easily. This applies to the `%s`, `%d`, `%i`, `%u`, and `%f` format specifiers."
    },
    "Style/RedundantFreeze": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Check for uses of `Object#freeze` on immutable objects.\n\n`Regexp` and `Range` literals are frozen objects since Ruby 3.0.\n\nFrom Ruby 3.0, this cop allows explicit freezing of interpolated string literals when `# frozen-string-literal: true` is used."
    },
    "Style/RedundantHeredocDelimiterQuotes": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for redundant heredoc delimiter quotes."
    },
    "Style/RedundantInitialize": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowComments": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AutoCorrect": {
          "type": "string",
          "description": "Default: contextual"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for `initialize` methods that are redundant.\n\nAn initializer is redundant if it does not do anything, or if it only calls `super` with the same arguments given to it. If the initializer takes an argument that accepts multiple values (`restarg`, `kwrestarg`, etc.) it will not register an offense, because it allows the initializer to take a different number of arguments as its superclass potentially does.\n\nIf an initializer takes any arguments and has an empty body, RuboCop assumes it to *not* be redundant. This is to prevent potential `ArgumentError`.\n\nIf an initializer argument has a default value, RuboCop assumes it to *not* be redundant.\n\nEmpty initializers are registered as offenses, but it is possible to purposely create an empty `initialize` method to override a superclass's initializer."
    },
    "Style/RedundantInterpolation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for strings that are just an interpolated expression."
    },
    "Style/RedundantInterpolationUnfreeze": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Before Ruby 3.0, interpolated strings followed the frozen string literal magic comment which sometimes made it necessary to explicitly unfreeze them. Ruby 3.0 changed interpolated strings to always be unfrozen which makes unfreezing them redundant."
    },
    "Style/RedundantLineContinuation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Check for redundant line continuation.\n\nThis cop marks a line continuation as redundant if removing the backslash does not result in a syntax error. However, a backslash at the end of a comment or for string concatenation is not redundant and is not considered an offense."
    },
    "Style/RedundantParentheses": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for redundant parentheses."
    },
    "Style/RedundantPercentQ": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for usage of the %q/%Q syntax when '' or \"\" would do."
    },
    "Style/RedundantRegexpArgument": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Identifies places where argument can be replaced from a deterministic regexp to a string."
    },
    "Style/RedundantRegexpCharacterClass": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for unnecessary single-element `Regexp` character classes."
    },
    "Style/RedundantRegexpConstructor": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for the instantiation of regexp using redundant `Regexp.new` or `Regexp.compile`. Autocorrect replaces to regexp literal which is the simplest and fastest."
    },
    "Style/RedundantRegexpEscape": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for redundant escapes inside `Regexp` literals."
    },
    "Style/RedundantReturn": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowMultipleReturnValues": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for redundant `return` expressions."
    },
    "Style/RedundantSelf": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for redundant uses of `self`.\n\nThe usage of `self` is only needed when:\n\n - Sending a message to same object with zero arguments in presence of a method name clash with an argument or a local variable.\n\n - Calling an attribute writer to prevent a local variable assignment.\n\nNote, with using explicit self you can only send messages with public or protected scope, you cannot send private messages this way.\n\nNote we allow uses of `self` with operators because it would be awkward otherwise. Also allows the use of `self.it` without arguments in blocks, as in `0.times { self.it }`, following `Lint/ItWithoutArgumentsInBlock` cop."
    },
    "Style/RedundantSelfAssignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for places where redundant assignments are made for in place modification methods."
    },
    "Style/RedundantSelfAssignmentBranch": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for places where conditional branch makes redundant self-assignment.\n\nIt only detects local variable because it may replace state of instance variable, class variable, and global variable that have state across methods with `nil`."
    },
    "Style/RedundantSort": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Identifies instances of sorting and then taking only the first or last element. The same behavior can be accomplished without a relatively expensive sort by using `Enumerable#min` instead of sorting and taking the first element and `Enumerable#max` instead of sorting and taking the last element. Similarly, `Enumerable#min_by` and `Enumerable#max_by` can replace `Enumerable#sort_by` calls after which only the first or last element is used."
    },
    "Style/RedundantSortBy": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Identifies places where `sort_by { ... }` can be replaced by `sort`."
    },
    "Style/RedundantStringEscape": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for redundant escapes in string literals."
    },
    "Style/RegexpLiteral": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["slashes", "percent_r", "mixed"],
          "description": "Default: slashes"
        },
        "AllowInnerSlashes": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: slashes, percent_r, mixed"
        }
      },
      "description": "Enforces using `//` or `%r` around regular expressions.\n\nThe following `%r` cases using a regexp starts with a blank or `=` as a method argument allowed to prevent syntax errors.\n\ndo_something %r{ regexp} # `do_something / regexp/` is an invalid syntax. do_something %r{=regexp} # `do_something /=regexp/` is an invalid syntax."
    },
    "Style/RequireOrder": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Sort `require` and `require_relative` in alphabetical order."
    },
    "Style/RescueModifier": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for uses of `rescue` in its modifier form is added for following reasons:\n\n - The syntax of modifier form rescue can be misleading because it might lead us to believe that rescue handles the given exception but it actually rescue all exceptions to return the given rescue block. In this case, value returned by handle_error or SomeException.\n\n - Modifier form rescue would rescue all the exceptions. It would silently skip all exception or errors and handle the error. Example: If NoMethodError is raised, modifier form rescue would handle the exception."
    },
    "Style/RescueStandardError": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["implicit", "explicit"],
          "description": "Default: explicit"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: implicit, explicit"
        }
      },
      "description": "Checks for rescuing `StandardError`. There are two supported styles `implicit` and `explicit`. This cop will not register an offense if any error other than `StandardError` is specified."
    },
    "Style/ReturnNil": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["return", "return_nil"],
          "description": "Default: return"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: return, return_nil"
        }
      },
      "description": "Enforces consistency between `return nil` and `return`.\n\nThis cop is disabled by default. Because there seems to be a perceived semantic difference between `return` and `return nil`. The former can be seen as just halting evaluation, while the latter might be used when the return value is of specific concern.\n\nSupported styles are `return` and `return_nil`."
    },
    "Style/ReturnNilInPredicateMethodDefinition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for predicate method definitions that return `nil`. A predicate method should only return a boolean value."
    },
    "Style/SafeNavigation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "ConvertCodeThatCanStartToReturnNil": {
          "type": "boolean",
          "description": "Default: false"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: present?, blank?, presence, try, try!"
        },
        "MaxChainLength": {
          "type": "integer",
          "description": "Default: 2"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Transforms usages of a method call safeguarded by a non `nil` check for the variable whose method is being called to safe navigation (`&.`). If there is a method chain, all of the methods in the chain need to be checked for safety, and all of the methods will need to be changed to use safe navigation.\n\nThe default for `ConvertCodeThatCanStartToReturnNil` is `false`. When configured to `true`, this will check for code in the format `!foo.nil? && foo.bar`. As it is written, the return of this code is limited to `false` and whatever the return of the method is. If this is converted to safe navigation, `foo&.bar` can start returning `nil` as well as what the method returns.\n\nThe default for `MaxChainLength` is `2`. We have limited the cop to not register an offense for method chains that exceed this option's value.\n\nThis cop will recognize offenses but not autocorrect code when the right hand side (RHS) of the `&&` statement is an `||` statement (eg. `foo && (foo.bar? || foo.baz?)`). It can be corrected manually by removing the `foo &&` and adding `&.` to each `foo` on the RHS."
    },
    "Style/SafeNavigationChainLength": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Max": {
          "type": "integer",
          "description": "Default: 2"
        }
      },
      "description": "Enforces safe navigation chains length to not exceed the configured maximum. The longer the chain is, the harder it becomes to track what on it could be returning `nil`.\n\nThere is a potential interplay with `Style/SafeNavigation` - if both are enabled and their settings are \"incompatible\", one of the cops will complain about what the other proposes.\n\nE.g. if `Style/SafeNavigation` is configured with `MaxChainLength: 2` (default) and this cop is configured with `Max: 1`, then for `foo.bar.baz if foo` the former will suggest `foo&.bar&.baz`, which is an offense for the latter."
    },
    "Style/Sample": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://github.com/fastruby/fast-ruby#arrayshufflefirst-vs-arraysample-code"
        }
      },
      "description": "Identifies usages of `shuffle.first`, `shuffle.last`, and `shuffle[]` and change them to use `sample` instead."
    },
    "Style/SelectByRegexp": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Looks for places where a subset of an Enumerable (array, range, set, etc.; see note below) is calculated based on a `Regexp` match, and suggests `grep` or `grep_v` instead.\n\nHashes do not behave as you may expect with `grep`, which means that `hash.grep` is not equivalent to `hash.select`. Although RuboCop is limited by static analysis, this cop attempts to avoid registering an offense when the receiver is a hash (hash literal, `Hash.new`, `Hash#[]`, or `to_h`/`to_hash`).\n\n`grep` and `grep_v` were optimized when used without a block in Ruby 3.0, but may be slower in previous versions. See https://bugs.ruby-lang.org/issues/17030"
    },
    "Style/SelfAssignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Enforces the use the shorthand for self-assignment."
    },
    "Style/Semicolon": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowAsExpressionSeparator": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for multiple expressions placed on the same line. It also checks for lines terminated with a semicolon.\n\nThis cop has `AllowAsExpressionSeparator` configuration option. It allows `;` to separate several expressions on the same line."
    },
    "Style/Send": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for the use of the send method."
    },
    "Style/SendWithLiteralMethodName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowSend": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Detects the use of the `public_send` method with a literal method name argument. Since the `send` method can be used to call private methods, by default, only the `public_send` method is detected.\n\nWriter methods with names ending in `=` are always permitted because their behavior differs as follows:\n\ndef foo=(foo)   @foo = foo   42 end  self.foo = 1   # => 1 send(:foo=, 1) # => 42"
    },
    "Style/SignalException": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["only_raise", "only_fail", "semantic"],
          "description": "Default: only_raise"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: only_raise, only_fail, semantic"
        }
      },
      "description": "Checks for uses of `fail` and `raise`."
    },
    "Style/SingleArgumentDig": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Sometimes using `dig` method ends up with just a single argument. In such cases, dig should be replaced with `[]`.\n\nSince replacing `hash&.dig(:key)` with `hash[:key]` could potentially lead to error, calls to the `dig` method using safe navigation will be ignored."
    },
    "Style/SingleLineBlockParams": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Methods": {
          "type": "array",
          "description": "Default: {\"reduce\" ⇒ [\"acc\", \"elem\"]}, {\"inject\" ⇒ [\"acc\", \"elem\"]}"
        }
      },
      "description": "Checks whether the block parameters of a single-line method accepting a block match the names specified via configuration.\n\nFor instance one can configure `reduce`(`inject`) to use |a, e| as parameters.\n\nConfiguration option: Methods Should be set to use this cop. `Array` of hashes, where each key is the method name and value - array of argument names."
    },
    "Style/SingleLineDoEndBlock": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for single-line `do`...`end` block.\n\nIn practice a single line `do`...`end` is autocorrected when `EnforcedStyle: semantic` is configured for `Style/BlockDelimiters`. The autocorrection maintains the `do` ... `end` syntax to preserve semantics and does not change it to `{`...`}` block.\n\nIf `InspectBlocks` is set to `true` for `Layout/RedundantLineBreak`, blocks will be autocorrected to be on a single line if possible. This cop respects that configuration by not registering an offense if it would subsequently cause a `Layout/RedundantLineBreak` offense."
    },
    "Style/SingleLineMethods": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowIfMethodIsEmpty": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "Checks for single-line method definitions that contain a body. It will accept single-line methods with no body.\n\nEndless methods added in Ruby 3.0 are also accepted by this cop.\n\nIf `Style/EndlessMethod` is enabled with `EnforcedStyle: allow_single_line`, `allow_always`, `require_single_line`, or `require_always`, single-line methods will be autocorrected to endless methods if there is only one statement in the body."
    },
    "Style/SlicingWithRange": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks that arrays are not sliced with the redundant `ary[0..-1]`, replacing it with `ary`, and ensures arrays are sliced with endless ranges instead of `ary[start..-1]` on Ruby 2.6+, and with beginless ranges instead of `ary[nil..end]` on Ruby 2.7+."
    },
    "Style/SoleNestedConditional": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowModifier": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "If the branch of a conditional consists solely of a conditional node, its conditions can be combined with the conditions of the outer branch. This helps to keep the nesting level from getting too deep."
    },
    "Style/SpecialGlobalVars": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "RequireEnglish": {
          "type": "boolean",
          "description": "Default: true"
        },
        "EnforcedStyle": {
          "enum": [
            "use_perl_names",
            "use_english_names",
            "use_builtin_english_names"
          ],
          "description": "Default: use_english_names"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: use_perl_names, use_english_names, use_builtin_english_names"
        }
      },
      "description": "Looks for uses of Perl-style global variables. Correcting to global variables in the 'English' library will add a require statement to the top of the file if enabled by RequireEnglish config."
    },
    "Style/StabbyLambdaParentheses": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["require_parentheses", "require_no_parentheses"],
          "description": "Default: require_parentheses"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: require_parentheses, require_no_parentheses"
        }
      },
      "description": "Check for parentheses around stabby lambda arguments. There are two different styles. Defaults to `require_parentheses`."
    },
    "Style/StaticClass": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for places where classes with only class methods can be replaced with a module. Classes should be used only when it makes sense to create instances out of them."
    },
    "Style/StderrPuts": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Identifies places where `$stderr.puts` can be replaced by `warn`. The latter has the advantage of easily being disabled by, the `-W0` interpreter flag or setting `$VERBOSE` to `nil`."
    },
    "Style/StringChars": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for uses of `String#split` with empty string or regexp literal argument."
    },
    "Style/StringConcatenation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Mode": {
          "type": "string",
          "description": "Default: aggressive"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for places where string concatenation can be replaced with string interpolation.\n\nThe cop can autocorrect simple cases but will skip autocorrecting more complex cases where the resulting code would be harder to read. In those cases, it might be useful to extract statements to local variables or methods which you can then interpolate in a string.\n\nWhen concatenation between two strings is broken over multiple lines, this cop does not register an offense; instead, `Style/LineEndConcatenation` will pick up the offense if enabled.\n\nTwo modes are supported: 1. `aggressive` style checks and corrects all occurrences of `+` where either the left or right side of `+` is a string literal. 2. `conservative` style on the other hand, checks and corrects only if left side (receiver of `+` method call) is a string literal. This is useful when the receiver is some expression that returns string like `Pathname` instead of a string literal."
    },
    "Style/StringHashKeys": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for the use of strings as keys in hashes. The use of symbols is preferred instead."
    },
    "Style/StringLiterals": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["single_quotes", "double_quotes"],
          "description": "Default: single_quotes"
        },
        "ConsistentQuotesInMultiline": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: single_quotes, double_quotes"
        }
      },
      "description": "Checks if uses of quotes match the configured preference."
    },
    "Style/StringLiteralsInInterpolation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["single_quotes", "double_quotes"],
          "description": "Default: single_quotes"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: single_quotes, double_quotes"
        }
      },
      "description": "Checks that quotes inside string, symbol, and regexp interpolations match the configured preference."
    },
    "Style/StringMethods": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "PreferredMethods": {
          "description": "Default: {\"intern\" ⇒ \"to_sym\"}"
        }
      },
      "description": "Enforces the use of consistent method names from the `String` class."
    },
    "Style/Strip": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Identifies places where `lstrip.rstrip` can be replaced by `strip`."
    },
    "Style/StructInheritance": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for inheritance from Struct.new."
    },
    "Style/SuperArguments": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for redundant argument forwarding when calling super with arguments identical to the method definition.\n\nUsing zero arity `super` within a `define_method` block results in `RuntimeError`:\n\ndef m   define_method(:foo) { super() } # => OK end  def m   define_method(:foo) { super }   # => RuntimeError end\n\nFurthermore, any arguments accompanied by a block may potentially be delegating to `define_method`, therefore, `super` used within these blocks will be allowed. This approach might result in false negatives, yet ensuring safe detection takes precedence.\n\nWhen forwarding the same arguments but replacing the block argument with a new inline block, it is not necessary to explicitly list the non-block arguments. As such, an offense will be registered in this case."
    },
    "Style/SuperWithArgsParentheses": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Enforces the presence of parentheses in `super` containing arguments.\n\n`super` is a keyword and is provided as a distinct cop from those designed for method call."
    },
    "Style/SwapValues": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Enforces the use of shorthand-style swapping of 2 variables."
    },
    "Style/SymbolArray": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["percent", "brackets"],
          "description": "Default: percent"
        },
        "MinSize": {
          "type": "integer",
          "description": "Default: 2"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: percent, brackets"
        }
      },
      "description": "Checks for array literals made up of symbols that are not using the %i() syntax.\n\nAlternatively, it checks for symbol arrays using the %i() syntax on projects which do not want to use that syntax, perhaps because they support a version of Ruby lower than 2.0.\n\nConfiguration option: MinSize If set, arrays with fewer elements than this value will not trigger the cop. For example, a `MinSize` of `3` will not enforce a style on an array of 2 or fewer elements."
    },
    "Style/SymbolLiteral": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks symbol literal syntax."
    },
    "Style/SymbolProc": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowMethodsWithArguments": {
          "type": "boolean",
          "description": "Default: false"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: define_method"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowComments": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Use symbols as procs when possible.\n\nIf you prefer a style that allows block for method with arguments, please set `true` to `AllowMethodsWithArguments`. `define_method?` methods are allowed by default. These are customizable with `AllowedMethods` option."
    },
    "Style/TernaryParentheses": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "require_parentheses",
            "require_no_parentheses",
            "require_parentheses_when_complex"
          ],
          "description": "Default: require_no_parentheses"
        },
        "AllowSafeAssignment": {
          "type": "boolean",
          "description": "Default: true"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: require_parentheses, require_no_parentheses, require_parentheses_when_complex"
        }
      },
      "description": "Checks for the presence of parentheses around ternary conditions. It is configurable to enforce inclusion or omission of parentheses using `EnforcedStyle`. Omission is only enforced when removing the parentheses won't cause a different behavior.\n\n`AllowSafeAssignment` option for safe assignment. By safe assignment we mean putting parentheses around an assignment to indicate \"I know I'm using an assignment as a condition. It's not a mistake.\""
    },
    "Style/TopLevelMethodDefinition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Newcomers to ruby applications may write top-level methods, when ideally they should be organized in appropriate classes or modules. This cop looks for definitions of top-level methods and warns about them.\n\nHowever for ruby scripts it is perfectly fine to use top-level methods. Hence this cop is disabled by default."
    },
    "Style/TrailingBodyOnClass": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for trailing code after the class definition."
    },
    "Style/TrailingBodyOnMethodDefinition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for trailing code after the method definition.\n\nIt always accepts endless method definitions that are basically on the same line."
    },
    "Style/TrailingBodyOnModule": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for trailing code after the module definition."
    },
    "Style/TrailingCommaInArguments": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyleForMultiline": {
          "enum": ["comma", "consistent_comma", "no_comma"],
          "description": "Default: no_comma"
        },
        "SupportedStylesForMultiline": {
          "type": "array",
          "description": "Default: comma, consistent_comma, no_comma"
        }
      },
      "description": "Checks for trailing comma in argument lists. The supported styles are:\n\n - consistent_comma: Requires a comma after the last argument, for all parenthesized multi-line method calls with arguments.\n\n - comma: Requires a comma after the last argument, but only for parenthesized method calls where each argument is on its own line.\n\n - no_comma: Requires that there is no comma after the last argument.\n\nRegardless of style, trailing commas are not allowed in single-line method calls."
    },
    "Style/TrailingCommaInArrayLiteral": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyleForMultiline": {
          "enum": ["comma", "consistent_comma", "diff_comma", "no_comma"],
          "description": "Default: no_comma"
        },
        "SupportedStylesForMultiline": {
          "type": "array",
          "description": "Default: comma, consistent_comma, diff_comma, no_comma"
        }
      },
      "description": "Checks for trailing comma in array literals. The configuration options are:\n\n - consistent_comma: Requires a comma after the last item of all non-empty, multiline array literals.\n\n - comma: Requires a comma after the last item in an array, but only when each item is on its own line.\n\n - diff_comma: Requires a comma after the last item in an array, but only when that item is followed by an immediate newline.\n\n - no_comma: Does not require a comma after the last item in an array"
    },
    "Style/TrailingCommaInBlockArgs": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks whether trailing commas in block arguments are required. Blocks with only one argument and a trailing comma require that comma to be present. Blocks with more than one argument never require a trailing comma."
    },
    "Style/TrailingCommaInHashLiteral": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyleForMultiline": {
          "enum": ["comma", "consistent_comma", "diff_comma", "no_comma"],
          "description": "Default: no_comma"
        },
        "SupportedStylesForMultiline": {
          "type": "array",
          "description": "Default: comma, consistent_comma, diff_comma, no_comma"
        }
      },
      "description": "Checks for trailing comma in hash literals. The configuration options are:\n\n - consistent_comma: Requires a comma after the last item of all non-empty, multiline hash literals.\n\n - comma: Requires a comma after the last item in a hash, but only when each item is on its own line.\n\n - diff_comma: Requires a comma after the last item in a hash, but only when that item is followed by an immediate newline.\n\n - no_comma: Does not require a comma after the last item in a hash"
    },
    "Style/TrailingMethodEndStatement": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for trailing code after the method definition."
    },
    "Style/TrailingUnderscoreVariable": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowNamedUnderscoreVariables": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "Checks for extra underscores in variable assignment."
    },
    "Style/TrivialAccessors": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "ExactNameMatch": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowPredicates": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowDSLWriters": {
          "type": "boolean",
          "description": "Default: true"
        },
        "IgnoreClassMethods": {
          "type": "boolean",
          "description": "Default: false"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: to_ary, to_a, to_c, to_enum, to_h, to_hash, to_i, to_int, to_io, to_open, to_path, to_proc, to_r, to_regexp, to_str, to_s, to_sym"
        }
      },
      "description": "Looks for trivial reader/writer methods, that could have been created with the attr_* family of functions automatically. `to_ary`, `to_a`, `to_c`, `to_enum`, `to_h`, `to_hash`, `to_i`, `to_int`, `to_io`, `to_open`, `to_path`, `to_proc`, `to_r`, `to_regexp`, `to_str`, `to_s`, and `to_sym` methods are allowed by default. These are customizable with `AllowedMethods` option."
    },
    "Style/UnlessElse": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Looks for `unless` expressions with `else` clauses."
    },
    "Style/UnlessLogicalOperators": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "forbid_mixed_logical_operators",
            "forbid_logical_operators"
          ],
          "description": "Default: forbid_mixed_logical_operators"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: forbid_mixed_logical_operators, forbid_logical_operators"
        }
      },
      "description": "Checks for the use of logical operators in an `unless` condition. It discourages such code, as the condition becomes more difficult to read and understand.\n\nThis cop supports two styles:\n\n - forbid_mixed_logical_operators (default)\n\n - forbid_logical_operators\n\n`forbid_mixed_logical_operators` style forbids the use of more than one type of logical operators. This makes the `unless` condition easier to read because either all conditions need to be met or any condition need to be met in order for the expression to be truthy or falsey.\n\n`forbid_logical_operators` style forbids any use of logical operator. This makes it even more easy to read the `unless` condition as there is only one condition in the expression."
    },
    "Style/UnpackFirst": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for accessing the first element of `String#unpack` which can be replaced with the shorter method `unpack1`."
    },
    "Style/VariableInterpolation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for variable interpolation (like \"#@ivar\")."
    },
    "Style/WhenThen": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for `when;` uses in `case` expressions."
    },
    "Style/WhileUntilDo": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for uses of `do` in multi-line `while/until` statements."
    },
    "Style/WhileUntilModifier": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for while and until statements that would fit on one line if written as a modifier while/until. The maximum line length is configured in the `Layout/LineLength` cop."
    },
    "Style/WordArray": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["percent", "brackets"],
          "description": "Default: percent"
        },
        "MinSize": {
          "type": "integer",
          "description": "Default: 2"
        },
        "WordRegex": {
          "description": "Default: (?-mix:\\A(?:\\p{Word}|\\p{Word}-\\p{Word}|\\n|\\t)+\\z)"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: percent, brackets"
        }
      },
      "description": "Checks for array literals made up of word-like strings, that are not using the %w() syntax.\n\nAlternatively, it can check for uses of the %w() syntax, in projects which do not want to include that syntax.\n\nWhen using the `percent` style, %w() arrays containing a space will be registered as offenses.\n\nConfiguration option: MinSize If set, arrays with fewer elements than this value will not trigger the cop. For example, a `MinSize` of `3` will not enforce a style on an array of 2 or fewer elements."
    },
    "Style/YAMLFileRead": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for the use of `YAML.load`, `YAML.safe_load`, and `YAML.parse` with `File.read` argument.\n\n`YAML.safe_load_file` was introduced in Ruby 3.0."
    },
    "Style/YodaCondition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "forbid_for_all_comparison_operators",
            "forbid_for_equality_operators_only",
            "require_for_all_comparison_operators",
            "require_for_equality_operators_only"
          ],
          "description": "Default: forbid_for_all_comparison_operators"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://en.wikipedia.org/wiki/Yoda_conditions"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: forbid_for_all_comparison_operators, forbid_for_equality_operators_only, require_for_all_comparison_operators, require_for_equality_operators_only"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Enforces or forbids Yoda conditions, i.e. comparison operations where the order of expression is reversed. eg. `5 == x`"
    },
    "Style/YodaExpression": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedOperators": {
          "type": "array",
          "description": "Default: *, +, &, |, ^"
        }
      },
      "description": "Forbids Yoda expressions, i.e. binary operations (using `*`, `+`, `&`, `|`, and `^` operators) where the order of expression is reversed, eg. `1 + x`. This cop complements `Style/YodaCondition` cop, which has a similar purpose.\n\nThis cop is disabled by default to respect user intentions such as:\n\nconfig.server_port = 9000 + ENV[\"TEST_ENV_NUMBER\"].to_i"
    },
    "Style/ZeroLengthPredicate": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for numeric comparisons that can be replaced by a predicate method, such as `receiver.length == 0`, `receiver.length > 0`, and `receiver.length != 0`, `receiver.length < 1` and `receiver.size == 0` that can be replaced by `receiver.empty?` and `!receiver.empty?`.\n\n`File`, `Tempfile`, and `StringIO` do not have `empty?` so allow `size == 0` and `size.zero?`."
    },
    "Performance": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "DocumentationBaseURL": {
          "type": "string",
          "description": "Default: https://docs.rubocop.org/rubocop-performance"
        }
      },
      "description": "'Performance' department (performance extension)"
    },
    "Performance/AncestorsInclude": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://github.com/fastruby/fast-ruby#ancestorsinclude-vs--code"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Identifies usages of `ancestors.include?` and change them to use `<=` instead."
    },
    "Performance/ArraySemiInfiniteRangeSlice": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Identifies places where slicing arrays with semi-infinite ranges can be replaced by `Array#take` and `Array#drop`. This cop was created due to a mistake in microbenchmark and hence is disabled by default. Refer https://github.com/rubocop/rubocop-performance/pull/175#issuecomment-731892717"
    },
    "Performance/BigDecimalWithNumericArgument": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Identifies places where a float argument to BigDecimal should be converted to a string. Initializing from String is faster than from Float for BigDecimal.\n\nAlso identifies places where an integer string argument to BigDecimal should be converted to an integer. Initializing from Integer is faster than from String for BigDecimal."
    },
    "Performance/BindCall": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "In Ruby 2.7, `UnboundMethod#bind_call` has been added.\n\nThis cop identifies places where `bind(obj).call(args, ...)` can be replaced by `bind_call(obj, args, ...)`.\n\nThe `bind_call(obj, args, ...)` method is faster than `bind(obj).call(args, ...)`."
    },
    "Performance/BlockGivenWithExplicitBlock": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Identifies unnecessary use of a `block_given?` where explicit check of block argument would suffice.\n\nThis cop produces code with significantly worse performance when a block is being passed to the method and as such should not be enabled."
    },
    "Performance/Caller": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Identifies places where `caller[n]` can be replaced by `caller(n..n).first`."
    },
    "Performance/CaseWhenSplat": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Reordering `when` conditions with a splat to the end of the `when` branches can improve performance.\n\nRuby has to allocate memory for the splat expansion every time that the `case` `when` statement is run. Since Ruby does not support fall through inside of `case` `when`, like some other languages do, the order of the `when` branches should not matter. By placing any splat expansions at the end of the list of `when` branches we will reduce the number of times that memory has to be allocated for the expansion. The exception to this is if multiple of your `when` conditions can be true for any given condition. A likely scenario for this defining a higher level when condition to override a condition that is inside of the splat expansion."
    },
    "Performance/Casecmp": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://github.com/fastruby/fast-ruby#stringcasecmp-vs--stringcasecmp-vs-stringdowncase---code"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Identifies places where a case-insensitive string comparison can better be implemented using `casecmp`.\n\nThis cop is disabled by default because `String#casecmp` only works with ASCII characters. See https://github.com/rubocop/rubocop/issues/9753.\n\nIf you are working only with ASCII characters, then this cop can be safely enabled."
    },
    "Performance/ChainArrayAllocation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://twitter.com/schneems/status/1034123879978029057"
        }
      },
      "description": "Identifies usages of `array.compact.flatten.map { |x| x.downcase }`. Each of these methods (`compact`, `flatten`, `map`) will generate a new intermediate array that is promptly thrown away. Instead it is faster to mutate when we know it's safe."
    },
    "Performance/CollectionLiteralInLoop": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "MinSize": {
          "type": "integer",
          "description": "Default: 1"
        }
      },
      "description": "Identifies places where Array and Hash literals are used within loops. It is better to extract them into a local variable or constant to avoid unnecessary allocations on each iteration.\n\nYou can set the minimum number of elements to consider an offense with `MinSize`."
    },
    "Performance/CompareWithBlock": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Identifies places where `sort { |a, b| a.foo <=> b.foo }` can be replaced by `sort_by(&:foo)`. This cop also checks `sort!`, `min`, `max` and `minmax` methods."
    },
    "Performance/ConcurrentMonotonicTime": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://github.com/rails/rails/pull/43502"
        }
      },
      "description": "Identifies places where `Concurrent.monotonic_time` can be replaced by `Process.clock_gettime(Process::CLOCK_MONOTONIC)`."
    },
    "Performance/ConstantRegexp": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Finds regular expressions with dynamic components that are all constants.\n\nRuby allocates a new Regexp object every time it executes a code containing such a regular expression. It is more efficient to extract it into a constant, memoize it, or add an `/o` option to perform `#{}` interpolation only once and reuse that Regexp object."
    },
    "Performance/Count": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Identifies usages of `count` on an `Enumerable` that follow calls to `select`, `find_all`, `filter` or `reject`. Querying logic can instead be passed to the `count` call."
    },
    "Performance/DeletePrefix": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeMultiline": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "In Ruby 2.5, `String#delete_prefix` has been added.\n\nThis cop identifies places where `gsub(/\\Aprefix/, '')` and `sub(/\\Aprefix/, '')` can be replaced by `delete_prefix('prefix')`.\n\nThis cop has `SafeMultiline` configuration option that `true` by default because `^prefix` is unsafe as it will behave incompatible with `delete_prefix` for receiver is multiline string.\n\nThe `delete_prefix('prefix')` method is faster than `gsub(/\\Aprefix/, '')`."
    },
    "Performance/DeleteSuffix": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeMultiline": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "In Ruby 2.5, `String#delete_suffix` has been added.\n\nThis cop identifies places where `gsub(/suffix\\z/, '')` and `sub(/suffix\\z/, '')` can be replaced by `delete_suffix('suffix')`.\n\nThis cop has `SafeMultiline` configuration option that `true` by default because `suffix$` is unsafe as it will behave incompatible with `delete_suffix?` for receiver is multiline string.\n\nThe `delete_suffix('suffix')` method is faster than `gsub(/suffix\\z/, '')`."
    },
    "Performance/Detect": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://github.com/fastruby/fast-ruby#enumerabledetect-vs-enumerableselectfirst-code"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Identifies usages of `first`, `last`, `[0]` or `[-1]` chained to `select`, `find_all` or `filter` and change them to use `detect` instead."
    },
    "Performance/DoubleStartEndWith": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "IncludeActiveSupportAliases": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for double `#start_with?` or `#end_with?` calls separated by `||`. In some cases such calls can be replaced with an single `#start_with?`/`#end_with?` call.\n\n`IncludeActiveSupportAliases` configuration option is used to check for `starts_with?` and `ends_with?`. These methods are defined by Active Support."
    },
    "Performance/EndWith": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeMultiline": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://github.com/fastruby/fast-ruby#stringmatch-vs-stringmatch-vs-stringstart_withstringend_with-code-start-code-end"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Identifies unnecessary use of a regex where `String#end_with?` would suffice.\n\nThis cop has `SafeMultiline` configuration option that `true` by default because `end$` is unsafe as it will behave incompatible with `end_with?` for receiver is multiline string."
    },
    "Performance/FixedSize": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Do not compute the size of statically sized objects."
    },
    "Performance/FlatMap": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnabledForFlattenWithoutParams": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://github.com/fastruby/fast-ruby#enumerablemaparrayflatten-vs-enumerableflat_map-code"
        }
      },
      "description": "Identifies usages of `map { ... }.flatten` and change them to use `flat_map { ... }` instead."
    },
    "Performance/InefficientHashSearch": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://github.com/fastruby/fast-ruby#hashkey-instead-of-hashkeysinclude-code"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for inefficient searching of keys and values within hashes.\n\n`Hash#keys.include?` is less efficient than `Hash#key?` because the former allocates a new array and then performs an O(n) search through that array, while `Hash#key?` does not allocate any array and performs a faster O(1) search for the key.\n\n`Hash#values.include?` is less efficient than `Hash#value?`. While they both perform an O(n) search through all of the values, calling `values` allocates a new array while using `value?` does not."
    },
    "Performance/IoReadlines": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://docs.gitlab.com/ee/development/performance.html#reading-from-files-and-other-data-sources"
        }
      },
      "description": "Identifies places where inefficient `readlines` method can be replaced by `each_line` to avoid fully loading file content into memory."
    },
    "Performance/MapCompact": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "In Ruby 2.7, `Enumerable#filter_map` has been added.\n\nThis cop identifies places where `map { ... }.compact` can be replaced by `filter_map`.\n\n[true, false, nil].compact              #=> [true, false] [true, false, nil].filter_map(&:itself) #=> [true]"
    },
    "Performance/MapMethodChain": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks if the map method is used in a chain.\n\nAutocorrection is not supported because an appropriate block variable name cannot be determined automatically.\n\nclass X   def initialize     @@num = 0   end    def foo     @@num += 1     self   end    def bar     @@num * 2   end end  [X.new, X.new].map(&:foo).map(&:bar) # => [4, 4] [X.new, X.new].map { |x| x.foo.bar } # => [2, 4]"
    },
    "Performance/MethodObjectAsBlock": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://github.com/fastruby/fast-ruby#normal-way-to-apply-method-vs-method-code"
        }
      },
      "description": "Identifies places where methods are converted to blocks, with the use of `&method`, and passed as arguments to method calls. It is faster to replace those with explicit blocks, calling those methods inside."
    },
    "Performance/OpenStruct": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for `OpenStruct.new` calls. Instantiation of an `OpenStruct` invalidates Ruby global method cache as it causes dynamic method definition during program runtime. This could have an effect on performance, especially in case of single-threaded applications with multiple `OpenStruct` instantiations."
    },
    "Performance/RangeInclude": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://github.com/fastruby/fast-ruby#cover-vs-include-code"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Identifies uses of `Range#include?` and `Range#member?`, which iterates over each item in a `Range` to see if a specified item is there. In contrast, `Range#cover?` simply compares the target item with the beginning and end points of the `Range`. In a great majority of cases, this is what is wanted."
    },
    "Performance/RedundantBlockCall": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://github.com/fastruby/fast-ruby#proccall-and-block-arguments-vs-yieldcode"
        }
      },
      "description": "Identifies the use of a `&block` parameter and `block.call` where `yield` would do just as well."
    },
    "Performance/RedundantEqualityComparisonBlock": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowRegexpMatch": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://github.com/rails/rails/pull/41363"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for uses `Enumerable#all?`, `Enumerable#any?`, `Enumerable#one?`, and `Enumerable#none?` are compared with `===` or similar methods in block.\n\nBy default, `Object#===` behaves the same as `Object#==`, but this behavior is appropriately overridden in subclass. For example, `Range#===` returns `true` when argument is within the range.\n\nThis cop has `AllowRegexpMatch` option and it is true by default because `regexp.match?('string')` often used in block changes to the opposite result:\n\n[/pattern/].all? { |regexp| regexp.match?('pattern') } # => true [/pattern/].all? { |regexp| regexp =~ 'pattern' }      # => true [/pattern/].all?('pattern')                            # => false"
    },
    "Performance/RedundantMatch": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Identifies the use of `Regexp#match` or `String#match`, which returns `#<MatchData>`/`nil`. The return value of `=~` is an integral index/`nil` and is more performant."
    },
    "Performance/RedundantMerge": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "MaxKeyValuePairs": {
          "type": "integer",
          "description": "Default: 2"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://github.com/fastruby/fast-ruby#hashmerge-vs-hash-code"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Identifies places where `Hash#merge!` can be replaced by `Hash#[]=`. You can set the maximum number of key-value pairs to consider an offense with `MaxKeyValuePairs`."
    },
    "Performance/RedundantSortBlock": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Identifies places where `sort { |a, b| a <=> b }` can be replaced with `sort`."
    },
    "Performance/RedundantSplitRegexpArgument": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Identifies places where `split` argument can be replaced from a deterministic regexp to a string."
    },
    "Performance/RedundantStringChars": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for redundant `String#chars`."
    },
    "Performance/RegexpMatch": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://github.com/fastruby/fast-ruby#regexp-vs-regexpmatch-vs-regexpmatch-vs-stringmatch-vs-string-vs-stringmatch-code-"
        }
      },
      "description": "In Ruby 2.4, `String#match?`, `Regexp#match?`, and `Symbol#match?` have been added. The methods are faster than `match`. Because the methods avoid creating a `MatchData` object or saving backref. So, when `MatchData` is not used, use `match?` instead of `match`."
    },
    "Performance/ReverseEach": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://github.com/fastruby/fast-ruby#enumerablereverseeach-vs-enumerablereverse_each-code"
        }
      },
      "description": "Identifies usages of `reverse.each` and change them to use `reverse_each` instead.\n\nIf the return value is used, it will not be detected because the result will be different.\n\n[1, 2, 3].reverse.each {} #=> [3, 2, 1] [1, 2, 3].reverse_each {} #=> [1, 2, 3]"
    },
    "Performance/ReverseFirst": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Identifies places where `reverse.first(n)` and `reverse.first` can be replaced by `last(n).reverse` and `last`."
    },
    "Performance/SelectMap": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "In Ruby 2.7, `Enumerable#filter_map` has been added.\n\nThis cop identifies places where `select.map` can be replaced by `filter_map`."
    },
    "Performance/Size": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://github.com/fastruby/fast-ruby#arraylength-vs-arraysize-vs-arraycount-code"
        }
      },
      "description": "Identifies usages of `count` on an `Array` and `Hash` and change them to `size`.\n\nTODO: Add advanced detection of variables that could have been assigned to an array or a hash."
    },
    "Performance/SortReverse": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Identifies places where `sort { |a, b| b <=> a }` can be replaced by a faster `sort.reverse`."
    },
    "Performance/Squeeze": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://github.com/fastruby/fast-ruby#remove-extra-spaces-or-other-contiguous-characters-code"
        }
      },
      "description": "Identifies places where `gsub(/a+/, 'a')` and `gsub!(/a+/, 'a')` can be replaced by `squeeze('a')` and `squeeze!('a')`.\n\nThe `squeeze('a')` method is faster than `gsub(/a+/, 'a')`."
    },
    "Performance/StartWith": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeMultiline": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://github.com/fastruby/fast-ruby#stringmatch-vs-stringmatch-vs-stringstart_withstringend_with-code-start-code-end"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Identifies unnecessary use of a regex where `String#start_with?` would suffice.\n\nThis cop has `SafeMultiline` configuration option that `true` by default because `^start` is unsafe as it will behave incompatible with `start_with?` for receiver is multiline string."
    },
    "Performance/StringBytesize": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for calls to `#bytes` counting method and suggests using `bytesize` instead. The `bytesize` method is more efficient and directly returns the size in bytes, avoiding the intermediate array allocation that `bytes.size` incurs."
    },
    "Performance/StringIdentifierArgument": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Identifies places where string identifier argument can be replaced by symbol identifier argument. It prevents the redundancy of the internal string-to-symbol conversion.\n\nThis cop targets methods that take identifier (e.g. method name) argument and the following examples are parts of it."
    },
    "Performance/StringInclude": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Identifies unnecessary use of a regex where `String#include?` would suffice."
    },
    "Performance/StringReplacement": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://github.com/fastruby/fast-ruby#stringgsub-vs-stringtr-code"
        }
      },
      "description": "Identifies places where `gsub` can be replaced by `tr` or `delete`."
    },
    "Performance/Sum": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "OnlySumOrWithInitialValue": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://blog.bigbinary.com/2016/11/02/ruby-2-4-introduces-enumerable-sum.html"
        }
      },
      "description": "Identifies places where custom code finding the sum of elements in some Enumerable object can be replaced by `Enumerable#sum` method."
    },
    "Performance/TimesMap": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for .times.map calls. In most cases such calls can be replaced with an explicit array creation."
    },
    "Performance/UnfreezeString": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "In Ruby 2.3 or later, use unary plus operator to unfreeze a string literal instead of `String#dup` and `String.new`. Unary plus operator is faster than `String#dup`."
    },
    "Performance/UriDefaultParser": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Identifies places where `URI::Parser.new` can be replaced by `URI::DEFAULT_PARSER`."
    },
    "Performance/ZipWithoutBlock": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for `map { |id| [id] }` and suggests replacing it with `zip`."
    },
    "Rake": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: Rakefile, **/*.rake"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      }
    },
    "Rake/ClassDefinitionInTask": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Do not define a class or module in rake task, because it will be defined to the top level."
    },
    "Rake/Desc": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Describe the task with `desc` method."
    },
    "Rake/DuplicateNamespace": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Do not define namespace with the same name"
    },
    "Rake/DuplicateTask": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Do not define tasks with the same name"
    },
    "Rake/MethodDefinitionInTask": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Do not define a method in rake task, because it will be defined to the top level."
    },
    "RSpec": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*_spec.rb, **/spec/**/*"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string",
          "description": "Default: https://rspec.rubystyle.guide"
        },
        "StyleGuide": {
          "type": "string"
        },
        "DocumentationBaseURL": {
          "type": "string",
          "description": "Default: https://docs.rubocop.org/rubocop-rspec"
        },
        "Language": {
          "description": "Default: {\"inherit_mode\"=>{\"merge\"=>[\"Expectations\", \"Helpers\", \"Hooks\", \"Subjects\"]}, \"ExampleGroups\"=>{\"inherit_mode\"=>{\"merge\"=>[\"Regular\", \"Skipped\", \"Focused\"]}, \"Regular\"=>[\"describe\", \"context\", \"feature\", \"example_group\"], \"Skipped\"=>[\"xdescribe\", \"xcontext\", \"xfeature\"], \"Focused\"=>[\"fdescribe\", \"fcontext\", \"ffeature\"]}, \"Examples\"=>{\"inherit_mode\"=>{\"merge\"=>[\"Regular\", \"Skipped\", \"Focused\", \"Pending\"]}, \"Regular\"=>[\"it\", \"specify\", \"example\", \"scenario\", \"its\"], \"Focused\"=>[\"fit\", \"fspecify\", \"fexample\", \"fscenario\", \"focus\"], \"Skipped\"=>[\"xit\", \"xspecify\", \"xexample\", \"xscenario\", \"skip\"], \"Pending\"=>[\"pending\"]}, \"Expectations\"=>[\"are_expected\", \"expect\", \"expect_any_instance_of\", \"is_expected\", \"should\", \"should_not\", \"should_not_receive\", \"should_receive\"], \"Helpers\"=>[\"let\", \"let!\"], \"Hooks\"=>[\"prepend_before\", \"before\", \"append_before\", \"around\", \"prepend_after\", \"after\", \"append_after\"], \"Includes\"=>{\"inherit_mode\"=>{\"merge\"=>[\"Examples\", \"Context\"]}, \"Examples\"=>[\"it_behaves_like\", \"it_should_behave_like\", \"include_examples\"], \"Context\"=>[\"include_context\"]}, \"SharedGroups\"=>{\"inherit_mode\"=>{\"merge\"=>[\"Examples\", \"Context\"]}, \"Examples\"=>[\"shared_examples\", \"shared_examples_for\"], \"Context\"=>[\"shared_context\"]}, \"Subjects\"=>[\"subject\", \"subject!\"]}"
        }
      },
      "description": "'RSpec' department (rspec extension)"
    },
    "RSpec/AlignLeftLetBrace": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/AlignLeftLetBrace"
        }
      },
      "description": "Checks that left braces for adjacent single line lets are aligned."
    },
    "RSpec/AlignRightLetBrace": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/AlignRightLetBrace"
        }
      },
      "description": "Checks that right braces for adjacent single line lets are aligned."
    },
    "RSpec/AnyInstance": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/AnyInstance"
        }
      },
      "description": "Check that instances are not being stubbed globally.\n\nPrefer instance doubles over stubbing any instance of a class"
    },
    "RSpec/AroundBlock": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/AroundBlock"
        }
      },
      "description": "Checks that around blocks actually run the test."
    },
    "RSpec/Be": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/Be"
        }
      },
      "description": "Check for expectations where `be` is used without argument.\n\nThe `be` matcher is too generic, as it pass on everything that is not nil or false. If that is the exact intend, use `be_truthy`. In all other cases it's better to specify what exactly is the expected value."
    },
    "RSpec/BeEmpty": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "string",
          "description": "Default: contextual"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/BeEmpty"
        }
      },
      "description": "Prefer using `be_empty` when checking for an empty array."
    },
    "RSpec/BeEq": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/BeEq"
        }
      },
      "description": "Check for expectations where `be(...)` can replace `eq(...)`.\n\nThe `be` matcher compares by identity while the `eq` matcher compares using `==`. Booleans and nil can be compared by identity and therefore the `be` matcher is preferable as it is a more strict test."
    },
    "RSpec/BeEql": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/BeEql"
        }
      },
      "description": "Check for expectations where `be(...)` can replace `eql(...)`.\n\nThe `be` matcher compares by identity while the `eql` matcher compares using `eql?`. Integers, floats, booleans, symbols, and nil can be compared by identity and therefore the `be` matcher is preferable as it is a more strict test.\n\nThis cop only looks for instances of `expect(...).to eql(...)`. We do not check `to_not` or `not_to` since `!eql?` is more strict than `!equal?`. We also do not try to flag `eq` because if `a == b`, and `b` is comparable by identity, `a` is still not necessarily the same type as `b` since the `#==` operator can coerce objects for comparison."
    },
    "RSpec/BeNil": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["be", "be_nil"],
          "description": "Default: be_nil"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: be, be_nil"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/BeNil"
        }
      },
      "description": "Ensures a consistent style is used when matching `nil`.\n\nYou can either use the more specific `be_nil` matcher, or the more generic `be` matcher with a `nil` argument.\n\nThis cop can be configured using the `EnforcedStyle` option"
    },
    "RSpec/BeforeAfterAll": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/spec/spec_helper.rb, **/spec/rails_helper.rb, **/spec/support/**/*.rb"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/BeforeAfterAll"
        }
      },
      "description": "Check that before/after(:all/:context) isn't being used."
    },
    "RSpec/ChangeByZero": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "NegatedMatcher": {
          "description": "Default: <none>"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ChangeByZero"
        }
      },
      "description": "Prefer negated matchers over `to change.by(0)`.\n\nIn the case of composite expectations, cop suggest using the negation matchers of `RSpec::Matchers#change`.\n\nBy default the cop does not support autocorrect of compound expectations, but if you set the negated matcher for `change`, e.g. `not_change` with the `NegatedMatcher` option, the cop will perform the autocorrection."
    },
    "RSpec/ClassCheck": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["be_a", "be_kind_of"],
          "description": "Default: be_a"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: be_a, be_kind_of"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ClassCheck"
        }
      },
      "description": "Enforces consistent use of `be_a` or `be_kind_of`."
    },
    "RSpec/ContainExactly": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ContainExactly"
        }
      },
      "description": "Checks where `contain_exactly` is used.\n\nThis cop checks for the following:\n\n - Prefer match_array when matching array values.\n\n - Prefer be_empty when using contain_exactly with no arguments."
    },
    "RSpec/ContextMethod": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ContextMethod"
        }
      },
      "description": "`context` should not be used for specifying methods."
    },
    "RSpec/ContextWording": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Prefixes": {
          "type": "array",
          "description": "Default: when, with, without"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ContextWording"
        }
      },
      "description": "Checks that `context` docstring starts with an allowed prefix.\n\nThe default list of prefixes is minimal. Users are encouraged to tailor the configuration to meet project needs. Other acceptable prefixes may include `if`, `unless`, `for`, `before`, `after`, or `during`. They may consist of multiple words if desired.\n\nIf both `Prefixes` and `AllowedPatterns` are empty, this cop will always report an offense. So you need to set at least one of them.\n\nThis cop can be customized allowed context description pattern with `AllowedPatterns`. By default, there are no checking by pattern."
    },
    "RSpec/DescribeClass": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/spec/features/**/*, **/spec/requests/**/*, **/spec/routing/**/*, **/spec/system/**/*, **/spec/views/**/*"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "IgnoredMetadata": {
          "description": "Default: {\"type\" ⇒ [\"channel\", \"controller\", \"helper\", \"job\", \"mailer\", \"model\", \"request\", \"routing\", \"view\", \"feature\", \"system\", \"mailbox\", \"aruba\", \"task\"]}"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/DescribeClass"
        }
      },
      "description": "Check that the first argument to the top-level describe is a constant.\n\nIt can be configured to ignore strings when certain metadata is passed.\n\nIgnores Rails and Aruba `type` metadata by default."
    },
    "RSpec/DescribeMethod": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/DescribeMethod"
        }
      },
      "description": "Checks that the second argument to `describe` specifies a method."
    },
    "RSpec/DescribeSymbol": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/DescribeSymbol"
        }
      },
      "description": "Avoid describing symbols."
    },
    "RSpec/DescribedClass": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SkipBlocks": {
          "type": "boolean",
          "description": "Default: false"
        },
        "EnforcedStyle": {
          "enum": ["described_class", "explicit"],
          "description": "Default: described_class"
        },
        "OnlyStaticConstants": {
          "type": "boolean",
          "description": "Default: true"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: described_class, explicit"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/DescribedClass"
        }
      },
      "description": "Checks that tests use `described_class`.\n\nIf the first argument of describe is a class, the class is exposed to each example via described_class.\n\nThis cop can be configured using the `EnforcedStyle`, `SkipBlocks` and `OnlyStaticConstants` options. `OnlyStaticConstants` is only relevant when `EnforcedStyle` is `described_class`.\n\nThere's a known caveat with rspec-rails's `controller` helper that runs its block in a different context, and `described_class` is not available to it. `SkipBlocks` option excludes detection in all non-RSpec related blocks.\n\nTo narrow down this setting to only a specific directory, it is possible to use an overriding configuration file local to that directory."
    },
    "RSpec/DescribedClassModuleWrapping": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/DescribedClassModuleWrapping"
        }
      },
      "description": "Avoid opening modules and defining specs within them."
    },
    "RSpec/Dialect": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "PreferredMethods": {
          "description": "Default: {}"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/Dialect"
        }
      },
      "description": "Enforces custom RSpec dialects.\n\nA dialect can be based on the following RSpec methods:\n\n - describe, context, feature, example_group\n\n - xdescribe, xcontext, xfeature\n\n - fdescribe, fcontext, ffeature\n\n - shared_examples, shared_examples_for, shared_context\n\n - it, specify, example, scenario, its\n\n - fit, fspecify, fexample, fscenario, focus\n\n - xit, xspecify, xexample, xscenario, skip\n\n - pending\n\n - prepend_before, before, append_before,\n\n - around\n\n - prepend_after, after, append_after\n\n - let, let!\n\n - subject, subject!\n\n - expect, is_expected, expect_any_instance_of\n\nBy default all of the RSpec methods and aliases are allowed. By setting a config like:\n\n  RSpec/Dialect:\n    PreferredMethods:\n      context: describe\n\nIf you were previously using the `RSpec/Capybara/FeatureMethods` cop and want to keep disabling all Capybara-specific methods that have the same native RSpec method (e.g. are just aliases), use the following config:\n\n  RSpec/Dialect:\n    PreferredMethods:\n      background: :before\n      scenario:   :it\n      xscenario:  :xit\n      given:      :let\n      given!:     :let!\n      feature:    :describe\n\nYou can expect the following behavior:"
    },
    "RSpec/DuplicatedMetadata": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/DuplicatedMetadata"
        }
      },
      "description": "Avoid duplicated metadata."
    },
    "RSpec/EmptyExampleGroup": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "string",
          "description": "Default: contextual"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/EmptyExampleGroup"
        }
      },
      "description": "Checks if an example group does not include any tests."
    },
    "RSpec/EmptyHook": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "string",
          "description": "Default: contextual"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/EmptyHook"
        }
      },
      "description": "Checks for empty before and after hooks."
    },
    "RSpec/EmptyLineAfterExample": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowConsecutiveOneLiners": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/EmptyLineAfterExample"
        }
      },
      "description": "Checks if there is an empty line after example blocks."
    },
    "RSpec/EmptyLineAfterExampleGroup": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/EmptyLineAfterExampleGroup"
        }
      },
      "description": "Checks if there is an empty line after example group blocks."
    },
    "RSpec/EmptyLineAfterFinalLet": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/EmptyLineAfterFinalLet"
        }
      },
      "description": "Checks if there is an empty line after the last let block."
    },
    "RSpec/EmptyLineAfterHook": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowConsecutiveOneLiners": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/EmptyLineAfterHook"
        }
      },
      "description": "Checks if there is an empty line after hook blocks.\n\n`AllowConsecutiveOneLiners` configures whether adjacent one-line definitions are considered an offense."
    },
    "RSpec/EmptyLineAfterSubject": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/EmptyLineAfterSubject"
        }
      },
      "description": "Checks if there is an empty line after subject block."
    },
    "RSpec/EmptyMetadata": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "string",
          "description": "Default: contextual"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/EmptyMetadata"
        }
      },
      "description": "Avoid empty metadata hash."
    },
    "RSpec/EmptyOutput": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/EmptyOutput"
        }
      },
      "description": "Check that the `output` matcher is not called with an empty string."
    },
    "RSpec/Eq": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/Eq"
        }
      },
      "description": "Use `eq` instead of `be ==` to compare objects."
    },
    "RSpec/ExampleLength": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Max": {
          "type": "integer",
          "description": "Default: 5"
        },
        "CountAsOne": {
          "type": "array",
          "description": "Default: []"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ExampleLength"
        }
      },
      "description": "Checks for long examples.\n\nA long example is usually more difficult to understand. Consider extracting out some behavior, e.g. with a `let` block, or a helper method.\n\nYou can set constructs you want to fold with `CountAsOne`. Available are: 'array', 'hash', 'heredoc', and 'method_call'. Each construct will be counted as one line regardless of its actual size."
    },
    "RSpec/ExampleWithoutDescription": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["always_allow", "single_line_only", "disallow"],
          "description": "Default: always_allow"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: always_allow, single_line_only, disallow"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ExampleWithoutDescription"
        }
      },
      "description": "Checks for examples without a description.\n\nRSpec allows for auto-generated example descriptions when there is no description provided or the description is an empty one. It is acceptable to use `specify` without a description\n\nThis cop removes empty descriptions. It also defines whether auto-generated description is allowed, based on the configured style.\n\nThis cop can be configured using the `EnforcedStyle` option"
    },
    "RSpec/ExampleWording": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "CustomTransform": {
          "description": "Default: {\"be\" ⇒ \"is\", \"BE\" ⇒ \"IS\", \"have\" ⇒ \"has\", \"HAVE\" ⇒ \"HAS\"}"
        },
        "IgnoredWords": {
          "type": "array",
          "description": "Default: []"
        },
        "DisallowedExamples": {
          "type": "array",
          "description": "Default: works"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ExampleWording"
        }
      },
      "description": "Checks for common mistakes in example descriptions.\n\nThis cop will correct docstrings that begin with 'should' and 'it'. This cop will also look for insufficient examples and call them out.\n\nThe autocorrect is experimental - use with care! It can be configured with CustomTransform (e.g. have => has) and IgnoredWords (e.g. only).\n\nUse the DisallowedExamples setting to prevent unclear or insufficient descriptions. Please note that this config will not be treated as case sensitive."
    },
    "RSpec/ExcessiveDocstringSpacing": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ExcessiveDocstringSpacing"
        }
      },
      "description": "Checks for excessive whitespace in example descriptions."
    },
    "RSpec/ExpectActual": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/spec/routing/**/*"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ExpectActual"
        }
      },
      "description": "Checks for `expect(...)` calls containing literal values.\n\nAutocorrection is performed when the expected is not a literal."
    },
    "RSpec/ExpectChange": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["method_call", "block"],
          "description": "Default: method_call"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: method_call, block"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ExpectChange"
        }
      },
      "description": "Checks for consistent style of change matcher.\n\nEnforces either passing a receiver and message as method arguments, or a block.\n\nThis cop can be configured using the `EnforcedStyle` option."
    },
    "RSpec/ExpectInHook": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ExpectInHook"
        }
      },
      "description": "Do not use `expect` in hooks such as `before`."
    },
    "RSpec/ExpectInLet": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ExpectInLet"
        }
      },
      "description": "Do not use `expect` in let."
    },
    "RSpec/ExpectOutput": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ExpectOutput"
        }
      },
      "description": "Checks for opportunities to use `expect { ... }.to output`."
    },
    "RSpec/Focus": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "string",
          "description": "Default: contextual"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/Focus"
        }
      },
      "description": "Checks if examples are focused.\n\nThis cop does not support autocorrection in some cases."
    },
    "RSpec/HookArgument": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["implicit", "each", "example"],
          "description": "Default: implicit"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: implicit, each, example"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/HookArgument"
        }
      },
      "description": "Checks the arguments passed to `before`, `around`, and `after`.\n\nThis cop checks for consistent style when specifying RSpec hooks which run for each example. There are three supported styles: \"implicit\", \"each\", and \"example.\" All styles have the same behavior."
    },
    "RSpec/HooksBeforeExamples": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "string",
          "description": "Default: contextual"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/HooksBeforeExamples"
        }
      },
      "description": "Checks for before/around/after hooks that come after an example."
    },
    "RSpec/IdenticalEqualityAssertion": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/IdenticalEqualityAssertion"
        }
      },
      "description": "Checks for equality assertions with identical expressions on both sides."
    },
    "RSpec/ImplicitBlockExpectation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ImplicitBlockExpectation"
        }
      },
      "description": "Check that implicit block expectation syntax is not used.\n\nPrefer using explicit block expectations."
    },
    "RSpec/ImplicitExpect": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["is_expected", "should"],
          "description": "Default: is_expected"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: is_expected, should"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ImplicitExpect"
        }
      },
      "description": "Check that a consistent implicit expectation style is used.\n\nThis cop can be configured using the `EnforcedStyle` option and supports the `--auto-gen-config` flag."
    },
    "RSpec/ImplicitSubject": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "single_line_only",
            "single_statement_only",
            "disallow",
            "require_implicit"
          ],
          "description": "Default: single_line_only"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: single_line_only, single_statement_only, disallow, require_implicit"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ImplicitSubject"
        }
      },
      "description": "Checks for usage of implicit subject (`is_expected` / `should`).\n\nThis cop can be configured using the `EnforcedStyle` option"
    },
    "RSpec/IncludeExamples": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/IncludeExamples"
        }
      },
      "description": "Checks for usage of `include_examples`.\n\n`include_examples`, unlike `it_behaves_like`, does not create its own context. As such, using `subject`, `let`, `before`/`after`, etc. within shared examples included with `include_examples` can have unexpected behavior and side effects.\n\nPrefer using `it_behaves_like` instead."
    },
    "RSpec/IndexedLet": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Max": {
          "type": "integer",
          "description": "Default: 1"
        },
        "AllowedIdentifiers": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/IndexedLet"
        }
      },
      "description": "Do not set up test data using indexes (e.g., `item_1`, `item_2`).\n\nIt makes reading the test harder because it's not clear what exactly is tested by this particular example.\n\nThe configurable options `AllowedIdentifiers` and `AllowedPatterns` will also read those set in `Naming/VariableNumber`."
    },
    "RSpec/InstanceSpy": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/InstanceSpy"
        }
      },
      "description": "Checks for `instance_double` used with `have_received`."
    },
    "RSpec/InstanceVariable": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AssignmentOnly": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/InstanceVariable"
        }
      },
      "description": "Checks for instance variable usage in specs.\n\nThis cop can be configured with the option `AssignmentOnly` which will configure the cop to only register offenses on instance variable usage if the instance variable is also assigned within the spec"
    },
    "RSpec/IsExpectedSpecify": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/IsExpectedSpecify"
        }
      },
      "description": "Check for `specify` with `is_expected` and one-liner expectations."
    },
    "RSpec/ItBehavesLike": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["it_behaves_like", "it_should_behave_like"],
          "description": "Default: it_behaves_like"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: it_behaves_like, it_should_behave_like"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ItBehavesLike"
        }
      },
      "description": "Checks that only one `it_behaves_like` style is used."
    },
    "RSpec/IteratedExpectation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/IteratedExpectation"
        }
      },
      "description": "Check that `all` matcher is used instead of iterating over an array."
    },
    "RSpec/LeadingSubject": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/LeadingSubject"
        }
      },
      "description": "Enforce that subject is the first definition in the test."
    },
    "RSpec/LeakyConstantDeclaration": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/LeakyConstantDeclaration"
        }
      },
      "description": "Checks that no class, module, or constant is declared.\n\nConstants, including classes and modules, when declared in a block scope, are defined in global namespace, and leak between examples.\n\nIf several examples may define a `DummyClass`, instead of being a blank slate class as it will be in the first example, subsequent examples will be reopening it and modifying its behavior in unpredictable ways. Even worse when a class that exists in the codebase is reopened.\n\nAnonymous classes are fine, since they don't result in global namespace name clashes."
    },
    "RSpec/LetBeforeExamples": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "string",
          "description": "Default: contextual"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/LetBeforeExamples"
        }
      },
      "description": "Checks for `let` definitions that come after an example."
    },
    "RSpec/LetSetup": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/LetSetup"
        }
      },
      "description": "Checks unreferenced `let!` calls being used for test setup."
    },
    "RSpec/MatchArray": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/MatchArray"
        }
      },
      "description": "Checks where `match_array` is used.\n\nThis cop checks for the following:\n\n - Prefer contain_exactly when matching an array with values.\n\n - Prefer eq when using match_array with an empty array literal."
    },
    "RSpec/MessageChain": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/MessageChain"
        }
      },
      "description": "Check that chains of messages are not being stubbed."
    },
    "RSpec/MessageExpectation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["allow", "expect"],
          "description": "Default: allow"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: allow, expect"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/MessageExpectation"
        }
      },
      "description": "Checks for consistent message expectation style.\n\nThis cop can be configured in your configuration using the `EnforcedStyle` option and supports `--auto-gen-config`."
    },
    "RSpec/MessageSpies": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["have_received", "receive"],
          "description": "Default: have_received"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: have_received, receive"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/MessageSpies"
        }
      },
      "description": "Checks that message expectations are set using spies.\n\nThis cop can be configured in your configuration using the `EnforcedStyle` option and supports `--auto-gen-config`."
    },
    "RSpec/MetadataStyle": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["hash", "symbol"],
          "description": "Default: symbol"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: hash, symbol"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/MetadataStyle"
        }
      },
      "description": "Use consistent metadata style.\n\nThis cop does not support autocorrection in the case of `EnforcedStyle: hash` where the trailing metadata type is ambiguous. (e.g. `describe 'Something', :a, b`)"
    },
    "RSpec/MissingExampleGroupArgument": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/MissingExampleGroupArgument"
        }
      },
      "description": "Checks that the first argument to an example group is not empty."
    },
    "RSpec/MissingExpectationTargetMethod": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/MissingExpectationTargetMethod"
        }
      },
      "description": "Checks if `.to`, `not_to` or `to_not` are used.\n\nThe RSpec::Expectations::ExpectationTarget must use `to`, `not_to` or `to_not` to run. Therefore, this cop checks if other methods are used."
    },
    "RSpec/MultipleDescribes": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/MultipleDescribes"
        }
      },
      "description": "Checks for multiple top-level example groups.\n\nMultiple descriptions for the same class or module should either be nested or separated into different test files."
    },
    "RSpec/MultipleExpectations": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Max": {
          "type": "integer",
          "description": "Default: 1"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/MultipleExpectations"
        }
      },
      "description": "Checks if examples contain too many `expect` calls.\n\nThis cop is configurable using the `Max` option and works with `--auto-gen-config`."
    },
    "RSpec/MultipleMemoizedHelpers": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowSubject": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Max": {
          "type": "integer",
          "description": "Default: 5"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/MultipleMemoizedHelpers"
        }
      },
      "description": "Checks if example groups contain too many `let` and `subject` calls.\n\nThis cop is configurable using the `Max` option and the `AllowSubject` which will configure the cop to only register offenses on calls to `let` and not calls to `subject`."
    },
    "RSpec/MultipleSubjects": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/MultipleSubjects"
        }
      },
      "description": "Checks if an example group defines `subject` multiple times.\n\nThis cop does not support autocorrection in some cases. The autocorrect behavior for this cop depends on the type of duplication:\n\n - If multiple named subjects are defined then this probably indicates that the overwritten subjects (all subjects except the last definition) are effectively being used to define helpers. In this case they are replaced with let.\n\n - If multiple unnamed subjects are defined though then this can only be dead code and we remove the overwritten subject definitions.\n\n - If subjects are defined with subject! then we don’t autocorrect. This is enough of an edge case that people can just move this to a before hook on their own"
    },
    "RSpec/NamedSubject": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["always", "named_only"],
          "description": "Default: always"
        },
        "IgnoreSharedExamples": {
          "type": "boolean",
          "description": "Default: true"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: always, named_only"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/NamedSubject"
        }
      },
      "description": "Checks for explicitly referenced test subjects.\n\nRSpec lets you declare an \"implicit subject\" using `subject { ... }` which allows for tests like `it { is_expected.to be_valid }`. If you need to reference your test subject you should explicitly name it using `subject(:your_subject_name) { ... }`. Your test subjects should be the most important object in your tests so they deserve a descriptive name.\n\nThis cop can be configured in your configuration using `EnforcedStyle`, and `IgnoreSharedExamples` which will not report offenses for implicit subjects in shared example groups."
    },
    "RSpec/NestedGroups": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Max": {
          "type": "integer",
          "description": "Default: 3"
        },
        "AllowedGroups": {
          "type": "array",
          "description": "Default: []"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/NestedGroups"
        }
      },
      "description": "Checks for nested example groups.\n\nThis cop is configurable using the `Max` option and supports `--auto-gen-config`."
    },
    "RSpec/NoExpectationExample": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: ^expect_, ^assert_"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/NoExpectationExample"
        }
      },
      "description": "Checks if an example contains any expectation.\n\nAll RSpec's example and expectation methods are covered by default. If you are using your own custom methods, add the following configuration:\n\n  RSpec:\n    Language:\n      Examples:\n        Regular:\n          - custom_it\n      Expectations:\n        - custom_expect\n\nThis cop can be customized with an allowed expectation methods pattern with an `AllowedPatterns` option. ^expect_ and ^assert_ are allowed by default."
    },
    "RSpec/NotToNot": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["not_to", "to_not"],
          "description": "Default: not_to"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: not_to, to_not"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/NotToNot"
        }
      },
      "description": "Checks for consistent method usage for negating expectations."
    },
    "RSpec/OverwritingSetup": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/OverwritingSetup"
        }
      },
      "description": "Checks if there is a let/subject that overwrites an existing one."
    },
    "RSpec/Pending": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/Pending"
        }
      },
      "description": "Checks for any pending or skipped examples."
    },
    "RSpec/PendingWithoutReason": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/PendingWithoutReason"
        }
      },
      "description": "Checks for pending or skipped examples without reason."
    },
    "RSpec/PredicateMatcher": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Strict": {
          "type": "boolean",
          "description": "Default: true"
        },
        "EnforcedStyle": {
          "enum": ["inflected", "explicit"],
          "description": "Default: inflected"
        },
        "AllowedExplicitMatchers": {
          "type": "array",
          "description": "Default: []"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: inflected, explicit"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/PredicateMatcher"
        }
      },
      "description": "Prefer using predicate matcher over using predicate method directly.\n\nRSpec defines magic matchers for predicate methods. This cop recommends to use the predicate matcher instead of using predicate method directly."
    },
    "RSpec/ReceiveCounts": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ReceiveCounts"
        }
      },
      "description": "Check for `once` and `twice` receive counts matchers usage."
    },
    "RSpec/ReceiveMessages": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ReceiveMessages"
        }
      },
      "description": "Checks for multiple messages stubbed on the same object."
    },
    "RSpec/ReceiveNever": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ReceiveNever"
        }
      },
      "description": "Prefer `not_to receive(...)` over `receive(...).never`."
    },
    "RSpec/RedundantAround": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/RedundantAround"
        }
      },
      "description": "Remove redundant `around` hook."
    },
    "RSpec/RedundantPredicateMatcher": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/RedundantPredicateMatcher"
        }
      },
      "description": "Checks for redundant predicate matcher."
    },
    "RSpec/RemoveConst": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/RemoveConst"
        }
      },
      "description": "Checks that `remove_const` is not used in specs."
    },
    "RSpec/RepeatedDescription": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/RepeatedDescription"
        }
      },
      "description": "Check for repeated description strings in example groups."
    },
    "RSpec/RepeatedExample": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/RepeatedExample"
        }
      },
      "description": "Check for repeated examples within example groups."
    },
    "RSpec/RepeatedExampleGroupBody": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/RepeatedExampleGroupBody"
        }
      },
      "description": "Check for repeated describe and context block body."
    },
    "RSpec/RepeatedExampleGroupDescription": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/RepeatedExampleGroupDescription"
        }
      },
      "description": "Check for repeated example group descriptions."
    },
    "RSpec/RepeatedIncludeExample": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/RepeatedIncludeExample"
        }
      },
      "description": "Check for repeated include of shared examples."
    },
    "RSpec/RepeatedSubjectCall": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/RepeatedSubjectCall"
        }
      },
      "description": "Checks for repeated calls to subject missing that it is memoized."
    },
    "RSpec/ReturnFromStub": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["and_return", "block"],
          "description": "Default: and_return"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: and_return, block"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ReturnFromStub"
        }
      },
      "description": "Checks for consistent style of stub's return setting.\n\nEnforces either `and_return` or block-style return in the cases where the returned value is constant. Ignores dynamic returned values are the result would be different\n\nThis cop can be configured using the `EnforcedStyle` option"
    },
    "RSpec/ScatteredLet": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "string",
          "description": "Default: contextual"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ScatteredLet"
        }
      },
      "description": "Checks for let scattered across the example group.\n\nGroup lets together"
    },
    "RSpec/ScatteredSetup": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "string",
          "description": "Default: contextual"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ScatteredSetup"
        }
      },
      "description": "Checks for setup scattered across multiple hooks in an example group.\n\nUnify `before` and `after` hooks when possible. However, `around` hooks are allowed to be defined multiple times, as unifying them would typically make the code harder to read."
    },
    "RSpec/SharedContext": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/SharedContext"
        }
      },
      "description": "Checks for proper shared_context and shared_examples usage.\n\nIf there are no examples defined, use shared_context. If there is no setup defined, use shared_examples."
    },
    "RSpec/SharedExamples": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["string", "symbol"],
          "description": "Default: string"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: string, symbol"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/SharedExamples"
        }
      },
      "description": "Checks for consistent style for shared example names.\n\nEnforces either `string` or `symbol` for shared example names.\n\nThis cop can be configured using the `EnforcedStyle` option"
    },
    "RSpec/SingleArgumentMessageChain": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/SingleArgumentMessageChain"
        }
      },
      "description": "Checks that chains of messages contain more than one element."
    },
    "RSpec/SkipBlockInsideExample": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/SkipBlockInsideExample"
        }
      },
      "description": "Checks for passing a block to `skip` within examples."
    },
    "RSpec/SortMetadata": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/SortMetadata"
        }
      },
      "description": "Sort RSpec metadata alphabetically.\n\nOnly the trailing metadata is sorted."
    },
    "RSpec/SpecFilePathFormat": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/spec/routing/**/*"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*_spec.rb"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "CustomTransform": {
          "description": "Default: {\"RuboCop\" ⇒ \"rubocop\", \"RSpec\" ⇒ \"rspec\"}"
        },
        "IgnoreMethods": {
          "type": "boolean",
          "description": "Default: false"
        },
        "IgnoreMetadata": {
          "description": "Default: {\"type\" ⇒ \"routing\"}"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/SpecFilePathFormat"
        }
      },
      "description": "Checks that spec file paths are consistent and well-formed."
    },
    "RSpec/SpecFilePathSuffix": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*_spec*rb*, **/spec/**/*"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/SpecFilePathSuffix"
        }
      },
      "description": "Checks that spec file paths suffix are consistent and well-formed."
    },
    "RSpec/StubbedMock": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/StubbedMock"
        }
      },
      "description": "Checks that message expectations do not have a configured response."
    },
    "RSpec/SubjectDeclaration": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/SubjectDeclaration"
        }
      },
      "description": "Ensure that subject is defined using subject helper."
    },
    "RSpec/SubjectStub": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/SubjectStub"
        }
      },
      "description": "Checks for stubbed test subjects.\n\nChecks nested subject stubs for innermost subject definition when subject is also defined in parent example groups."
    },
    "RSpec/UndescriptiveLiteralsDescription": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/UndescriptiveLiteralsDescription"
        }
      },
      "description": "Description should be descriptive.\n\nIf example group or example contains only `execute string`, numbers and regular expressions, the description is not clear."
    },
    "RSpec/UnspecifiedException": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/UnspecifiedException"
        }
      },
      "description": "Checks for a specified error in checking raised errors.\n\nEnforces one of an Exception type, a string, or a regular expression to match against the exception message as a parameter to `raise_error`"
    },
    "RSpec/VariableDefinition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["symbols", "strings"],
          "description": "Default: symbols"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: symbols, strings"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/VariableDefinition"
        }
      },
      "description": "Checks that memoized helpers names are symbols or strings."
    },
    "RSpec/VariableName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": ["snake_case", "camelCase"],
          "description": "Default: snake_case"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: snake_case, camelCase"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/VariableName"
        }
      },
      "description": "Checks that memoized helper names use the configured style.\n\nVariables can be excluded from checking using the `AllowedPatterns` option."
    },
    "RSpec/VerifiedDoubleReference": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/VerifiedDoubleReference"
        }
      },
      "description": "Checks for consistent verified double reference style."
    },
    "RSpec/VerifiedDoubles": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "IgnoreNameless": {
          "type": "boolean",
          "description": "Default: true"
        },
        "IgnoreSymbolicNames": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/VerifiedDoubles"
        }
      },
      "description": "Prefer using verifying doubles over normal doubles."
    },
    "RSpec/VoidExpect": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/VoidExpect"
        }
      },
      "description": "Checks void `expect()`."
    },
    "RSpec/Yield": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/Yield"
        }
      },
      "description": "Checks for calling a block within a stub."
    },
    "Sorbet/AllowIncompatibleOverride": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Disallows using `.override(allow_incompatible: true)`."
    },
    "Sorbet/BindingConstantWithoutTypeAlias": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Disallows binding the return value of `T.any`, `T.all`, `T.enum` to a constant directly. To bind the value, one must use `T.type_alias`."
    },
    "Sorbet/BlockMethodDefinition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: true"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Disallows defining methods inside blocks without using `define_method`, unless the block is a named class definition. This is to avoid running into https://github.com/sorbet/sorbet/issues/3609."
    },
    "Sorbet/BuggyObsoleteStrictMemoization": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: true"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for the a mistaken variant of the \"obsolete memoization pattern\" that used to be required for older Sorbet versions in `#typed: strict` files. The mistaken variant would overwrite the ivar with `nil` on every call, causing the memoized value to be discarded and recomputed on every call.\nThis cop will correct it to read from the ivar instead of `nil`, which will memoize it correctly.\nThe result of this correction will be the \"obsolete memoization pattern\", which can further be corrected by the `Sorbet/ObsoleteStrictMemoization` cop.\nSee `Sorbet/ObsoleteStrictMemoization` for more details."
    },
    "Sorbet/CallbackConditionalsBinding": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Ensures callback conditionals are bound to the right type."
    },
    "Sorbet/CheckedTrueInSignature": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Disallows the usage of `checked(true)` in signatures."
    },
    "Sorbet/ConstantsFromStrings": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Forbids constant access through meta-programming.\nFor example, things like `constantize` or `const_get` are forbidden."
    },
    "Sorbet/EmptyLineAfterSig": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Ensures that there are no blank lines after signatures"
    },
    "Sorbet/EnforceSigilOrder": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Ensures that Sorbet sigil comes first in a file."
    },
    "Sorbet/EnforceSignatures": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowRBS": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Ensures all methods have a valid signature."
    },
    "Sorbet/EnforceSingleSigil": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Ensures that there is only one Sorbet sigil in a file."
    },
    "Sorbet/FalseSigil": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: bin/**/*, db/**/*.rb, script/**/*"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.{rb,rbi,rake,ru}"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SuggestedStrictness": {
          "type": "string",
          "description": "Default: false"
        }
      },
      "description": "All files must be at least at strictness `false`."
    },
    "Sorbet/ForbidComparableTEnum": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Disallows including the `Comparable` module in a `T::Enum`."
    },
    "Sorbet/ForbidExtendTSigHelpersInShims": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.rbi"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Forbid the use of `extend T::Sig` and `extend T::Helpers` in RBI shims"
    },
    "Sorbet/ForbidIncludeConstLiteral": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Forbids include of non-literal constants."
    },
    "Sorbet/ForbidMixesInClassMethods": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Disallows the usage of `mixes_in_class_methods` in favor of `extend ActiveSupport::Concern`."
    },
    "Sorbet/ForbidRBIOutsideOfAllowedPaths": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.rbi"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedPaths": {
          "type": "array",
          "description": "Default: rbi/**, sorbet/rbi/**"
        }
      },
      "description": "Forbids RBI files outside of the allowed paths"
    },
    "Sorbet/ForbidSig": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Forbid usage of sig"
    },
    "Sorbet/ForbidSigWithRuntime": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Forbid usage of T::Sig.sig"
    },
    "Sorbet/ForbidSigWithoutRuntime": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Forbid usage of T::Sig::WithoutRuntime.sig"
    },
    "Sorbet/ForbidSuperclassConstLiteral": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: db/migrate/*.rb"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Forbid superclasses which are non-literal constants."
    },
    "Sorbet/ForbidTEnum": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Forbid usage of T::Enum."
    },
    "Sorbet/ForbidTStruct": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Forbid usage of T::Struct."
    },
    "Sorbet/ForbidTUnsafe": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Forbid usage of T.unsafe."
    },
    "Sorbet/ForbidTUntyped": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Forbid usage of T.untyped"
    },
    "Sorbet/ForbidTypeAliasedShapes": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Forbids defining type aliases that contain shapes"
    },
    "Sorbet/ForbidUntypedStructProps": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Disallows use of `T.untyped` or `T.nilable(T.untyped)` as a prop type for `T::Struct` subclasses."
    },
    "Sorbet/HasSigil": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: bin/**/*, db/**/*.rb, script/**/*"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.{rb,rbi,rake,ru}"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SuggestedStrictness": {
          "type": "string",
          "description": "Default: false"
        },
        "MinimumStrictness": {
          "type": "string",
          "description": "Default: nil"
        },
        "ExactStrictness": {
          "type": "string",
          "description": "Default: nil"
        }
      },
      "description": "Makes the Sorbet typed sigil mandatory in all files."
    },
    "Sorbet/IgnoreSigil": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: bin/**/*, db/**/*.rb, script/**/*"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.{rb,rbi,rake,ru}"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SuggestedStrictness": {
          "type": "string",
          "description": "Default: ignore"
        }
      },
      "description": "All files must be at least at strictness `ignore`."
    },
    "Sorbet/ImplicitConversionMethod": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "This cop disallows declaring implicit conversion methods, as sorbet does not support implicit conversion."
    },
    "Sorbet/KeywordArgumentOrdering": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Enforces a compatible keyword arguments with Sorbet.\nAll keyword arguments must be at the end of the parameters list, and all keyword arguments with a default value must be after those without default values."
    },
    "Sorbet/MultipleTEnumValues": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Ensures that all `T::Enum`s have multiple values."
    },
    "Sorbet/ObsoleteStrictMemoization": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: true"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "This cop checks for the obsolete pattern for initializing instance variables that was required for older Sorbet versions in `#typed: strict` files.\nIt's no longer required, as of Sorbet 0.5.10210 See https://sorbet.org/docs/type-assertions#put-type-assertions-behind-memoization"
    },
    "Sorbet/RedundantExtendTSig": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Forbid the usage of redundant `extend T::Sig`.\nOnly for use in applications that monkey patch `Module.include(T::Sig)` directly, where it is useful to reduce noise."
    },
    "Sorbet/Refinement": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for the use of Ruby Refinements library. Refinements add complexity and incur a performance penalty that can be significant for large code bases. They are also not supported by Sorbet."
    },
    "Sorbet/SelectByIsA": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: true"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "Suggests using `grep` over `select` when using it only for type narrowing. This is because Sorbet can properly infer types when using `grep` but not with `select`."
    },
    "Sorbet/SignatureBuildOrder": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Order": {
          "type": "array",
          "description": "Default: final, abstract, implementation, override, overridable, type_parameters, params, bind, returns, void, soft, checked, on_failure"
        }
      },
      "description": "Enforces the order of parts in a signature.\nThe order is first inheritance related builders, then params, then return and finally the modifier such as: `abstract.params(...).returns(...).soft`.'"
    },
    "Sorbet/SingleLineRbiClassModuleDefinitions": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.rbi"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Empty class and module definitions in RBI must be on a single line."
    },
    "Sorbet/StrictSigil": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: bin/**/*, db/**/*.rb, script/**/*"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.{rb,rbi,rake,ru}"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SuggestedStrictness": {
          "type": "string",
          "description": "Default: strict"
        }
      },
      "description": "All files must be at least at strictness `strict`."
    },
    "Sorbet/StrongSigil": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: bin/**/*, db/**/*.rb, script/**/*"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.{rb,rbi,rake,ru}"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SuggestedStrictness": {
          "type": "string",
          "description": "Default: strong"
        }
      },
      "description": "All files must be at least at strictness `strong`."
    },
    "Sorbet/TrueSigil": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: bin/**/*, db/**/*.rb, script/**/*"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.{rb,rbi,rake,ru}"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SuggestedStrictness": {
          "type": "string",
          "description": "Default: true"
        }
      },
      "description": "All files must be at least at strictness `true`."
    },
    "Sorbet/TypeAliasName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: bin/**/*, db/**/*.rb, script/**/*"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.{rb,rbi,rake,ru}"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Type alias constant names must be in CamelCase."
    },
    "Sorbet/ValidSigil": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: bin/**/*, db/**/*.rb, script/**/*"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.{rb,rbi,rake,ru}"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "RequireSigilOnAllFiles": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SuggestedStrictness": {
          "type": "string",
          "description": "Default: false"
        },
        "MinimumStrictness": {
          "type": "string",
          "description": "Default: nil"
        },
        "ExactStrictness": {
          "type": "string",
          "description": "Default: nil"
        }
      },
      "description": "All files must have a valid sigil."
    },
    "Sorbet/VoidCheckedTests": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Forbid `.void.checked(:tests)`"
    },
    "plugins": {
      "$ref": "#/definitions/stringOrStrings"
    }
  }
}
