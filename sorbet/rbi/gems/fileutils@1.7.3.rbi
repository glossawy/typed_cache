# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `fileutils` gem.
# Please instead update this file by running `bin/tapioca gem fileutils`.


# Namespace for file utility methods for copying, moving, removing, etc.
#
# == What's Here
#
# First, whatâ€™s elsewhere. \Module \FileUtils:
#
# - Inherits from {class Object}[https://docs.ruby-lang.org/en/master/Object.html].
# - Supplements {class File}[https://docs.ruby-lang.org/en/master/File.html]
#   (but is not included or extended there).
#
# Here, module \FileUtils provides methods that are useful for:
#
# - {Creating}[rdoc-ref:FileUtils@Creating].
# - {Deleting}[rdoc-ref:FileUtils@Deleting].
# - {Querying}[rdoc-ref:FileUtils@Querying].
# - {Setting}[rdoc-ref:FileUtils@Setting].
# - {Comparing}[rdoc-ref:FileUtils@Comparing].
# - {Copying}[rdoc-ref:FileUtils@Copying].
# - {Moving}[rdoc-ref:FileUtils@Moving].
# - {Options}[rdoc-ref:FileUtils@Options].
#
# === Creating
#
# - ::mkdir: Creates directories.
# - ::mkdir_p, ::makedirs, ::mkpath: Creates directories,
#   also creating ancestor directories as needed.
# - ::link_entry: Creates a hard link.
# - ::ln, ::link: Creates hard links.
# - ::ln_s, ::symlink: Creates symbolic links.
# - ::ln_sf: Creates symbolic links, overwriting if necessary.
# - ::ln_sr: Creates symbolic links relative to targets
#
# === Deleting
#
# - ::remove_dir: Removes a directory and its descendants.
# - ::remove_entry: Removes an entry, including its descendants if it is a directory.
# - ::remove_entry_secure: Like ::remove_entry, but removes securely.
# - ::remove_file: Removes a file entry.
# - ::rm, ::remove: Removes entries.
# - ::rm_f, ::safe_unlink: Like ::rm, but removes forcibly.
# - ::rm_r: Removes entries and their descendants.
# - ::rm_rf, ::rmtree: Like ::rm_r, but removes forcibly.
# - ::rmdir: Removes directories.
#
# === Querying
#
# - ::pwd, ::getwd: Returns the path to the working directory.
# - ::uptodate?: Returns whether a given entry is newer than given other entries.
#
# === Setting
#
# - ::cd, ::chdir: Sets the working directory.
# - ::chmod: Sets permissions for an entry.
# - ::chmod_R: Sets permissions for an entry and its descendants.
# - ::chown: Sets the owner and group for entries.
# - ::chown_R: Sets the owner and group for entries and their descendants.
# - ::touch: Sets modification and access times for entries,
#   creating if necessary.
#
# === Comparing
#
# - ::compare_file, ::cmp, ::identical?: Returns whether two entries are identical.
# - ::compare_stream: Returns whether two streams are identical.
#
# === Copying
#
# - ::copy_entry: Recursively copies an entry.
# - ::copy_file: Copies an entry.
# - ::copy_stream: Copies a stream.
# - ::cp, ::copy: Copies files.
# - ::cp_lr: Recursively creates hard links.
# - ::cp_r: Recursively copies files, retaining mode, owner, and group.
# - ::install: Recursively copies files, optionally setting mode,
#   owner, and group.
#
# === Moving
#
# - ::mv, ::move: Moves entries.
#
# === Options
#
# - ::collect_method: Returns the names of methods that accept a given option.
# - ::commands: Returns the names of methods that accept options.
# - ::have_option?: Returns whether a given method accepts a given option.
# - ::options: Returns all option names.
# - ::options_of: Returns the names of the options for a given method.
#
# == Path Arguments
#
# Some methods in \FileUtils accept _path_ arguments,
# which are interpreted as paths to filesystem entries:
#
# - If the argument is a string, that value is the path.
# - If the argument has method +:to_path+, it is converted via that method.
# - If the argument has method +:to_str+, it is converted via that method.
#
# == About the Examples
#
# Some examples here involve trees of file entries.
# For these, we sometimes display trees using the
# {tree command-line utility}[https://en.wikipedia.org/wiki/Tree_(command)],
# which is a recursive directory-listing utility that produces
# a depth-indented listing of files and directories.
#
# We use a helper method to launch the command and control the format:
#
#   def tree(dirpath = '.')
#     command = "tree --noreport --charset=ascii #{dirpath}"
#     system(command)
#   end
#
# To illustrate:
#
#   tree('src0')
#   # => src0
#   #    |-- sub0
#   #    |   |-- src0.txt
#   #    |   `-- src1.txt
#   #    `-- sub1
#   #        |-- src2.txt
#   #        `-- src3.txt
#
# == Avoiding the TOCTTOU Vulnerability
#
# For certain methods that recursively remove entries,
# there is a potential vulnerability called the
# {Time-of-check to time-of-use}[https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use],
# or TOCTTOU, vulnerability that can exist when:
#
# - An ancestor directory of the entry at the target path is world writable;
#   such directories include <tt>/tmp</tt>.
# - The directory tree at the target path includes:
#
#   - A world-writable descendant directory.
#   - A symbolic link.
#
# To avoid that vulnerability, you can use this method to remove entries:
#
# - FileUtils.remove_entry_secure: removes recursively
#   if the target path points to a directory.
#
# Also available are these methods,
# each of which calls \FileUtils.remove_entry_secure:
#
# - FileUtils.rm_r with keyword argument <tt>secure: true</tt>.
# - FileUtils.rm_rf with keyword argument <tt>secure: true</tt>.
#
# Finally, this method for moving entries calls \FileUtils.remove_entry_secure
# if the source and destination are on different file systems
# (which means that the "move" is really a copy and remove):
#
# - FileUtils.mv with keyword argument <tt>secure: true</tt>.
#
# \Method \FileUtils.remove_entry_secure removes securely
# by applying a special pre-process:
#
# - If the target path points to a directory, this method uses methods
#   {File#chown}[https://docs.ruby-lang.org/en/master/File.html#method-i-chown]
#   and {File#chmod}[https://docs.ruby-lang.org/en/master/File.html#method-i-chmod]
#   in removing directories.
# - The owner of the target directory should be either the current process
#   or the super user (root).
#
# WARNING: You must ensure that *ALL* parent directories cannot be
# moved by other untrusted users.  For example, parent directories
# should not be owned by untrusted users, and should not be world
# writable except when the sticky bit is set.
#
# For details of this security vulnerability, see Perl cases:
#
# - {CVE-2005-0448}[https://cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2005-0448].
# - {CVE-2004-0452}[https://cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2004-0452].
#
# source://fileutils//lib/fileutils.rb#182
module FileUtils
  include ::FileUtils::StreamUtils_
  extend ::FileUtils::StreamUtils_

  private

  # source://fileutils//lib/fileutils.rb#1661
  def apply_mask(mode, user_mask, op, mode_mask); end

  # Changes the working directory to the given +dir+, which
  # should be {interpretable as a path}[rdoc-ref:FileUtils@Path+Arguments]:
  #
  # With no block given,
  # changes the current directory to the directory at +dir+; returns zero:
  #
  #   FileUtils.pwd # => "/rdoc/fileutils"
  #   FileUtils.cd('..')
  #   FileUtils.pwd # => "/rdoc"
  #   FileUtils.cd('fileutils')
  #
  # With a block given, changes the current directory to the directory
  # at +dir+, calls the block with argument +dir+,
  # and restores the original current directory; returns the block's value:
  #
  #   FileUtils.pwd                                     # => "/rdoc/fileutils"
  #   FileUtils.cd('..') { |arg| [arg, FileUtils.pwd] } # => ["..", "/rdoc"]
  #   FileUtils.pwd                                     # => "/rdoc/fileutils"
  #
  # Keyword arguments:
  #
  # - <tt>verbose: true</tt> - prints an equivalent command:
  #
  #     FileUtils.cd('..')
  #     FileUtils.cd('fileutils')
  #
  #   Output:
  #
  #     cd ..
  #     cd fileutils
  #
  # Related: FileUtils.pwd.
  #
  # source://fileutils//lib/fileutils.rb#239
  def cd(dir, verbose: T.unsafe(nil), &block); end

  # Changes the working directory to the given +dir+, which
  # should be {interpretable as a path}[rdoc-ref:FileUtils@Path+Arguments]:
  #
  # With no block given,
  # changes the current directory to the directory at +dir+; returns zero:
  #
  #   FileUtils.pwd # => "/rdoc/fileutils"
  #   FileUtils.cd('..')
  #   FileUtils.pwd # => "/rdoc"
  #   FileUtils.cd('fileutils')
  #
  # With a block given, changes the current directory to the directory
  # at +dir+, calls the block with argument +dir+,
  # and restores the original current directory; returns the block's value:
  #
  #   FileUtils.pwd                                     # => "/rdoc/fileutils"
  #   FileUtils.cd('..') { |arg| [arg, FileUtils.pwd] } # => ["..", "/rdoc"]
  #   FileUtils.pwd                                     # => "/rdoc/fileutils"
  #
  # Keyword arguments:
  #
  # - <tt>verbose: true</tt> - prints an equivalent command:
  #
  #     FileUtils.cd('..')
  #     FileUtils.cd('fileutils')
  #
  #   Output:
  #
  #     cd ..
  #     cd fileutils
  #
  # Related: FileUtils.pwd.
  #
  # source://fileutils//lib/fileutils.rb#239
  def chdir(dir, verbose: T.unsafe(nil), &block); end

  # Changes permissions on the entries at the paths given in +list+
  # (a single path or an array of paths)
  # to the permissions given by +mode+;
  # returns +list+ if it is an array, <tt>[list]</tt> otherwise:
  #
  # - Modifies each entry that is a regular file using
  #   {File.chmod}[https://docs.ruby-lang.org/en/master/File.html#method-c-chmod].
  # - Modifies each entry that is a symbolic link using
  #   {File.lchmod}[https://docs.ruby-lang.org/en/master/File.html#method-c-lchmod].
  #
  # Argument +list+ or its elements
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # Argument +mode+ may be either an integer or a string:
  #
  # - \Integer +mode+: represents the permission bits to be set:
  #
  #     FileUtils.chmod(0755, 'src0.txt')
  #     FileUtils.chmod(0644, ['src0.txt', 'src0.dat'])
  #
  # - \String +mode+: represents the permissions to be set:
  #
  #   The string is of the form <tt>[targets][[operator][perms[,perms]]</tt>, where:
  #
  #   - +targets+ may be any combination of these letters:
  #
  #     - <tt>'u'</tt>: permissions apply to the file's owner.
  #     - <tt>'g'</tt>: permissions apply to users in the file's group.
  #     - <tt>'o'</tt>: permissions apply to other users not in the file's group.
  #     - <tt>'a'</tt> (the default): permissions apply to all users.
  #
  #   - +operator+ may be one of these letters:
  #
  #     - <tt>'+'</tt>: adds permissions.
  #     - <tt>'-'</tt>: removes permissions.
  #     - <tt>'='</tt>: sets (replaces) permissions.
  #
  #   - +perms+ (may be repeated, with separating commas)
  #     may be any combination of these letters:
  #
  #     - <tt>'r'</tt>: Read.
  #     - <tt>'w'</tt>: Write.
  #     - <tt>'x'</tt>: Execute (search, for a directory).
  #     - <tt>'X'</tt>: Search (for a directories only;
  #       must be used with <tt>'+'</tt>)
  #     - <tt>'s'</tt>: Uid or gid.
  #     - <tt>'t'</tt>: Sticky bit.
  #
  #   Examples:
  #
  #     FileUtils.chmod('u=wrx,go=rx', 'src1.txt')
  #     FileUtils.chmod('u=wrx,go=rx', '/usr/bin/ruby')
  #
  # Keyword arguments:
  #
  # - <tt>noop: true</tt> - does not change permissions; returns +nil+.
  # - <tt>verbose: true</tt> - prints an equivalent command:
  #
  #     FileUtils.chmod(0755, 'src0.txt', noop: true, verbose: true)
  #     FileUtils.chmod(0644, ['src0.txt', 'src0.dat'], noop: true, verbose: true)
  #     FileUtils.chmod('u=wrx,go=rx', 'src1.txt', noop: true, verbose: true)
  #     FileUtils.chmod('u=wrx,go=rx', '/usr/bin/ruby', noop: true, verbose: true)
  #
  #   Output:
  #
  #     chmod 755 src0.txt
  #     chmod 644 src0.txt src0.dat
  #     chmod u=wrx,go=rx src1.txt
  #     chmod u=wrx,go=rx /usr/bin/ruby
  #
  # Related: FileUtils.chmod_R.
  #
  # source://fileutils//lib/fileutils.rb#1804
  def chmod(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  # Like FileUtils.chmod, but changes permissions recursively.
  #
  # source://fileutils//lib/fileutils.rb#1816
  def chmod_R(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end

  # Changes the owner and group on the entries at the paths given in +list+
  # (a single path or an array of paths)
  # to the given +user+ and +group+;
  # returns +list+ if it is an array, <tt>[list]</tt> otherwise:
  #
  # - Modifies each entry that is a regular file using
  #   {File.chown}[https://docs.ruby-lang.org/en/master/File.html#method-c-chown].
  # - Modifies each entry that is a symbolic link using
  #   {File.lchown}[https://docs.ruby-lang.org/en/master/File.html#method-c-lchown].
  #
  # Argument +list+ or its elements
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # User and group:
  #
  # - Argument +user+ may be a user name or a user id;
  #   if +nil+ or +-1+, the user is not changed.
  # - Argument +group+ may be a group name or a group id;
  #   if +nil+ or +-1+, the group is not changed.
  # - The user must be a member of the group.
  #
  # Examples:
  #
  #   # One path.
  #   # User and group as string names.
  #   File.stat('src0.txt').uid # => 1004
  #   File.stat('src0.txt').gid # => 1004
  #   FileUtils.chown('user2', 'group1', 'src0.txt')
  #   File.stat('src0.txt').uid # => 1006
  #   File.stat('src0.txt').gid # => 1005
  #
  #   # User and group as uid and gid.
  #   FileUtils.chown(1004, 1004, 'src0.txt')
  #   File.stat('src0.txt').uid # => 1004
  #   File.stat('src0.txt').gid # => 1004
  #
  #   # Array of paths.
  #   FileUtils.chown(1006, 1005, ['src0.txt', 'src0.dat'])
  #
  #   # Directory (not recursive).
  #   FileUtils.chown('user2', 'group1', '.')
  #
  # Keyword arguments:
  #
  # - <tt>noop: true</tt> - does not change permissions; returns +nil+.
  # - <tt>verbose: true</tt> - prints an equivalent command:
  #
  #     FileUtils.chown('user2', 'group1', 'src0.txt', noop: true, verbose: true)
  #     FileUtils.chown(1004, 1004, 'src0.txt', noop: true, verbose: true)
  #     FileUtils.chown(1006, 1005, ['src0.txt', 'src0.dat'], noop: true, verbose: true)
  #     FileUtils.chown('user2', 'group1', path, noop: true, verbose: true)
  #     FileUtils.chown('user2', 'group1', '.', noop: true, verbose: true)
  #
  #   Output:
  #
  #     chown user2:group1 src0.txt
  #     chown 1004:1004 src0.txt
  #     chown 1006:1005 src0.txt src0.dat
  #     chown user2:group1 src0.txt
  #     chown user2:group1 .
  #
  # Related: FileUtils.chown_R.
  #
  # source://fileutils//lib/fileutils.rb#1897
  def chown(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  # Like FileUtils.chown, but changes owner and group recursively.
  #
  # source://fileutils//lib/fileutils.rb#1913
  def chown_R(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end

  # Returns +true+ if the contents of files +a+ and +b+ are identical,
  # +false+ otherwise.
  #
  # Arguments +a+ and +b+
  # should be {interpretable as a path}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # FileUtils.identical? and FileUtils.cmp are aliases for FileUtils.compare_file.
  #
  # Related: FileUtils.compare_stream.
  #
  # source://fileutils//lib/fileutils.rb#1508
  def cmp(a, b); end

  # Returns +true+ if the contents of files +a+ and +b+ are identical,
  # +false+ otherwise.
  #
  # Arguments +a+ and +b+
  # should be {interpretable as a path}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # FileUtils.identical? and FileUtils.cmp are aliases for FileUtils.compare_file.
  #
  # Related: FileUtils.compare_stream.
  #
  # source://fileutils//lib/fileutils.rb#1508
  def compare_file(a, b); end

  # Returns +true+ if the contents of streams +a+ and +b+ are identical,
  # +false+ otherwise.
  #
  # Arguments +a+ and +b+
  # should be {interpretable as a path}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # Related: FileUtils.compare_file.
  #
  # source://fileutils//lib/fileutils.rb#1531
  def compare_stream(a, b); end

  # Copies files.
  #
  # Arguments +src+ (a single path or an array of paths)
  # and +dest+ (a single path)
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # If +src+ is the path to a file and +dest+ is not the path to a directory,
  # copies +src+ to +dest+:
  #
  #   FileUtils.touch('src0.txt')
  #   File.exist?('dest0.txt') # => false
  #   FileUtils.cp('src0.txt', 'dest0.txt')
  #   File.file?('dest0.txt')  # => true
  #
  # If +src+ is the path to a file and +dest+ is the path to a directory,
  # copies +src+ to <tt>dest/src</tt>:
  #
  #   FileUtils.touch('src1.txt')
  #   FileUtils.mkdir('dest1')
  #   FileUtils.cp('src1.txt', 'dest1')
  #   File.file?('dest1/src1.txt') # => true
  #
  # If +src+ is an array of paths to files and +dest+ is the path to a directory,
  # copies from each +src+ to +dest+:
  #
  #   src_file_paths = ['src2.txt', 'src2.dat']
  #   FileUtils.touch(src_file_paths)
  #   FileUtils.mkdir('dest2')
  #   FileUtils.cp(src_file_paths, 'dest2')
  #   File.file?('dest2/src2.txt') # => true
  #   File.file?('dest2/src2.dat') # => true
  #
  # Keyword arguments:
  #
  # - <tt>preserve: true</tt> - preserves file times.
  # - <tt>noop: true</tt> - does not copy files.
  # - <tt>verbose: true</tt> - prints an equivalent command:
  #
  #     FileUtils.cp('src0.txt', 'dest0.txt', noop: true, verbose: true)
  #     FileUtils.cp('src1.txt', 'dest1', noop: true, verbose: true)
  #     FileUtils.cp(src_file_paths, 'dest2', noop: true, verbose: true)
  #
  #   Output:
  #
  #     cp src0.txt dest0.txt
  #     cp src1.txt dest1
  #     cp src2.txt src2.dat dest2
  #
  # Raises an exception if +src+ is a directory.
  #
  # Related: {methods for copying}[rdoc-ref:FileUtils@Copying].
  #
  # source://fileutils//lib/fileutils.rb#874
  def copy(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  # Recursively copies files from +src+ to +dest+.
  #
  # Arguments +src+ and +dest+
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # If +src+ is the path to a file, copies +src+ to +dest+:
  #
  #   FileUtils.touch('src0.txt')
  #   File.exist?('dest0.txt') # => false
  #   FileUtils.copy_entry('src0.txt', 'dest0.txt')
  #   File.file?('dest0.txt')  # => true
  #
  # If +src+ is a directory, recursively copies +src+ to +dest+:
  #
  #   tree('src1')
  #   # => src1
  #   #    |-- dir0
  #   #    |   |-- src0.txt
  #   #    |   `-- src1.txt
  #   #    `-- dir1
  #   #        |-- src2.txt
  #   #        `-- src3.txt
  #   FileUtils.copy_entry('src1', 'dest1')
  #   tree('dest1')
  #   # => dest1
  #   #    |-- dir0
  #   #    |   |-- src0.txt
  #   #    |   `-- src1.txt
  #   #    `-- dir1
  #   #        |-- src2.txt
  #   #        `-- src3.txt
  #
  # The recursive copying preserves file types for regular files,
  # directories, and symbolic links;
  # other file types (FIFO streams, device files, etc.) are not supported.
  #
  # Keyword arguments:
  #
  # - <tt>dereference_root: true</tt> - if +src+ is a symbolic link,
  #   follows the link.
  # - <tt>preserve: true</tt> - preserves file times.
  # - <tt>remove_destination: true</tt> - removes +dest+ before copying files.
  #
  # Related: {methods for copying}[rdoc-ref:FileUtils@Copying].
  #
  # source://fileutils//lib/fileutils.rb#1041
  def copy_entry(src, dest, preserve = T.unsafe(nil), dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end

  # Copies file from +src+ to +dest+, which should not be directories.
  #
  # Arguments +src+ and +dest+
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # Examples:
  #
  #   FileUtils.touch('src0.txt')
  #   FileUtils.copy_file('src0.txt', 'dest0.txt')
  #   File.file?('dest0.txt') # => true
  #
  # Keyword arguments:
  #
  # - <tt>dereference: false</tt> - if +src+ is a symbolic link,
  #   does not follow the link.
  # - <tt>preserve: true</tt> - preserves file times.
  # - <tt>remove_destination: true</tt> - removes +dest+ before copying files.
  #
  # Related: {methods for copying}[rdoc-ref:FileUtils@Copying].
  #
  # source://fileutils//lib/fileutils.rb#1077
  def copy_file(src, dest, preserve = T.unsafe(nil), dereference = T.unsafe(nil)); end

  # Copies \IO stream +src+ to \IO stream +dest+ via
  # {IO.copy_stream}[https://docs.ruby-lang.org/en/master/IO.html#method-c-copy_stream].
  #
  # Related: {methods for copying}[rdoc-ref:FileUtils@Copying].
  #
  # source://fileutils//lib/fileutils.rb#1089
  def copy_stream(src, dest); end

  # Copies files.
  #
  # Arguments +src+ (a single path or an array of paths)
  # and +dest+ (a single path)
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # If +src+ is the path to a file and +dest+ is not the path to a directory,
  # copies +src+ to +dest+:
  #
  #   FileUtils.touch('src0.txt')
  #   File.exist?('dest0.txt') # => false
  #   FileUtils.cp('src0.txt', 'dest0.txt')
  #   File.file?('dest0.txt')  # => true
  #
  # If +src+ is the path to a file and +dest+ is the path to a directory,
  # copies +src+ to <tt>dest/src</tt>:
  #
  #   FileUtils.touch('src1.txt')
  #   FileUtils.mkdir('dest1')
  #   FileUtils.cp('src1.txt', 'dest1')
  #   File.file?('dest1/src1.txt') # => true
  #
  # If +src+ is an array of paths to files and +dest+ is the path to a directory,
  # copies from each +src+ to +dest+:
  #
  #   src_file_paths = ['src2.txt', 'src2.dat']
  #   FileUtils.touch(src_file_paths)
  #   FileUtils.mkdir('dest2')
  #   FileUtils.cp(src_file_paths, 'dest2')
  #   File.file?('dest2/src2.txt') # => true
  #   File.file?('dest2/src2.dat') # => true
  #
  # Keyword arguments:
  #
  # - <tt>preserve: true</tt> - preserves file times.
  # - <tt>noop: true</tt> - does not copy files.
  # - <tt>verbose: true</tt> - prints an equivalent command:
  #
  #     FileUtils.cp('src0.txt', 'dest0.txt', noop: true, verbose: true)
  #     FileUtils.cp('src1.txt', 'dest1', noop: true, verbose: true)
  #     FileUtils.cp(src_file_paths, 'dest2', noop: true, verbose: true)
  #
  #   Output:
  #
  #     cp src0.txt dest0.txt
  #     cp src1.txt dest1
  #     cp src2.txt src2.dat dest2
  #
  # Raises an exception if +src+ is a directory.
  #
  # Related: {methods for copying}[rdoc-ref:FileUtils@Copying].
  #
  # source://fileutils//lib/fileutils.rb#874
  def cp(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  # Creates {hard links}[https://en.wikipedia.org/wiki/Hard_link].
  #
  # Arguments +src+ (a single path or an array of paths)
  # and +dest+ (a single path)
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # If +src+ is the path to a directory and +dest+ does not exist,
  # creates links +dest+ and descendents pointing to +src+ and its descendents:
  #
  #   tree('src0')
  #   # => src0
  #   #    |-- sub0
  #   #    |   |-- src0.txt
  #   #    |   `-- src1.txt
  #   #    `-- sub1
  #   #        |-- src2.txt
  #   #        `-- src3.txt
  #   File.exist?('dest0') # => false
  #   FileUtils.cp_lr('src0', 'dest0')
  #   tree('dest0')
  #   # => dest0
  #   #    |-- sub0
  #   #    |   |-- src0.txt
  #   #    |   `-- src1.txt
  #   #    `-- sub1
  #   #        |-- src2.txt
  #   #        `-- src3.txt
  #
  # If +src+ and +dest+ are both paths to directories,
  # creates links <tt>dest/src</tt> and descendents
  # pointing to +src+ and its descendents:
  #
  #   tree('src1')
  #   # => src1
  #   #    |-- sub0
  #   #    |   |-- src0.txt
  #   #    |   `-- src1.txt
  #   #    `-- sub1
  #   #        |-- src2.txt
  #   #        `-- src3.txt
  #   FileUtils.mkdir('dest1')
  #   FileUtils.cp_lr('src1', 'dest1')
  #   tree('dest1')
  #   # => dest1
  #   #    `-- src1
  #   #        |-- sub0
  #   #        |   |-- src0.txt
  #   #        |   `-- src1.txt
  #   #        `-- sub1
  #   #            |-- src2.txt
  #   #            `-- src3.txt
  #
  # If +src+ is an array of paths to entries and +dest+ is the path to a directory,
  # for each path +filepath+ in +src+, creates a link at <tt>dest/filepath</tt>
  # pointing to that path:
  #
  #   tree('src2')
  #   # => src2
  #   #    |-- sub0
  #   #    |   |-- src0.txt
  #   #    |   `-- src1.txt
  #   #    `-- sub1
  #   #        |-- src2.txt
  #   #        `-- src3.txt
  #   FileUtils.mkdir('dest2')
  #   FileUtils.cp_lr(['src2/sub0', 'src2/sub1'], 'dest2')
  #   tree('dest2')
  #   # => dest2
  #   #    |-- sub0
  #   #    |   |-- src0.txt
  #   #    |   `-- src1.txt
  #   #    `-- sub1
  #   #        |-- src2.txt
  #   #        `-- src3.txt
  #
  # Keyword arguments:
  #
  # - <tt>dereference_root: false</tt> - if +src+ is a symbolic link,
  #   does not dereference it.
  # - <tt>noop: true</tt> - does not create links.
  # - <tt>remove_destination: true</tt> - removes +dest+ before creating links.
  # - <tt>verbose: true</tt> - prints an equivalent command:
  #
  #     FileUtils.cp_lr('src0', 'dest0', noop: true, verbose: true)
  #     FileUtils.cp_lr('src1', 'dest1', noop: true, verbose: true)
  #     FileUtils.cp_lr(['src2/sub0', 'src2/sub1'], 'dest2', noop: true, verbose: true)
  #
  #   Output:
  #
  #     cp -lr src0 dest0
  #     cp -lr src1 dest1
  #     cp -lr src2/sub0 src2/sub1 dest2
  #
  # Raises an exception if +dest+ is the path to an existing file or directory
  # and keyword argument <tt>remove_destination: true</tt> is not given.
  #
  # Related: {methods for copying}[rdoc-ref:FileUtils@Copying].
  #
  # source://fileutils//lib/fileutils.rb#628
  def cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  # Recursively copies files.
  #
  # Arguments +src+ (a single path or an array of paths)
  # and +dest+ (a single path)
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # The mode, owner, and group are retained in the copy;
  # to change those, use FileUtils.install instead.
  #
  # If +src+ is the path to a file and +dest+ is not the path to a directory,
  # copies +src+ to +dest+:
  #
  #   FileUtils.touch('src0.txt')
  #   File.exist?('dest0.txt') # => false
  #   FileUtils.cp_r('src0.txt', 'dest0.txt')
  #   File.file?('dest0.txt')  # => true
  #
  # If +src+ is the path to a file and +dest+ is the path to a directory,
  # copies +src+ to <tt>dest/src</tt>:
  #
  #   FileUtils.touch('src1.txt')
  #   FileUtils.mkdir('dest1')
  #   FileUtils.cp_r('src1.txt', 'dest1')
  #   File.file?('dest1/src1.txt') # => true
  #
  # If +src+ is the path to a directory and +dest+ does not exist,
  # recursively copies +src+ to +dest+:
  #
  #   tree('src2')
  #   # => src2
  #   #    |-- dir0
  #   #    |   |-- src0.txt
  #   #    |   `-- src1.txt
  #   #    `-- dir1
  #   #    |-- src2.txt
  #   #    `-- src3.txt
  #   FileUtils.exist?('dest2') # => false
  #   FileUtils.cp_r('src2', 'dest2')
  #   tree('dest2')
  #   # => dest2
  #   #    |-- dir0
  #   #    |   |-- src0.txt
  #   #    |   `-- src1.txt
  #   #    `-- dir1
  #   #    |-- src2.txt
  #   #    `-- src3.txt
  #
  # If +src+ and +dest+ are paths to directories,
  # recursively copies +src+ to <tt>dest/src</tt>:
  #
  #   tree('src3')
  #   # => src3
  #   #    |-- dir0
  #   #    |   |-- src0.txt
  #   #    |   `-- src1.txt
  #   #    `-- dir1
  #   #    |-- src2.txt
  #   #    `-- src3.txt
  #   FileUtils.mkdir('dest3')
  #   FileUtils.cp_r('src3', 'dest3')
  #   tree('dest3')
  #   # => dest3
  #   #    `-- src3
  #   #      |-- dir0
  #   #      |   |-- src0.txt
  #   #      |   `-- src1.txt
  #   #      `-- dir1
  #   #          |-- src2.txt
  #   #          `-- src3.txt
  #
  # If +src+ is an array of paths and +dest+ is a directory,
  # recursively copies from each path in +src+ to +dest+;
  # the paths in +src+ may point to files and/or directories.
  #
  # Keyword arguments:
  #
  # - <tt>dereference_root: false</tt> - if +src+ is a symbolic link,
  #   does not dereference it.
  # - <tt>noop: true</tt> - does not copy files.
  # - <tt>preserve: true</tt> - preserves file times.
  # - <tt>remove_destination: true</tt> - removes +dest+ before copying files.
  # - <tt>verbose: true</tt> - prints an equivalent command:
  #
  #     FileUtils.cp_r('src0.txt', 'dest0.txt', noop: true, verbose: true)
  #     FileUtils.cp_r('src1.txt', 'dest1', noop: true, verbose: true)
  #     FileUtils.cp_r('src2', 'dest2', noop: true, verbose: true)
  #     FileUtils.cp_r('src3', 'dest3', noop: true, verbose: true)
  #
  #   Output:
  #
  #     cp -r src0.txt dest0.txt
  #     cp -r src1.txt dest1
  #     cp -r src2 dest2
  #     cp -r src3 dest3
  #
  # Raises an exception of +src+ is the path to a directory
  # and +dest+ is the path to a file.
  #
  # Related: {methods for copying}[rdoc-ref:FileUtils@Copying].
  #
  # source://fileutils//lib/fileutils.rb#986
  def cp_r(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  # source://fileutils//lib/fileutils.rb#2529
  def fu_clean_components(*comp); end

  # source://fileutils//lib/fileutils.rb#2468
  def fu_each_src_dest(src, dest); end

  # source://fileutils//lib/fileutils.rb#2476
  def fu_each_src_dest0(src, dest, target_directory = T.unsafe(nil)); end

  # source://fileutils//lib/fileutils.rb#1948
  def fu_get_gid(group); end

  # source://fileutils//lib/fileutils.rb#1934
  def fu_get_uid(user); end

  # @return [Boolean]
  #
  # source://fileutils//lib/fileutils.rb#1424
  def fu_have_symlink?; end

  # class Entry_
  #
  # source://fileutils//lib/fileutils.rb#2463
  def fu_list(arg); end

  # source://fileutils//lib/fileutils.rb#397
  def fu_mkdir(path, mode); end

  # source://fileutils//lib/fileutils.rb#1722
  def fu_mode(mode, path); end

  # source://fileutils//lib/fileutils.rb#2498
  def fu_output_message(msg); end

  # source://fileutils//lib/fileutils.rb#2520
  def fu_relative_components_from(target, base); end

  # @return [Boolean]
  #
  # source://fileutils//lib/fileutils.rb#2493
  def fu_same?(a, b); end

  # source://fileutils//lib/fileutils.rb#2508
  def fu_split_path(path); end

  # @return [Boolean]
  #
  # source://fileutils//lib/fileutils.rb#2552
  def fu_starting_path?(path); end

  # @return [Boolean]
  #
  # source://fileutils//lib/fileutils.rb#1433
  def fu_stat_identical_entry?(a, b); end

  # Returns a string containing the path to the current directory:
  #
  #   FileUtils.pwd # => "/rdoc/fileutils"
  #
  # Related: FileUtils.cd.
  #
  # source://fileutils//lib/fileutils.rb#198
  def getwd; end

  # Returns +true+ if the contents of files +a+ and +b+ are identical,
  # +false+ otherwise.
  #
  # Arguments +a+ and +b+
  # should be {interpretable as a path}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # FileUtils.identical? and FileUtils.cmp are aliases for FileUtils.compare_file.
  #
  # Related: FileUtils.compare_stream.
  #
  # source://fileutils//lib/fileutils.rb#1508
  def identical?(a, b); end

  # Copies a file entry.
  # See {install(1)}[https://man7.org/linux/man-pages/man1/install.1.html].
  #
  # Arguments +src+ (a single path or an array of paths)
  # and +dest+ (a single path)
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments];
  #
  # If the entry at +dest+ does not exist, copies from +src+ to +dest+:
  #
  #   File.read('src0.txt')    # => "aaa\n"
  #   File.exist?('dest0.txt') # => false
  #   FileUtils.install('src0.txt', 'dest0.txt')
  #   File.read('dest0.txt')   # => "aaa\n"
  #
  # If +dest+ is a file entry, copies from +src+ to +dest+, overwriting:
  #
  #   File.read('src1.txt')  # => "aaa\n"
  #   File.read('dest1.txt') # => "bbb\n"
  #   FileUtils.install('src1.txt', 'dest1.txt')
  #   File.read('dest1.txt') # => "aaa\n"
  #
  # If +dest+ is a directory entry, copies from +src+ to <tt>dest/src</tt>,
  # overwriting if necessary:
  #
  #   File.read('src2.txt')       # => "aaa\n"
  #   File.read('dest2/src2.txt') # => "bbb\n"
  #   FileUtils.install('src2.txt', 'dest2')
  #   File.read('dest2/src2.txt') # => "aaa\n"
  #
  # If +src+ is an array of paths and +dest+ points to a directory,
  # copies each path +path+ in +src+ to <tt>dest/path</tt>:
  #
  #   File.file?('src3.txt') # => true
  #   File.file?('src3.dat') # => true
  #   FileUtils.mkdir('dest3')
  #   FileUtils.install(['src3.txt', 'src3.dat'], 'dest3')
  #   File.file?('dest3/src3.txt') # => true
  #   File.file?('dest3/src3.dat') # => true
  #
  # Keyword arguments:
  #
  # - <tt>group: <i>group</i></tt> - changes the group if not +nil+,
  #   using {File.chown}[https://docs.ruby-lang.org/en/master/File.html#method-c-chown].
  # - <tt>mode: <i>permissions</i></tt> - changes the permissions.
  #   using {File.chmod}[https://docs.ruby-lang.org/en/master/File.html#method-c-chmod].
  # - <tt>noop: true</tt> - does not copy entries; returns +nil+.
  # - <tt>owner: <i>owner</i></tt> - changes the owner if not +nil+,
  #   using {File.chown}[https://docs.ruby-lang.org/en/master/File.html#method-c-chown].
  # - <tt>preserve: true</tt> - preserve timestamps
  #   using {File.utime}[https://docs.ruby-lang.org/en/master/File.html#method-c-utime].
  # - <tt>verbose: true</tt> - prints an equivalent command:
  #
  #     FileUtils.install('src0.txt', 'dest0.txt', noop: true, verbose: true)
  #     FileUtils.install('src1.txt', 'dest1.txt', noop: true, verbose: true)
  #     FileUtils.install('src2.txt', 'dest2', noop: true, verbose: true)
  #
  #   Output:
  #
  #     install -c src0.txt dest0.txt
  #     install -c src1.txt dest1.txt
  #     install -c src2.txt dest2
  #
  # Related: {methods for copying}[rdoc-ref:FileUtils@Copying].
  #
  # source://fileutils//lib/fileutils.rb#1610
  def install(src, dest, mode: T.unsafe(nil), owner: T.unsafe(nil), group: T.unsafe(nil), preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  # Creates {hard links}[https://en.wikipedia.org/wiki/Hard_link].
  #
  # Arguments +src+ (a single path or an array of paths)
  # and +dest+ (a single path)
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # When +src+ is the path to an existing file
  # and +dest+ is the path to a non-existent file,
  # creates a hard link at +dest+ pointing to +src+; returns zero:
  #
  #   Dir.children('tmp0/')                    # => ["t.txt"]
  #   Dir.children('tmp1/')                    # => []
  #   FileUtils.ln('tmp0/t.txt', 'tmp1/t.lnk') # => 0
  #   Dir.children('tmp1/')                    # => ["t.lnk"]
  #
  # When +src+ is the path to an existing file
  # and +dest+ is the path to an existing directory,
  # creates a hard link at <tt>dest/src</tt> pointing to +src+; returns zero:
  #
  #   Dir.children('tmp2')               # => ["t.dat"]
  #   Dir.children('tmp3')               # => []
  #   FileUtils.ln('tmp2/t.dat', 'tmp3') # => 0
  #   Dir.children('tmp3')               # => ["t.dat"]
  #
  # When +src+ is an array of paths to existing files
  # and +dest+ is the path to an existing directory,
  # then for each path +target+ in +src+,
  # creates a hard link at <tt>dest/target</tt> pointing to +target+;
  # returns +src+:
  #
  #   Dir.children('tmp4/')                               # => []
  #   FileUtils.ln(['tmp0/t.txt', 'tmp2/t.dat'], 'tmp4/') # => ["tmp0/t.txt", "tmp2/t.dat"]
  #   Dir.children('tmp4/')                               # => ["t.dat", "t.txt"]
  #
  # Keyword arguments:
  #
  # - <tt>force: true</tt> - overwrites +dest+ if it exists.
  # - <tt>noop: true</tt> - does not create links.
  # - <tt>verbose: true</tt> - prints an equivalent command:
  #
  #     FileUtils.ln('tmp0/t.txt', 'tmp1/t.lnk', verbose: true)
  #     FileUtils.ln('tmp2/t.dat', 'tmp3', verbose: true)
  #     FileUtils.ln(['tmp0/t.txt', 'tmp2/t.dat'], 'tmp4/', verbose: true)
  #
  #   Output:
  #
  #     ln tmp0/t.txt tmp1/t.lnk
  #     ln tmp2/t.dat tmp3
  #     ln tmp0/t.txt tmp2/t.dat tmp4/
  #
  # Raises an exception if +dest+ is the path to an existing file
  # and keyword argument +force+ is not +true+.
  #
  # Related: FileUtils.link_entry (has different options).
  #
  # source://fileutils//lib/fileutils.rb#517
  def link(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  # Creates {hard links}[https://en.wikipedia.org/wiki/Hard_link]; returns +nil+.
  #
  # Arguments +src+ and +dest+
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # If +src+ is the path to a file and +dest+ does not exist,
  # creates a hard link at +dest+ pointing to +src+:
  #
  #   FileUtils.touch('src0.txt')
  #   File.exist?('dest0.txt') # => false
  #   FileUtils.link_entry('src0.txt', 'dest0.txt')
  #   File.file?('dest0.txt')  # => true
  #
  # If +src+ is the path to a directory and +dest+ does not exist,
  # recursively creates hard links at +dest+ pointing to paths in +src+:
  #
  #   FileUtils.mkdir_p(['src1/dir0', 'src1/dir1'])
  #   src_file_paths = [
  #     'src1/dir0/t0.txt',
  #     'src1/dir0/t1.txt',
  #     'src1/dir1/t2.txt',
  #     'src1/dir1/t3.txt',
  #     ]
  #   FileUtils.touch(src_file_paths)
  #   File.directory?('dest1')        # => true
  #   FileUtils.link_entry('src1', 'dest1')
  #   File.file?('dest1/dir0/t0.txt') # => true
  #   File.file?('dest1/dir0/t1.txt') # => true
  #   File.file?('dest1/dir1/t2.txt') # => true
  #   File.file?('dest1/dir1/t3.txt') # => true
  #
  # Keyword arguments:
  #
  # - <tt>dereference_root: true</tt> - dereferences +src+ if it is a symbolic link.
  # - <tt>remove_destination: true</tt> - removes +dest+ before creating links.
  #
  # Raises an exception if +dest+ is the path to an existing file or directory
  # and keyword argument <tt>remove_destination: true</tt> is not given.
  #
  # Related: FileUtils.ln (has different options).
  #
  # source://fileutils//lib/fileutils.rb#813
  def link_entry(src, dest, dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end

  # Creates {hard links}[https://en.wikipedia.org/wiki/Hard_link].
  #
  # Arguments +src+ (a single path or an array of paths)
  # and +dest+ (a single path)
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # When +src+ is the path to an existing file
  # and +dest+ is the path to a non-existent file,
  # creates a hard link at +dest+ pointing to +src+; returns zero:
  #
  #   Dir.children('tmp0/')                    # => ["t.txt"]
  #   Dir.children('tmp1/')                    # => []
  #   FileUtils.ln('tmp0/t.txt', 'tmp1/t.lnk') # => 0
  #   Dir.children('tmp1/')                    # => ["t.lnk"]
  #
  # When +src+ is the path to an existing file
  # and +dest+ is the path to an existing directory,
  # creates a hard link at <tt>dest/src</tt> pointing to +src+; returns zero:
  #
  #   Dir.children('tmp2')               # => ["t.dat"]
  #   Dir.children('tmp3')               # => []
  #   FileUtils.ln('tmp2/t.dat', 'tmp3') # => 0
  #   Dir.children('tmp3')               # => ["t.dat"]
  #
  # When +src+ is an array of paths to existing files
  # and +dest+ is the path to an existing directory,
  # then for each path +target+ in +src+,
  # creates a hard link at <tt>dest/target</tt> pointing to +target+;
  # returns +src+:
  #
  #   Dir.children('tmp4/')                               # => []
  #   FileUtils.ln(['tmp0/t.txt', 'tmp2/t.dat'], 'tmp4/') # => ["tmp0/t.txt", "tmp2/t.dat"]
  #   Dir.children('tmp4/')                               # => ["t.dat", "t.txt"]
  #
  # Keyword arguments:
  #
  # - <tt>force: true</tt> - overwrites +dest+ if it exists.
  # - <tt>noop: true</tt> - does not create links.
  # - <tt>verbose: true</tt> - prints an equivalent command:
  #
  #     FileUtils.ln('tmp0/t.txt', 'tmp1/t.lnk', verbose: true)
  #     FileUtils.ln('tmp2/t.dat', 'tmp3', verbose: true)
  #     FileUtils.ln(['tmp0/t.txt', 'tmp2/t.dat'], 'tmp4/', verbose: true)
  #
  #   Output:
  #
  #     ln tmp0/t.txt tmp1/t.lnk
  #     ln tmp2/t.dat tmp3
  #     ln tmp0/t.txt tmp2/t.dat tmp4/
  #
  # Raises an exception if +dest+ is the path to an existing file
  # and keyword argument +force+ is not +true+.
  #
  # Related: FileUtils.link_entry (has different options).
  #
  # source://fileutils//lib/fileutils.rb#517
  def ln(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  # Creates {symbolic links}[https://en.wikipedia.org/wiki/Symbolic_link].
  #
  # Arguments +src+ (a single path or an array of paths)
  # and +dest+ (a single path)
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # If +src+ is the path to an existing file:
  #
  # - When +dest+ is the path to a non-existent file,
  #   creates a symbolic link at +dest+ pointing to +src+:
  #
  #     FileUtils.touch('src0.txt')
  #     File.exist?('dest0.txt')   # => false
  #     FileUtils.ln_s('src0.txt', 'dest0.txt')
  #     File.symlink?('dest0.txt') # => true
  #
  # - When +dest+ is the path to an existing file,
  #   creates a symbolic link at +dest+ pointing to +src+
  #   if and only if keyword argument <tt>force: true</tt> is given
  #   (raises an exception otherwise):
  #
  #     FileUtils.touch('src1.txt')
  #     FileUtils.touch('dest1.txt')
  #     FileUtils.ln_s('src1.txt', 'dest1.txt', force: true)
  #     FileTest.symlink?('dest1.txt') # => true
  #
  #     FileUtils.ln_s('src1.txt', 'dest1.txt') # Raises Errno::EEXIST.
  #
  # If +dest+ is the path to a directory,
  # creates a symbolic link at <tt>dest/src</tt> pointing to +src+:
  #
  #   FileUtils.touch('src2.txt')
  #   FileUtils.mkdir('destdir2')
  #   FileUtils.ln_s('src2.txt', 'destdir2')
  #   File.symlink?('destdir2/src2.txt') # => true
  #
  # If +src+ is an array of paths to existing files and +dest+ is a directory,
  # for each child +child+ in +src+ creates a symbolic link <tt>dest/child</tt>
  # pointing to +child+:
  #
  #   FileUtils.mkdir('srcdir3')
  #   FileUtils.touch('srcdir3/src0.txt')
  #   FileUtils.touch('srcdir3/src1.txt')
  #   FileUtils.mkdir('destdir3')
  #   FileUtils.ln_s(['srcdir3/src0.txt', 'srcdir3/src1.txt'], 'destdir3')
  #   File.symlink?('destdir3/src0.txt') # => true
  #   File.symlink?('destdir3/src1.txt') # => true
  #
  # Keyword arguments:
  #
  # - <tt>force: true</tt> - overwrites +dest+ if it exists.
  # - <tt>relative: false</tt> - create links relative to +dest+.
  # - <tt>noop: true</tt> - does not create links.
  # - <tt>verbose: true</tt> - prints an equivalent command:
  #
  #     FileUtils.ln_s('src0.txt', 'dest0.txt', noop: true, verbose: true)
  #     FileUtils.ln_s('src1.txt', 'destdir1', noop: true, verbose: true)
  #     FileUtils.ln_s('src2.txt', 'dest2.txt', force: true, noop: true, verbose: true)
  #     FileUtils.ln_s(['srcdir3/src0.txt', 'srcdir3/src1.txt'], 'destdir3', noop: true, verbose: true)
  #
  #   Output:
  #
  #     ln -s src0.txt dest0.txt
  #     ln -s src1.txt destdir1
  #     ln -sf src2.txt dest2.txt
  #     ln -s srcdir3/src0.txt srcdir3/src1.txt destdir3
  #
  # Related: FileUtils.ln_sf.
  #
  # source://fileutils//lib/fileutils.rb#707
  def ln_s(src, dest, force: T.unsafe(nil), relative: T.unsafe(nil), target_directory: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  # Like FileUtils.ln_s, but always with keyword argument <tt>force: true</tt> given.
  #
  # source://fileutils//lib/fileutils.rb#725
  def ln_sf(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  # Like FileUtils.ln_s, but create links relative to +dest+.
  #
  # source://fileutils//lib/fileutils.rb#732
  def ln_sr(src, dest, target_directory: T.unsafe(nil), force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  # Creates directories at the paths in the given +list+
  # (a single path or an array of paths),
  # also creating ancestor directories as needed;
  # returns +list+ if it is an array, <tt>[list]</tt> otherwise.
  #
  # Argument +list+ or its elements
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # With no keyword arguments, creates a directory at each +path+ in +list+,
  # along with any needed ancestor directories,
  # by calling: <tt>Dir.mkdir(path, mode)</tt>;
  # see {Dir.mkdir}[https://docs.ruby-lang.org/en/master/Dir.html#method-c-mkdir]:
  #
  #   FileUtils.mkdir_p(%w[tmp0/tmp1 tmp2/tmp3]) # => ["tmp0/tmp1", "tmp2/tmp3"]
  #   FileUtils.mkdir_p('tmp4/tmp5')             # => ["tmp4/tmp5"]
  #
  # Keyword arguments:
  #
  # - <tt>mode: <i>mode</i></tt> - also calls <tt>File.chmod(mode, path)</tt>;
  #   see {File.chmod}[https://docs.ruby-lang.org/en/master/File.html#method-c-chmod].
  # - <tt>noop: true</tt> - does not create directories.
  # - <tt>verbose: true</tt> - prints an equivalent command:
  #
  #     FileUtils.mkdir_p(%w[tmp0 tmp1], verbose: true)
  #     FileUtils.mkdir_p(%w[tmp2 tmp3], mode: 0700, verbose: true)
  #
  #   Output:
  #
  #     mkdir -p tmp0 tmp1
  #     mkdir -p -m 700 tmp2 tmp3
  #
  # Raises an exception if for any reason a directory cannot be created.
  #
  # FileUtils.mkpath and FileUtils.makedirs are aliases for FileUtils.mkdir_p.
  #
  # Related: FileUtils.mkdir.
  #
  # source://fileutils//lib/fileutils.rb#366
  def makedirs(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  # Creates directories at the paths in the given +list+
  # (a single path or an array of paths);
  # returns +list+ if it is an array, <tt>[list]</tt> otherwise.
  #
  # Argument +list+ or its elements
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # With no keyword arguments, creates a directory at each +path+ in +list+
  # by calling: <tt>Dir.mkdir(path, mode)</tt>;
  # see {Dir.mkdir}[https://docs.ruby-lang.org/en/master/Dir.html#method-c-mkdir]:
  #
  #   FileUtils.mkdir(%w[tmp0 tmp1]) # => ["tmp0", "tmp1"]
  #   FileUtils.mkdir('tmp4')        # => ["tmp4"]
  #
  # Keyword arguments:
  #
  # - <tt>mode: <i>mode</i></tt> - also calls <tt>File.chmod(mode, path)</tt>;
  #   see {File.chmod}[https://docs.ruby-lang.org/en/master/File.html#method-c-chmod].
  # - <tt>noop: true</tt> - does not create directories.
  # - <tt>verbose: true</tt> - prints an equivalent command:
  #
  #     FileUtils.mkdir(%w[tmp0 tmp1], verbose: true)
  #     FileUtils.mkdir(%w[tmp2 tmp3], mode: 0700, verbose: true)
  #
  #   Output:
  #
  #     mkdir tmp0 tmp1
  #     mkdir -m 700 tmp2 tmp3
  #
  # Raises an exception if any path points to an existing
  # file or directory, or if for any reason a directory cannot be created.
  #
  # Related: FileUtils.mkdir_p.
  #
  # source://fileutils//lib/fileutils.rb#317
  def mkdir(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  # Creates directories at the paths in the given +list+
  # (a single path or an array of paths),
  # also creating ancestor directories as needed;
  # returns +list+ if it is an array, <tt>[list]</tt> otherwise.
  #
  # Argument +list+ or its elements
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # With no keyword arguments, creates a directory at each +path+ in +list+,
  # along with any needed ancestor directories,
  # by calling: <tt>Dir.mkdir(path, mode)</tt>;
  # see {Dir.mkdir}[https://docs.ruby-lang.org/en/master/Dir.html#method-c-mkdir]:
  #
  #   FileUtils.mkdir_p(%w[tmp0/tmp1 tmp2/tmp3]) # => ["tmp0/tmp1", "tmp2/tmp3"]
  #   FileUtils.mkdir_p('tmp4/tmp5')             # => ["tmp4/tmp5"]
  #
  # Keyword arguments:
  #
  # - <tt>mode: <i>mode</i></tt> - also calls <tt>File.chmod(mode, path)</tt>;
  #   see {File.chmod}[https://docs.ruby-lang.org/en/master/File.html#method-c-chmod].
  # - <tt>noop: true</tt> - does not create directories.
  # - <tt>verbose: true</tt> - prints an equivalent command:
  #
  #     FileUtils.mkdir_p(%w[tmp0 tmp1], verbose: true)
  #     FileUtils.mkdir_p(%w[tmp2 tmp3], mode: 0700, verbose: true)
  #
  #   Output:
  #
  #     mkdir -p tmp0 tmp1
  #     mkdir -p -m 700 tmp2 tmp3
  #
  # Raises an exception if for any reason a directory cannot be created.
  #
  # FileUtils.mkpath and FileUtils.makedirs are aliases for FileUtils.mkdir_p.
  #
  # Related: FileUtils.mkdir.
  #
  # source://fileutils//lib/fileutils.rb#366
  def mkdir_p(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  # Creates directories at the paths in the given +list+
  # (a single path or an array of paths),
  # also creating ancestor directories as needed;
  # returns +list+ if it is an array, <tt>[list]</tt> otherwise.
  #
  # Argument +list+ or its elements
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # With no keyword arguments, creates a directory at each +path+ in +list+,
  # along with any needed ancestor directories,
  # by calling: <tt>Dir.mkdir(path, mode)</tt>;
  # see {Dir.mkdir}[https://docs.ruby-lang.org/en/master/Dir.html#method-c-mkdir]:
  #
  #   FileUtils.mkdir_p(%w[tmp0/tmp1 tmp2/tmp3]) # => ["tmp0/tmp1", "tmp2/tmp3"]
  #   FileUtils.mkdir_p('tmp4/tmp5')             # => ["tmp4/tmp5"]
  #
  # Keyword arguments:
  #
  # - <tt>mode: <i>mode</i></tt> - also calls <tt>File.chmod(mode, path)</tt>;
  #   see {File.chmod}[https://docs.ruby-lang.org/en/master/File.html#method-c-chmod].
  # - <tt>noop: true</tt> - does not create directories.
  # - <tt>verbose: true</tt> - prints an equivalent command:
  #
  #     FileUtils.mkdir_p(%w[tmp0 tmp1], verbose: true)
  #     FileUtils.mkdir_p(%w[tmp2 tmp3], mode: 0700, verbose: true)
  #
  #   Output:
  #
  #     mkdir -p tmp0 tmp1
  #     mkdir -p -m 700 tmp2 tmp3
  #
  # Raises an exception if for any reason a directory cannot be created.
  #
  # FileUtils.mkpath and FileUtils.makedirs are aliases for FileUtils.mkdir_p.
  #
  # Related: FileUtils.mkdir.
  #
  # source://fileutils//lib/fileutils.rb#366
  def mkpath(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  # source://fileutils//lib/fileutils.rb#1727
  def mode_to_s(mode); end

  # Moves entries.
  #
  # Arguments +src+ (a single path or an array of paths)
  # and +dest+ (a single path)
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # If +src+ and +dest+ are on different file systems,
  # first copies, then removes +src+.
  #
  # May cause a local vulnerability if not called with keyword argument
  # <tt>secure: true</tt>;
  # see {Avoiding the TOCTTOU Vulnerability}[rdoc-ref:FileUtils@Avoiding+the+TOCTTOU+Vulnerability].
  #
  # If +src+ is the path to a single file or directory and +dest+ does not exist,
  # moves +src+ to +dest+:
  #
  #   tree('src0')
  #   # => src0
  #   #    |-- src0.txt
  #   #    `-- src1.txt
  #   File.exist?('dest0') # => false
  #   FileUtils.mv('src0', 'dest0')
  #   File.exist?('src0')  # => false
  #   tree('dest0')
  #   # => dest0
  #   #    |-- src0.txt
  #   #    `-- src1.txt
  #
  # If +src+ is an array of paths to files and directories
  # and +dest+ is the path to a directory,
  # copies from each path in the array to +dest+:
  #
  #   File.file?('src1.txt') # => true
  #   tree('src1')
  #   # => src1
  #   #    |-- src.dat
  #   #    `-- src.txt
  #   Dir.empty?('dest1')    # => true
  #   FileUtils.mv(['src1.txt', 'src1'], 'dest1')
  #   tree('dest1')
  #   # => dest1
  #   #    |-- src1
  #   #    |   |-- src.dat
  #   #    |   `-- src.txt
  #   #    `-- src1.txt
  #
  # Keyword arguments:
  #
  # - <tt>force: true</tt> - if the move includes removing +src+
  #   (that is, if +src+ and +dest+ are on different file systems),
  #   ignores raised exceptions of StandardError and its descendants.
  # - <tt>noop: true</tt> - does not move files.
  # - <tt>secure: true</tt> - removes +src+ securely;
  #   see details at FileUtils.remove_entry_secure.
  # - <tt>verbose: true</tt> - prints an equivalent command:
  #
  #     FileUtils.mv('src0', 'dest0', noop: true, verbose: true)
  #     FileUtils.mv(['src1.txt', 'src1'], 'dest1', noop: true, verbose: true)
  #
  #   Output:
  #
  #     mv src0 dest0
  #     mv src1.txt src1 dest1
  #
  # source://fileutils//lib/fileutils.rb#1158
  def move(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  # Moves entries.
  #
  # Arguments +src+ (a single path or an array of paths)
  # and +dest+ (a single path)
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # If +src+ and +dest+ are on different file systems,
  # first copies, then removes +src+.
  #
  # May cause a local vulnerability if not called with keyword argument
  # <tt>secure: true</tt>;
  # see {Avoiding the TOCTTOU Vulnerability}[rdoc-ref:FileUtils@Avoiding+the+TOCTTOU+Vulnerability].
  #
  # If +src+ is the path to a single file or directory and +dest+ does not exist,
  # moves +src+ to +dest+:
  #
  #   tree('src0')
  #   # => src0
  #   #    |-- src0.txt
  #   #    `-- src1.txt
  #   File.exist?('dest0') # => false
  #   FileUtils.mv('src0', 'dest0')
  #   File.exist?('src0')  # => false
  #   tree('dest0')
  #   # => dest0
  #   #    |-- src0.txt
  #   #    `-- src1.txt
  #
  # If +src+ is an array of paths to files and directories
  # and +dest+ is the path to a directory,
  # copies from each path in the array to +dest+:
  #
  #   File.file?('src1.txt') # => true
  #   tree('src1')
  #   # => src1
  #   #    |-- src.dat
  #   #    `-- src.txt
  #   Dir.empty?('dest1')    # => true
  #   FileUtils.mv(['src1.txt', 'src1'], 'dest1')
  #   tree('dest1')
  #   # => dest1
  #   #    |-- src1
  #   #    |   |-- src.dat
  #   #    |   `-- src.txt
  #   #    `-- src1.txt
  #
  # Keyword arguments:
  #
  # - <tt>force: true</tt> - if the move includes removing +src+
  #   (that is, if +src+ and +dest+ are on different file systems),
  #   ignores raised exceptions of StandardError and its descendants.
  # - <tt>noop: true</tt> - does not move files.
  # - <tt>secure: true</tt> - removes +src+ securely;
  #   see details at FileUtils.remove_entry_secure.
  # - <tt>verbose: true</tt> - prints an equivalent command:
  #
  #     FileUtils.mv('src0', 'dest0', noop: true, verbose: true)
  #     FileUtils.mv(['src1.txt', 'src1'], 'dest1', noop: true, verbose: true)
  #
  #   Output:
  #
  #     mv src0 dest0
  #     mv src1.txt src1 dest1
  #
  # source://fileutils//lib/fileutils.rb#1158
  def mv(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  # Returns a string containing the path to the current directory:
  #
  #   FileUtils.pwd # => "/rdoc/fileutils"
  #
  # Related: FileUtils.cd.
  #
  # source://fileutils//lib/fileutils.rb#198
  def pwd; end

  # Removes entries at the paths in the given +list+
  # (a single path or an array of paths)
  # returns +list+, if it is an array, <tt>[list]</tt> otherwise.
  #
  # Argument +list+ or its elements
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # With no keyword arguments, removes files at the paths given in +list+:
  #
  #   FileUtils.touch(['src0.txt', 'src0.dat'])
  #   FileUtils.rm(['src0.dat', 'src0.txt']) # => ["src0.dat", "src0.txt"]
  #
  # Keyword arguments:
  #
  # - <tt>force: true</tt> - ignores raised exceptions of StandardError
  #   and its descendants.
  # - <tt>noop: true</tt> - does not remove files; returns +nil+.
  # - <tt>verbose: true</tt> - prints an equivalent command:
  #
  #     FileUtils.rm(['src0.dat', 'src0.txt'], noop: true, verbose: true)
  #
  #   Output:
  #
  #     rm src0.dat src0.txt
  #
  # Related: {methods for deleting}[rdoc-ref:FileUtils@Deleting].
  #
  # source://fileutils//lib/fileutils.rb#1217
  def remove(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  # Recursively removes the directory entry given by +path+,
  # which should be the entry for a regular file, a symbolic link,
  # or a directory.
  #
  # Argument +path+
  # should be {interpretable as a path}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # Optional argument +force+ specifies whether to ignore
  # raised exceptions of StandardError and its descendants.
  #
  # Related: {methods for deleting}[rdoc-ref:FileUtils@Deleting].
  #
  # source://fileutils//lib/fileutils.rb#1493
  def remove_dir(path, force = T.unsafe(nil)); end

  # Removes the entry given by +path+,
  # which should be the entry for a regular file, a symbolic link,
  # or a directory.
  #
  # Argument +path+
  # should be {interpretable as a path}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # Optional argument +force+ specifies whether to ignore
  # raised exceptions of StandardError and its descendants.
  #
  # Related: FileUtils.remove_entry_secure.
  #
  # source://fileutils//lib/fileutils.rb#1450
  def remove_entry(path, force = T.unsafe(nil)); end

  # Securely removes the entry given by +path+,
  # which should be the entry for a regular file, a symbolic link,
  # or a directory.
  #
  # Argument +path+
  # should be {interpretable as a path}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # Avoids a local vulnerability that can exist in certain circumstances;
  # see {Avoiding the TOCTTOU Vulnerability}[rdoc-ref:FileUtils@Avoiding+the+TOCTTOU+Vulnerability].
  #
  # Optional argument +force+ specifies whether to ignore
  # raised exceptions of StandardError and its descendants.
  #
  # Related: {methods for deleting}[rdoc-ref:FileUtils@Deleting].
  #
  # source://fileutils//lib/fileutils.rb#1352
  def remove_entry_secure(path, force = T.unsafe(nil)); end

  # Removes the file entry given by +path+,
  # which should be the entry for a regular file or a symbolic link.
  #
  # Argument +path+
  # should be {interpretable as a path}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # Optional argument +force+ specifies whether to ignore
  # raised exceptions of StandardError and its descendants.
  #
  # Related: {methods for deleting}[rdoc-ref:FileUtils@Deleting].
  #
  # source://fileutils//lib/fileutils.rb#1474
  def remove_file(path, force = T.unsafe(nil)); end

  # source://fileutils//lib/fileutils.rb#277
  def remove_trailing_slash(dir); end

  # Removes entries at the paths in the given +list+
  # (a single path or an array of paths)
  # returns +list+, if it is an array, <tt>[list]</tt> otherwise.
  #
  # Argument +list+ or its elements
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # With no keyword arguments, removes files at the paths given in +list+:
  #
  #   FileUtils.touch(['src0.txt', 'src0.dat'])
  #   FileUtils.rm(['src0.dat', 'src0.txt']) # => ["src0.dat", "src0.txt"]
  #
  # Keyword arguments:
  #
  # - <tt>force: true</tt> - ignores raised exceptions of StandardError
  #   and its descendants.
  # - <tt>noop: true</tt> - does not remove files; returns +nil+.
  # - <tt>verbose: true</tt> - prints an equivalent command:
  #
  #     FileUtils.rm(['src0.dat', 'src0.txt'], noop: true, verbose: true)
  #
  #   Output:
  #
  #     rm src0.dat src0.txt
  #
  # Related: {methods for deleting}[rdoc-ref:FileUtils@Deleting].
  #
  # source://fileutils//lib/fileutils.rb#1217
  def rm(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  # Equivalent to:
  #
  #   FileUtils.rm(list, force: true, **kwargs)
  #
  # Argument +list+ (a single path or an array of paths)
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # See FileUtils.rm for keyword arguments.
  #
  # Related: {methods for deleting}[rdoc-ref:FileUtils@Deleting].
  #
  # source://fileutils//lib/fileutils.rb#1242
  def rm_f(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  # Removes entries at the paths in the given +list+
  # (a single path or an array of paths);
  # returns +list+, if it is an array, <tt>[list]</tt> otherwise.
  #
  # Argument +list+ or its elements
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # May cause a local vulnerability if not called with keyword argument
  # <tt>secure: true</tt>;
  # see {Avoiding the TOCTTOU Vulnerability}[rdoc-ref:FileUtils@Avoiding+the+TOCTTOU+Vulnerability].
  #
  # For each file path, removes the file at that path:
  #
  #   FileUtils.touch(['src0.txt', 'src0.dat'])
  #   FileUtils.rm_r(['src0.dat', 'src0.txt'])
  #   File.exist?('src0.txt') # => false
  #   File.exist?('src0.dat') # => false
  #
  # For each directory path, recursively removes files and directories:
  #
  #   tree('src1')
  #   # => src1
  #   #    |-- dir0
  #   #    |   |-- src0.txt
  #   #    |   `-- src1.txt
  #   #    `-- dir1
  #   #        |-- src2.txt
  #   #        `-- src3.txt
  #   FileUtils.rm_r('src1')
  #   File.exist?('src1') # => false
  #
  # Keyword arguments:
  #
  # - <tt>force: true</tt> - ignores raised exceptions of StandardError
  #   and its descendants.
  # - <tt>noop: true</tt> - does not remove entries; returns +nil+.
  # - <tt>secure: true</tt> - removes +src+ securely;
  #   see details at FileUtils.remove_entry_secure.
  # - <tt>verbose: true</tt> - prints an equivalent command:
  #
  #     FileUtils.rm_r(['src0.dat', 'src0.txt'], noop: true, verbose: true)
  #     FileUtils.rm_r('src1', noop: true, verbose: true)
  #
  #   Output:
  #
  #     rm -r src0.dat src0.txt
  #     rm -r src1
  #
  # Related: {methods for deleting}[rdoc-ref:FileUtils@Deleting].
  #
  # source://fileutils//lib/fileutils.rb#1300
  def rm_r(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  # Equivalent to:
  #
  #   FileUtils.rm_r(list, force: true, **kwargs)
  #
  # Argument +list+ or its elements
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # May cause a local vulnerability if not called with keyword argument
  # <tt>secure: true</tt>;
  # see {Avoiding the TOCTTOU Vulnerability}[rdoc-ref:FileUtils@Avoiding+the+TOCTTOU+Vulnerability].
  #
  # See FileUtils.rm_r for keyword arguments.
  #
  # Related: {methods for deleting}[rdoc-ref:FileUtils@Deleting].
  #
  # source://fileutils//lib/fileutils.rb#1329
  def rm_rf(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  # Removes directories at the paths in the given +list+
  # (a single path or an array of paths);
  # returns +list+, if it is an array, <tt>[list]</tt> otherwise.
  #
  # Argument +list+ or its elements
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # With no keyword arguments, removes the directory at each +path+ in +list+,
  # by calling: <tt>Dir.rmdir(path)</tt>;
  # see {Dir.rmdir}[https://docs.ruby-lang.org/en/master/Dir.html#method-c-rmdir]:
  #
  #   FileUtils.rmdir(%w[tmp0/tmp1 tmp2/tmp3]) # => ["tmp0/tmp1", "tmp2/tmp3"]
  #   FileUtils.rmdir('tmp4/tmp5')             # => ["tmp4/tmp5"]
  #
  # Keyword arguments:
  #
  # - <tt>parents: true</tt> - removes successive ancestor directories
  #   if empty.
  # - <tt>noop: true</tt> - does not remove directories.
  # - <tt>verbose: true</tt> - prints an equivalent command:
  #
  #     FileUtils.rmdir(%w[tmp0/tmp1 tmp2/tmp3], parents: true, verbose: true)
  #     FileUtils.rmdir('tmp4/tmp5', parents: true, verbose: true)
  #
  #   Output:
  #
  #     rmdir -p tmp0/tmp1 tmp2/tmp3
  #     rmdir -p tmp4/tmp5
  #
  # Raises an exception if a directory does not exist
  # or if for any reason a directory cannot be removed.
  #
  # Related: {methods for deleting}[rdoc-ref:FileUtils@Deleting].
  #
  # source://fileutils//lib/fileutils.rb#443
  def rmdir(list, parents: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  # Equivalent to:
  #
  #   FileUtils.rm_r(list, force: true, **kwargs)
  #
  # Argument +list+ or its elements
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # May cause a local vulnerability if not called with keyword argument
  # <tt>secure: true</tt>;
  # see {Avoiding the TOCTTOU Vulnerability}[rdoc-ref:FileUtils@Avoiding+the+TOCTTOU+Vulnerability].
  #
  # See FileUtils.rm_r for keyword arguments.
  #
  # Related: {methods for deleting}[rdoc-ref:FileUtils@Deleting].
  #
  # source://fileutils//lib/fileutils.rb#1329
  def rmtree(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  # Equivalent to:
  #
  #   FileUtils.rm(list, force: true, **kwargs)
  #
  # Argument +list+ (a single path or an array of paths)
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # See FileUtils.rm for keyword arguments.
  #
  # Related: {methods for deleting}[rdoc-ref:FileUtils@Deleting].
  #
  # source://fileutils//lib/fileutils.rb#1242
  def safe_unlink(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  # source://fileutils//lib/fileutils.rb#1673
  def symbolic_modes_to_i(mode_sym, path); end

  # Creates {symbolic links}[https://en.wikipedia.org/wiki/Symbolic_link].
  #
  # Arguments +src+ (a single path or an array of paths)
  # and +dest+ (a single path)
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # If +src+ is the path to an existing file:
  #
  # - When +dest+ is the path to a non-existent file,
  #   creates a symbolic link at +dest+ pointing to +src+:
  #
  #     FileUtils.touch('src0.txt')
  #     File.exist?('dest0.txt')   # => false
  #     FileUtils.ln_s('src0.txt', 'dest0.txt')
  #     File.symlink?('dest0.txt') # => true
  #
  # - When +dest+ is the path to an existing file,
  #   creates a symbolic link at +dest+ pointing to +src+
  #   if and only if keyword argument <tt>force: true</tt> is given
  #   (raises an exception otherwise):
  #
  #     FileUtils.touch('src1.txt')
  #     FileUtils.touch('dest1.txt')
  #     FileUtils.ln_s('src1.txt', 'dest1.txt', force: true)
  #     FileTest.symlink?('dest1.txt') # => true
  #
  #     FileUtils.ln_s('src1.txt', 'dest1.txt') # Raises Errno::EEXIST.
  #
  # If +dest+ is the path to a directory,
  # creates a symbolic link at <tt>dest/src</tt> pointing to +src+:
  #
  #   FileUtils.touch('src2.txt')
  #   FileUtils.mkdir('destdir2')
  #   FileUtils.ln_s('src2.txt', 'destdir2')
  #   File.symlink?('destdir2/src2.txt') # => true
  #
  # If +src+ is an array of paths to existing files and +dest+ is a directory,
  # for each child +child+ in +src+ creates a symbolic link <tt>dest/child</tt>
  # pointing to +child+:
  #
  #   FileUtils.mkdir('srcdir3')
  #   FileUtils.touch('srcdir3/src0.txt')
  #   FileUtils.touch('srcdir3/src1.txt')
  #   FileUtils.mkdir('destdir3')
  #   FileUtils.ln_s(['srcdir3/src0.txt', 'srcdir3/src1.txt'], 'destdir3')
  #   File.symlink?('destdir3/src0.txt') # => true
  #   File.symlink?('destdir3/src1.txt') # => true
  #
  # Keyword arguments:
  #
  # - <tt>force: true</tt> - overwrites +dest+ if it exists.
  # - <tt>relative: false</tt> - create links relative to +dest+.
  # - <tt>noop: true</tt> - does not create links.
  # - <tt>verbose: true</tt> - prints an equivalent command:
  #
  #     FileUtils.ln_s('src0.txt', 'dest0.txt', noop: true, verbose: true)
  #     FileUtils.ln_s('src1.txt', 'destdir1', noop: true, verbose: true)
  #     FileUtils.ln_s('src2.txt', 'dest2.txt', force: true, noop: true, verbose: true)
  #     FileUtils.ln_s(['srcdir3/src0.txt', 'srcdir3/src1.txt'], 'destdir3', noop: true, verbose: true)
  #
  #   Output:
  #
  #     ln -s src0.txt dest0.txt
  #     ln -s src1.txt destdir1
  #     ln -sf src2.txt dest2.txt
  #     ln -s srcdir3/src0.txt srcdir3/src1.txt destdir3
  #
  # Related: FileUtils.ln_sf.
  #
  # source://fileutils//lib/fileutils.rb#707
  def symlink(src, dest, force: T.unsafe(nil), relative: T.unsafe(nil), target_directory: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  # Updates modification times (mtime) and access times (atime)
  # of the entries given by the paths in +list+
  # (a single path or an array of paths);
  # returns +list+ if it is an array, <tt>[list]</tt> otherwise.
  #
  # By default, creates an empty file for any path to a non-existent entry;
  # use keyword argument +nocreate+ to raise an exception instead.
  #
  # Argument +list+ or its elements
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
  #
  # Examples:
  #
  #   # Single path.
  #   f = File.new('src0.txt') # Existing file.
  #   f.atime # => 2022-06-10 11:11:21.200277 -0700
  #   f.mtime # => 2022-06-10 11:11:21.200277 -0700
  #   FileUtils.touch('src0.txt')
  #   f = File.new('src0.txt')
  #   f.atime # => 2022-06-11 08:28:09.8185343 -0700
  #   f.mtime # => 2022-06-11 08:28:09.8185343 -0700
  #
  #   # Array of paths.
  #   FileUtils.touch(['src0.txt', 'src0.dat'])
  #
  # Keyword arguments:
  #
  # - <tt>mtime: <i>time</i></tt> - sets the entry's mtime to the given time,
  #   instead of the current time.
  # - <tt>nocreate: true</tt> - raises an exception if the entry does not exist.
  # - <tt>noop: true</tt> - does not touch entries; returns +nil+.
  # - <tt>verbose: true</tt> - prints an equivalent command:
  #
  #     FileUtils.touch('src0.txt', noop: true, verbose: true)
  #     FileUtils.touch(['src0.txt', 'src0.dat'], noop: true, verbose: true)
  #     FileUtils.touch(path, noop: true, verbose: true)
  #
  #   Output:
  #
  #     touch src0.txt
  #     touch src0.txt src0.dat
  #     touch src0.txt
  #
  # Related: FileUtils.uptodate?.
  #
  # source://fileutils//lib/fileutils.rb#2007
  def touch(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), mtime: T.unsafe(nil), nocreate: T.unsafe(nil)); end

  # Returns +true+ if the file at path +new+
  # is newer than all the files at paths in array +old_list+;
  # +false+ otherwise.
  #
  # Argument +new+ and the elements of +old_list+
  # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments]:
  #
  #   FileUtils.uptodate?('Rakefile', ['Gemfile', 'README.md']) # => true
  #   FileUtils.uptodate?('Gemfile', ['Rakefile', 'README.md']) # => false
  #
  # A non-existent file is considered to be infinitely old.
  #
  # Related: FileUtils.touch.
  #
  # @return [Boolean]
  #
  # source://fileutils//lib/fileutils.rb#265
  def uptodate?(new, old_list); end

  # source://fileutils//lib/fileutils.rb#1643
  def user_mask(target); end

  class << self
    # Changes the working directory to the given +dir+, which
    # should be {interpretable as a path}[rdoc-ref:FileUtils@Path+Arguments]:
    #
    # With no block given,
    # changes the current directory to the directory at +dir+; returns zero:
    #
    #   FileUtils.pwd # => "/rdoc/fileutils"
    #   FileUtils.cd('..')
    #   FileUtils.pwd # => "/rdoc"
    #   FileUtils.cd('fileutils')
    #
    # With a block given, changes the current directory to the directory
    # at +dir+, calls the block with argument +dir+,
    # and restores the original current directory; returns the block's value:
    #
    #   FileUtils.pwd                                     # => "/rdoc/fileutils"
    #   FileUtils.cd('..') { |arg| [arg, FileUtils.pwd] } # => ["..", "/rdoc"]
    #   FileUtils.pwd                                     # => "/rdoc/fileutils"
    #
    # Keyword arguments:
    #
    # - <tt>verbose: true</tt> - prints an equivalent command:
    #
    #     FileUtils.cd('..')
    #     FileUtils.cd('fileutils')
    #
    #   Output:
    #
    #     cd ..
    #     cd fileutils
    #
    # Related: FileUtils.pwd.
    #
    # source://fileutils//lib/fileutils.rb#239
    def cd(dir, verbose: T.unsafe(nil), &block); end

    # Changes the working directory to the given +dir+, which
    # should be {interpretable as a path}[rdoc-ref:FileUtils@Path+Arguments]:
    #
    # With no block given,
    # changes the current directory to the directory at +dir+; returns zero:
    #
    #   FileUtils.pwd # => "/rdoc/fileutils"
    #   FileUtils.cd('..')
    #   FileUtils.pwd # => "/rdoc"
    #   FileUtils.cd('fileutils')
    #
    # With a block given, changes the current directory to the directory
    # at +dir+, calls the block with argument +dir+,
    # and restores the original current directory; returns the block's value:
    #
    #   FileUtils.pwd                                     # => "/rdoc/fileutils"
    #   FileUtils.cd('..') { |arg| [arg, FileUtils.pwd] } # => ["..", "/rdoc"]
    #   FileUtils.pwd                                     # => "/rdoc/fileutils"
    #
    # Keyword arguments:
    #
    # - <tt>verbose: true</tt> - prints an equivalent command:
    #
    #     FileUtils.cd('..')
    #     FileUtils.cd('fileutils')
    #
    #   Output:
    #
    #     cd ..
    #     cd fileutils
    #
    # Related: FileUtils.pwd.
    #
    # source://fileutils//lib/fileutils.rb#239
    def chdir(dir, verbose: T.unsafe(nil), &block); end

    # Changes permissions on the entries at the paths given in +list+
    # (a single path or an array of paths)
    # to the permissions given by +mode+;
    # returns +list+ if it is an array, <tt>[list]</tt> otherwise:
    #
    # - Modifies each entry that is a regular file using
    #   {File.chmod}[https://docs.ruby-lang.org/en/master/File.html#method-c-chmod].
    # - Modifies each entry that is a symbolic link using
    #   {File.lchmod}[https://docs.ruby-lang.org/en/master/File.html#method-c-lchmod].
    #
    # Argument +list+ or its elements
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # Argument +mode+ may be either an integer or a string:
    #
    # - \Integer +mode+: represents the permission bits to be set:
    #
    #     FileUtils.chmod(0755, 'src0.txt')
    #     FileUtils.chmod(0644, ['src0.txt', 'src0.dat'])
    #
    # - \String +mode+: represents the permissions to be set:
    #
    #   The string is of the form <tt>[targets][[operator][perms[,perms]]</tt>, where:
    #
    #   - +targets+ may be any combination of these letters:
    #
    #     - <tt>'u'</tt>: permissions apply to the file's owner.
    #     - <tt>'g'</tt>: permissions apply to users in the file's group.
    #     - <tt>'o'</tt>: permissions apply to other users not in the file's group.
    #     - <tt>'a'</tt> (the default): permissions apply to all users.
    #
    #   - +operator+ may be one of these letters:
    #
    #     - <tt>'+'</tt>: adds permissions.
    #     - <tt>'-'</tt>: removes permissions.
    #     - <tt>'='</tt>: sets (replaces) permissions.
    #
    #   - +perms+ (may be repeated, with separating commas)
    #     may be any combination of these letters:
    #
    #     - <tt>'r'</tt>: Read.
    #     - <tt>'w'</tt>: Write.
    #     - <tt>'x'</tt>: Execute (search, for a directory).
    #     - <tt>'X'</tt>: Search (for a directories only;
    #       must be used with <tt>'+'</tt>)
    #     - <tt>'s'</tt>: Uid or gid.
    #     - <tt>'t'</tt>: Sticky bit.
    #
    #   Examples:
    #
    #     FileUtils.chmod('u=wrx,go=rx', 'src1.txt')
    #     FileUtils.chmod('u=wrx,go=rx', '/usr/bin/ruby')
    #
    # Keyword arguments:
    #
    # - <tt>noop: true</tt> - does not change permissions; returns +nil+.
    # - <tt>verbose: true</tt> - prints an equivalent command:
    #
    #     FileUtils.chmod(0755, 'src0.txt', noop: true, verbose: true)
    #     FileUtils.chmod(0644, ['src0.txt', 'src0.dat'], noop: true, verbose: true)
    #     FileUtils.chmod('u=wrx,go=rx', 'src1.txt', noop: true, verbose: true)
    #     FileUtils.chmod('u=wrx,go=rx', '/usr/bin/ruby', noop: true, verbose: true)
    #
    #   Output:
    #
    #     chmod 755 src0.txt
    #     chmod 644 src0.txt src0.dat
    #     chmod u=wrx,go=rx src1.txt
    #     chmod u=wrx,go=rx /usr/bin/ruby
    #
    # Related: FileUtils.chmod_R.
    #
    # source://fileutils//lib/fileutils.rb#1804
    def chmod(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

    # Like FileUtils.chmod, but changes permissions recursively.
    #
    # source://fileutils//lib/fileutils.rb#1816
    def chmod_R(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end

    # Changes the owner and group on the entries at the paths given in +list+
    # (a single path or an array of paths)
    # to the given +user+ and +group+;
    # returns +list+ if it is an array, <tt>[list]</tt> otherwise:
    #
    # - Modifies each entry that is a regular file using
    #   {File.chown}[https://docs.ruby-lang.org/en/master/File.html#method-c-chown].
    # - Modifies each entry that is a symbolic link using
    #   {File.lchown}[https://docs.ruby-lang.org/en/master/File.html#method-c-lchown].
    #
    # Argument +list+ or its elements
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # User and group:
    #
    # - Argument +user+ may be a user name or a user id;
    #   if +nil+ or +-1+, the user is not changed.
    # - Argument +group+ may be a group name or a group id;
    #   if +nil+ or +-1+, the group is not changed.
    # - The user must be a member of the group.
    #
    # Examples:
    #
    #   # One path.
    #   # User and group as string names.
    #   File.stat('src0.txt').uid # => 1004
    #   File.stat('src0.txt').gid # => 1004
    #   FileUtils.chown('user2', 'group1', 'src0.txt')
    #   File.stat('src0.txt').uid # => 1006
    #   File.stat('src0.txt').gid # => 1005
    #
    #   # User and group as uid and gid.
    #   FileUtils.chown(1004, 1004, 'src0.txt')
    #   File.stat('src0.txt').uid # => 1004
    #   File.stat('src0.txt').gid # => 1004
    #
    #   # Array of paths.
    #   FileUtils.chown(1006, 1005, ['src0.txt', 'src0.dat'])
    #
    #   # Directory (not recursive).
    #   FileUtils.chown('user2', 'group1', '.')
    #
    # Keyword arguments:
    #
    # - <tt>noop: true</tt> - does not change permissions; returns +nil+.
    # - <tt>verbose: true</tt> - prints an equivalent command:
    #
    #     FileUtils.chown('user2', 'group1', 'src0.txt', noop: true, verbose: true)
    #     FileUtils.chown(1004, 1004, 'src0.txt', noop: true, verbose: true)
    #     FileUtils.chown(1006, 1005, ['src0.txt', 'src0.dat'], noop: true, verbose: true)
    #     FileUtils.chown('user2', 'group1', path, noop: true, verbose: true)
    #     FileUtils.chown('user2', 'group1', '.', noop: true, verbose: true)
    #
    #   Output:
    #
    #     chown user2:group1 src0.txt
    #     chown 1004:1004 src0.txt
    #     chown 1006:1005 src0.txt src0.dat
    #     chown user2:group1 src0.txt
    #     chown user2:group1 .
    #
    # Related: FileUtils.chown_R.
    #
    # source://fileutils//lib/fileutils.rb#1897
    def chown(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

    # Like FileUtils.chown, but changes owner and group recursively.
    #
    # source://fileutils//lib/fileutils.rb#1913
    def chown_R(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end

    # Returns +true+ if the contents of files +a+ and +b+ are identical,
    # +false+ otherwise.
    #
    # Arguments +a+ and +b+
    # should be {interpretable as a path}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # FileUtils.identical? and FileUtils.cmp are aliases for FileUtils.compare_file.
    #
    # Related: FileUtils.compare_stream.
    #
    # source://fileutils//lib/fileutils.rb#1508
    def cmp(a, b); end

    # Returns an array of the string method names of the methods
    # that accept the given keyword option +opt+;
    # the argument must be a symbol:
    #
    #   FileUtils.collect_method(:preserve) # => ["cp", "copy", "cp_r", "install"]
    #
    # source://fileutils//lib/fileutils.rb#2611
    def collect_method(opt); end

    # Returns an array of the string names of \FileUtils methods
    # that accept one or more keyword arguments:
    #
    #   FileUtils.commands.sort.take(3) # => ["cd", "chdir", "chmod"]
    #
    # source://fileutils//lib/fileutils.rb#2572
    def commands; end

    # Returns +true+ if the contents of files +a+ and +b+ are identical,
    # +false+ otherwise.
    #
    # Arguments +a+ and +b+
    # should be {interpretable as a path}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # FileUtils.identical? and FileUtils.cmp are aliases for FileUtils.compare_file.
    #
    # Related: FileUtils.compare_stream.
    #
    # source://fileutils//lib/fileutils.rb#1508
    def compare_file(a, b); end

    # Returns +true+ if the contents of streams +a+ and +b+ are identical,
    # +false+ otherwise.
    #
    # Arguments +a+ and +b+
    # should be {interpretable as a path}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # Related: FileUtils.compare_file.
    #
    # source://fileutils//lib/fileutils.rb#1531
    def compare_stream(a, b); end

    # Copies files.
    #
    # Arguments +src+ (a single path or an array of paths)
    # and +dest+ (a single path)
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # If +src+ is the path to a file and +dest+ is not the path to a directory,
    # copies +src+ to +dest+:
    #
    #   FileUtils.touch('src0.txt')
    #   File.exist?('dest0.txt') # => false
    #   FileUtils.cp('src0.txt', 'dest0.txt')
    #   File.file?('dest0.txt')  # => true
    #
    # If +src+ is the path to a file and +dest+ is the path to a directory,
    # copies +src+ to <tt>dest/src</tt>:
    #
    #   FileUtils.touch('src1.txt')
    #   FileUtils.mkdir('dest1')
    #   FileUtils.cp('src1.txt', 'dest1')
    #   File.file?('dest1/src1.txt') # => true
    #
    # If +src+ is an array of paths to files and +dest+ is the path to a directory,
    # copies from each +src+ to +dest+:
    #
    #   src_file_paths = ['src2.txt', 'src2.dat']
    #   FileUtils.touch(src_file_paths)
    #   FileUtils.mkdir('dest2')
    #   FileUtils.cp(src_file_paths, 'dest2')
    #   File.file?('dest2/src2.txt') # => true
    #   File.file?('dest2/src2.dat') # => true
    #
    # Keyword arguments:
    #
    # - <tt>preserve: true</tt> - preserves file times.
    # - <tt>noop: true</tt> - does not copy files.
    # - <tt>verbose: true</tt> - prints an equivalent command:
    #
    #     FileUtils.cp('src0.txt', 'dest0.txt', noop: true, verbose: true)
    #     FileUtils.cp('src1.txt', 'dest1', noop: true, verbose: true)
    #     FileUtils.cp(src_file_paths, 'dest2', noop: true, verbose: true)
    #
    #   Output:
    #
    #     cp src0.txt dest0.txt
    #     cp src1.txt dest1
    #     cp src2.txt src2.dat dest2
    #
    # Raises an exception if +src+ is a directory.
    #
    # Related: {methods for copying}[rdoc-ref:FileUtils@Copying].
    #
    # source://fileutils//lib/fileutils.rb#874
    def copy(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

    # Recursively copies files from +src+ to +dest+.
    #
    # Arguments +src+ and +dest+
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # If +src+ is the path to a file, copies +src+ to +dest+:
    #
    #   FileUtils.touch('src0.txt')
    #   File.exist?('dest0.txt') # => false
    #   FileUtils.copy_entry('src0.txt', 'dest0.txt')
    #   File.file?('dest0.txt')  # => true
    #
    # If +src+ is a directory, recursively copies +src+ to +dest+:
    #
    #   tree('src1')
    #   # => src1
    #   #    |-- dir0
    #   #    |   |-- src0.txt
    #   #    |   `-- src1.txt
    #   #    `-- dir1
    #   #        |-- src2.txt
    #   #        `-- src3.txt
    #   FileUtils.copy_entry('src1', 'dest1')
    #   tree('dest1')
    #   # => dest1
    #   #    |-- dir0
    #   #    |   |-- src0.txt
    #   #    |   `-- src1.txt
    #   #    `-- dir1
    #   #        |-- src2.txt
    #   #        `-- src3.txt
    #
    # The recursive copying preserves file types for regular files,
    # directories, and symbolic links;
    # other file types (FIFO streams, device files, etc.) are not supported.
    #
    # Keyword arguments:
    #
    # - <tt>dereference_root: true</tt> - if +src+ is a symbolic link,
    #   follows the link.
    # - <tt>preserve: true</tt> - preserves file times.
    # - <tt>remove_destination: true</tt> - removes +dest+ before copying files.
    #
    # Related: {methods for copying}[rdoc-ref:FileUtils@Copying].
    #
    # source://fileutils//lib/fileutils.rb#1041
    def copy_entry(src, dest, preserve = T.unsafe(nil), dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end

    # Copies file from +src+ to +dest+, which should not be directories.
    #
    # Arguments +src+ and +dest+
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # Examples:
    #
    #   FileUtils.touch('src0.txt')
    #   FileUtils.copy_file('src0.txt', 'dest0.txt')
    #   File.file?('dest0.txt') # => true
    #
    # Keyword arguments:
    #
    # - <tt>dereference: false</tt> - if +src+ is a symbolic link,
    #   does not follow the link.
    # - <tt>preserve: true</tt> - preserves file times.
    # - <tt>remove_destination: true</tt> - removes +dest+ before copying files.
    #
    # Related: {methods for copying}[rdoc-ref:FileUtils@Copying].
    #
    # source://fileutils//lib/fileutils.rb#1077
    def copy_file(src, dest, preserve = T.unsafe(nil), dereference = T.unsafe(nil)); end

    # Copies \IO stream +src+ to \IO stream +dest+ via
    # {IO.copy_stream}[https://docs.ruby-lang.org/en/master/IO.html#method-c-copy_stream].
    #
    # Related: {methods for copying}[rdoc-ref:FileUtils@Copying].
    #
    # source://fileutils//lib/fileutils.rb#1089
    def copy_stream(src, dest); end

    # Copies files.
    #
    # Arguments +src+ (a single path or an array of paths)
    # and +dest+ (a single path)
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # If +src+ is the path to a file and +dest+ is not the path to a directory,
    # copies +src+ to +dest+:
    #
    #   FileUtils.touch('src0.txt')
    #   File.exist?('dest0.txt') # => false
    #   FileUtils.cp('src0.txt', 'dest0.txt')
    #   File.file?('dest0.txt')  # => true
    #
    # If +src+ is the path to a file and +dest+ is the path to a directory,
    # copies +src+ to <tt>dest/src</tt>:
    #
    #   FileUtils.touch('src1.txt')
    #   FileUtils.mkdir('dest1')
    #   FileUtils.cp('src1.txt', 'dest1')
    #   File.file?('dest1/src1.txt') # => true
    #
    # If +src+ is an array of paths to files and +dest+ is the path to a directory,
    # copies from each +src+ to +dest+:
    #
    #   src_file_paths = ['src2.txt', 'src2.dat']
    #   FileUtils.touch(src_file_paths)
    #   FileUtils.mkdir('dest2')
    #   FileUtils.cp(src_file_paths, 'dest2')
    #   File.file?('dest2/src2.txt') # => true
    #   File.file?('dest2/src2.dat') # => true
    #
    # Keyword arguments:
    #
    # - <tt>preserve: true</tt> - preserves file times.
    # - <tt>noop: true</tt> - does not copy files.
    # - <tt>verbose: true</tt> - prints an equivalent command:
    #
    #     FileUtils.cp('src0.txt', 'dest0.txt', noop: true, verbose: true)
    #     FileUtils.cp('src1.txt', 'dest1', noop: true, verbose: true)
    #     FileUtils.cp(src_file_paths, 'dest2', noop: true, verbose: true)
    #
    #   Output:
    #
    #     cp src0.txt dest0.txt
    #     cp src1.txt dest1
    #     cp src2.txt src2.dat dest2
    #
    # Raises an exception if +src+ is a directory.
    #
    # Related: {methods for copying}[rdoc-ref:FileUtils@Copying].
    #
    # source://fileutils//lib/fileutils.rb#874
    def cp(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

    # Creates {hard links}[https://en.wikipedia.org/wiki/Hard_link].
    #
    # Arguments +src+ (a single path or an array of paths)
    # and +dest+ (a single path)
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # If +src+ is the path to a directory and +dest+ does not exist,
    # creates links +dest+ and descendents pointing to +src+ and its descendents:
    #
    #   tree('src0')
    #   # => src0
    #   #    |-- sub0
    #   #    |   |-- src0.txt
    #   #    |   `-- src1.txt
    #   #    `-- sub1
    #   #        |-- src2.txt
    #   #        `-- src3.txt
    #   File.exist?('dest0') # => false
    #   FileUtils.cp_lr('src0', 'dest0')
    #   tree('dest0')
    #   # => dest0
    #   #    |-- sub0
    #   #    |   |-- src0.txt
    #   #    |   `-- src1.txt
    #   #    `-- sub1
    #   #        |-- src2.txt
    #   #        `-- src3.txt
    #
    # If +src+ and +dest+ are both paths to directories,
    # creates links <tt>dest/src</tt> and descendents
    # pointing to +src+ and its descendents:
    #
    #   tree('src1')
    #   # => src1
    #   #    |-- sub0
    #   #    |   |-- src0.txt
    #   #    |   `-- src1.txt
    #   #    `-- sub1
    #   #        |-- src2.txt
    #   #        `-- src3.txt
    #   FileUtils.mkdir('dest1')
    #   FileUtils.cp_lr('src1', 'dest1')
    #   tree('dest1')
    #   # => dest1
    #   #    `-- src1
    #   #        |-- sub0
    #   #        |   |-- src0.txt
    #   #        |   `-- src1.txt
    #   #        `-- sub1
    #   #            |-- src2.txt
    #   #            `-- src3.txt
    #
    # If +src+ is an array of paths to entries and +dest+ is the path to a directory,
    # for each path +filepath+ in +src+, creates a link at <tt>dest/filepath</tt>
    # pointing to that path:
    #
    #   tree('src2')
    #   # => src2
    #   #    |-- sub0
    #   #    |   |-- src0.txt
    #   #    |   `-- src1.txt
    #   #    `-- sub1
    #   #        |-- src2.txt
    #   #        `-- src3.txt
    #   FileUtils.mkdir('dest2')
    #   FileUtils.cp_lr(['src2/sub0', 'src2/sub1'], 'dest2')
    #   tree('dest2')
    #   # => dest2
    #   #    |-- sub0
    #   #    |   |-- src0.txt
    #   #    |   `-- src1.txt
    #   #    `-- sub1
    #   #        |-- src2.txt
    #   #        `-- src3.txt
    #
    # Keyword arguments:
    #
    # - <tt>dereference_root: false</tt> - if +src+ is a symbolic link,
    #   does not dereference it.
    # - <tt>noop: true</tt> - does not create links.
    # - <tt>remove_destination: true</tt> - removes +dest+ before creating links.
    # - <tt>verbose: true</tt> - prints an equivalent command:
    #
    #     FileUtils.cp_lr('src0', 'dest0', noop: true, verbose: true)
    #     FileUtils.cp_lr('src1', 'dest1', noop: true, verbose: true)
    #     FileUtils.cp_lr(['src2/sub0', 'src2/sub1'], 'dest2', noop: true, verbose: true)
    #
    #   Output:
    #
    #     cp -lr src0 dest0
    #     cp -lr src1 dest1
    #     cp -lr src2/sub0 src2/sub1 dest2
    #
    # Raises an exception if +dest+ is the path to an existing file or directory
    # and keyword argument <tt>remove_destination: true</tt> is not given.
    #
    # Related: {methods for copying}[rdoc-ref:FileUtils@Copying].
    #
    # source://fileutils//lib/fileutils.rb#628
    def cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

    # Recursively copies files.
    #
    # Arguments +src+ (a single path or an array of paths)
    # and +dest+ (a single path)
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # The mode, owner, and group are retained in the copy;
    # to change those, use FileUtils.install instead.
    #
    # If +src+ is the path to a file and +dest+ is not the path to a directory,
    # copies +src+ to +dest+:
    #
    #   FileUtils.touch('src0.txt')
    #   File.exist?('dest0.txt') # => false
    #   FileUtils.cp_r('src0.txt', 'dest0.txt')
    #   File.file?('dest0.txt')  # => true
    #
    # If +src+ is the path to a file and +dest+ is the path to a directory,
    # copies +src+ to <tt>dest/src</tt>:
    #
    #   FileUtils.touch('src1.txt')
    #   FileUtils.mkdir('dest1')
    #   FileUtils.cp_r('src1.txt', 'dest1')
    #   File.file?('dest1/src1.txt') # => true
    #
    # If +src+ is the path to a directory and +dest+ does not exist,
    # recursively copies +src+ to +dest+:
    #
    #   tree('src2')
    #   # => src2
    #   #    |-- dir0
    #   #    |   |-- src0.txt
    #   #    |   `-- src1.txt
    #   #    `-- dir1
    #   #    |-- src2.txt
    #   #    `-- src3.txt
    #   FileUtils.exist?('dest2') # => false
    #   FileUtils.cp_r('src2', 'dest2')
    #   tree('dest2')
    #   # => dest2
    #   #    |-- dir0
    #   #    |   |-- src0.txt
    #   #    |   `-- src1.txt
    #   #    `-- dir1
    #   #    |-- src2.txt
    #   #    `-- src3.txt
    #
    # If +src+ and +dest+ are paths to directories,
    # recursively copies +src+ to <tt>dest/src</tt>:
    #
    #   tree('src3')
    #   # => src3
    #   #    |-- dir0
    #   #    |   |-- src0.txt
    #   #    |   `-- src1.txt
    #   #    `-- dir1
    #   #    |-- src2.txt
    #   #    `-- src3.txt
    #   FileUtils.mkdir('dest3')
    #   FileUtils.cp_r('src3', 'dest3')
    #   tree('dest3')
    #   # => dest3
    #   #    `-- src3
    #   #      |-- dir0
    #   #      |   |-- src0.txt
    #   #      |   `-- src1.txt
    #   #      `-- dir1
    #   #          |-- src2.txt
    #   #          `-- src3.txt
    #
    # If +src+ is an array of paths and +dest+ is a directory,
    # recursively copies from each path in +src+ to +dest+;
    # the paths in +src+ may point to files and/or directories.
    #
    # Keyword arguments:
    #
    # - <tt>dereference_root: false</tt> - if +src+ is a symbolic link,
    #   does not dereference it.
    # - <tt>noop: true</tt> - does not copy files.
    # - <tt>preserve: true</tt> - preserves file times.
    # - <tt>remove_destination: true</tt> - removes +dest+ before copying files.
    # - <tt>verbose: true</tt> - prints an equivalent command:
    #
    #     FileUtils.cp_r('src0.txt', 'dest0.txt', noop: true, verbose: true)
    #     FileUtils.cp_r('src1.txt', 'dest1', noop: true, verbose: true)
    #     FileUtils.cp_r('src2', 'dest2', noop: true, verbose: true)
    #     FileUtils.cp_r('src3', 'dest3', noop: true, verbose: true)
    #
    #   Output:
    #
    #     cp -r src0.txt dest0.txt
    #     cp -r src1.txt dest1
    #     cp -r src2 dest2
    #     cp -r src3 dest3
    #
    # Raises an exception of +src+ is the path to a directory
    # and +dest+ is the path to a file.
    #
    # Related: {methods for copying}[rdoc-ref:FileUtils@Copying].
    #
    # source://fileutils//lib/fileutils.rb#986
    def cp_r(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

    # Returns a string containing the path to the current directory:
    #
    #   FileUtils.pwd # => "/rdoc/fileutils"
    #
    # Related: FileUtils.cd.
    #
    # source://fileutils//lib/fileutils.rb#198
    def getwd; end

    # Returns +true+ if method +mid+ accepts the given option +opt+, +false+ otherwise;
    # the arguments may be strings or symbols:
    #
    #   FileUtils.have_option?(:chmod, :noop) # => true
    #   FileUtils.have_option?('chmod', 'secure') # => false
    #
    # @return [Boolean]
    #
    # source://fileutils//lib/fileutils.rb#2590
    def have_option?(mid, opt); end

    # Returns +true+ if the contents of files +a+ and +b+ are identical,
    # +false+ otherwise.
    #
    # Arguments +a+ and +b+
    # should be {interpretable as a path}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # FileUtils.identical? and FileUtils.cmp are aliases for FileUtils.compare_file.
    #
    # Related: FileUtils.compare_stream.
    #
    # source://fileutils//lib/fileutils.rb#1508
    def identical?(a, b); end

    # Copies a file entry.
    # See {install(1)}[https://man7.org/linux/man-pages/man1/install.1.html].
    #
    # Arguments +src+ (a single path or an array of paths)
    # and +dest+ (a single path)
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments];
    #
    # If the entry at +dest+ does not exist, copies from +src+ to +dest+:
    #
    #   File.read('src0.txt')    # => "aaa\n"
    #   File.exist?('dest0.txt') # => false
    #   FileUtils.install('src0.txt', 'dest0.txt')
    #   File.read('dest0.txt')   # => "aaa\n"
    #
    # If +dest+ is a file entry, copies from +src+ to +dest+, overwriting:
    #
    #   File.read('src1.txt')  # => "aaa\n"
    #   File.read('dest1.txt') # => "bbb\n"
    #   FileUtils.install('src1.txt', 'dest1.txt')
    #   File.read('dest1.txt') # => "aaa\n"
    #
    # If +dest+ is a directory entry, copies from +src+ to <tt>dest/src</tt>,
    # overwriting if necessary:
    #
    #   File.read('src2.txt')       # => "aaa\n"
    #   File.read('dest2/src2.txt') # => "bbb\n"
    #   FileUtils.install('src2.txt', 'dest2')
    #   File.read('dest2/src2.txt') # => "aaa\n"
    #
    # If +src+ is an array of paths and +dest+ points to a directory,
    # copies each path +path+ in +src+ to <tt>dest/path</tt>:
    #
    #   File.file?('src3.txt') # => true
    #   File.file?('src3.dat') # => true
    #   FileUtils.mkdir('dest3')
    #   FileUtils.install(['src3.txt', 'src3.dat'], 'dest3')
    #   File.file?('dest3/src3.txt') # => true
    #   File.file?('dest3/src3.dat') # => true
    #
    # Keyword arguments:
    #
    # - <tt>group: <i>group</i></tt> - changes the group if not +nil+,
    #   using {File.chown}[https://docs.ruby-lang.org/en/master/File.html#method-c-chown].
    # - <tt>mode: <i>permissions</i></tt> - changes the permissions.
    #   using {File.chmod}[https://docs.ruby-lang.org/en/master/File.html#method-c-chmod].
    # - <tt>noop: true</tt> - does not copy entries; returns +nil+.
    # - <tt>owner: <i>owner</i></tt> - changes the owner if not +nil+,
    #   using {File.chown}[https://docs.ruby-lang.org/en/master/File.html#method-c-chown].
    # - <tt>preserve: true</tt> - preserve timestamps
    #   using {File.utime}[https://docs.ruby-lang.org/en/master/File.html#method-c-utime].
    # - <tt>verbose: true</tt> - prints an equivalent command:
    #
    #     FileUtils.install('src0.txt', 'dest0.txt', noop: true, verbose: true)
    #     FileUtils.install('src1.txt', 'dest1.txt', noop: true, verbose: true)
    #     FileUtils.install('src2.txt', 'dest2', noop: true, verbose: true)
    #
    #   Output:
    #
    #     install -c src0.txt dest0.txt
    #     install -c src1.txt dest1.txt
    #     install -c src2.txt dest2
    #
    # Related: {methods for copying}[rdoc-ref:FileUtils@Copying].
    #
    # source://fileutils//lib/fileutils.rb#1610
    def install(src, dest, mode: T.unsafe(nil), owner: T.unsafe(nil), group: T.unsafe(nil), preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

    # Creates {hard links}[https://en.wikipedia.org/wiki/Hard_link].
    #
    # Arguments +src+ (a single path or an array of paths)
    # and +dest+ (a single path)
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # When +src+ is the path to an existing file
    # and +dest+ is the path to a non-existent file,
    # creates a hard link at +dest+ pointing to +src+; returns zero:
    #
    #   Dir.children('tmp0/')                    # => ["t.txt"]
    #   Dir.children('tmp1/')                    # => []
    #   FileUtils.ln('tmp0/t.txt', 'tmp1/t.lnk') # => 0
    #   Dir.children('tmp1/')                    # => ["t.lnk"]
    #
    # When +src+ is the path to an existing file
    # and +dest+ is the path to an existing directory,
    # creates a hard link at <tt>dest/src</tt> pointing to +src+; returns zero:
    #
    #   Dir.children('tmp2')               # => ["t.dat"]
    #   Dir.children('tmp3')               # => []
    #   FileUtils.ln('tmp2/t.dat', 'tmp3') # => 0
    #   Dir.children('tmp3')               # => ["t.dat"]
    #
    # When +src+ is an array of paths to existing files
    # and +dest+ is the path to an existing directory,
    # then for each path +target+ in +src+,
    # creates a hard link at <tt>dest/target</tt> pointing to +target+;
    # returns +src+:
    #
    #   Dir.children('tmp4/')                               # => []
    #   FileUtils.ln(['tmp0/t.txt', 'tmp2/t.dat'], 'tmp4/') # => ["tmp0/t.txt", "tmp2/t.dat"]
    #   Dir.children('tmp4/')                               # => ["t.dat", "t.txt"]
    #
    # Keyword arguments:
    #
    # - <tt>force: true</tt> - overwrites +dest+ if it exists.
    # - <tt>noop: true</tt> - does not create links.
    # - <tt>verbose: true</tt> - prints an equivalent command:
    #
    #     FileUtils.ln('tmp0/t.txt', 'tmp1/t.lnk', verbose: true)
    #     FileUtils.ln('tmp2/t.dat', 'tmp3', verbose: true)
    #     FileUtils.ln(['tmp0/t.txt', 'tmp2/t.dat'], 'tmp4/', verbose: true)
    #
    #   Output:
    #
    #     ln tmp0/t.txt tmp1/t.lnk
    #     ln tmp2/t.dat tmp3
    #     ln tmp0/t.txt tmp2/t.dat tmp4/
    #
    # Raises an exception if +dest+ is the path to an existing file
    # and keyword argument +force+ is not +true+.
    #
    # Related: FileUtils.link_entry (has different options).
    #
    # source://fileutils//lib/fileutils.rb#517
    def link(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

    # Creates {hard links}[https://en.wikipedia.org/wiki/Hard_link]; returns +nil+.
    #
    # Arguments +src+ and +dest+
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # If +src+ is the path to a file and +dest+ does not exist,
    # creates a hard link at +dest+ pointing to +src+:
    #
    #   FileUtils.touch('src0.txt')
    #   File.exist?('dest0.txt') # => false
    #   FileUtils.link_entry('src0.txt', 'dest0.txt')
    #   File.file?('dest0.txt')  # => true
    #
    # If +src+ is the path to a directory and +dest+ does not exist,
    # recursively creates hard links at +dest+ pointing to paths in +src+:
    #
    #   FileUtils.mkdir_p(['src1/dir0', 'src1/dir1'])
    #   src_file_paths = [
    #     'src1/dir0/t0.txt',
    #     'src1/dir0/t1.txt',
    #     'src1/dir1/t2.txt',
    #     'src1/dir1/t3.txt',
    #     ]
    #   FileUtils.touch(src_file_paths)
    #   File.directory?('dest1')        # => true
    #   FileUtils.link_entry('src1', 'dest1')
    #   File.file?('dest1/dir0/t0.txt') # => true
    #   File.file?('dest1/dir0/t1.txt') # => true
    #   File.file?('dest1/dir1/t2.txt') # => true
    #   File.file?('dest1/dir1/t3.txt') # => true
    #
    # Keyword arguments:
    #
    # - <tt>dereference_root: true</tt> - dereferences +src+ if it is a symbolic link.
    # - <tt>remove_destination: true</tt> - removes +dest+ before creating links.
    #
    # Raises an exception if +dest+ is the path to an existing file or directory
    # and keyword argument <tt>remove_destination: true</tt> is not given.
    #
    # Related: FileUtils.ln (has different options).
    #
    # source://fileutils//lib/fileutils.rb#813
    def link_entry(src, dest, dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end

    # Creates {hard links}[https://en.wikipedia.org/wiki/Hard_link].
    #
    # Arguments +src+ (a single path or an array of paths)
    # and +dest+ (a single path)
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # When +src+ is the path to an existing file
    # and +dest+ is the path to a non-existent file,
    # creates a hard link at +dest+ pointing to +src+; returns zero:
    #
    #   Dir.children('tmp0/')                    # => ["t.txt"]
    #   Dir.children('tmp1/')                    # => []
    #   FileUtils.ln('tmp0/t.txt', 'tmp1/t.lnk') # => 0
    #   Dir.children('tmp1/')                    # => ["t.lnk"]
    #
    # When +src+ is the path to an existing file
    # and +dest+ is the path to an existing directory,
    # creates a hard link at <tt>dest/src</tt> pointing to +src+; returns zero:
    #
    #   Dir.children('tmp2')               # => ["t.dat"]
    #   Dir.children('tmp3')               # => []
    #   FileUtils.ln('tmp2/t.dat', 'tmp3') # => 0
    #   Dir.children('tmp3')               # => ["t.dat"]
    #
    # When +src+ is an array of paths to existing files
    # and +dest+ is the path to an existing directory,
    # then for each path +target+ in +src+,
    # creates a hard link at <tt>dest/target</tt> pointing to +target+;
    # returns +src+:
    #
    #   Dir.children('tmp4/')                               # => []
    #   FileUtils.ln(['tmp0/t.txt', 'tmp2/t.dat'], 'tmp4/') # => ["tmp0/t.txt", "tmp2/t.dat"]
    #   Dir.children('tmp4/')                               # => ["t.dat", "t.txt"]
    #
    # Keyword arguments:
    #
    # - <tt>force: true</tt> - overwrites +dest+ if it exists.
    # - <tt>noop: true</tt> - does not create links.
    # - <tt>verbose: true</tt> - prints an equivalent command:
    #
    #     FileUtils.ln('tmp0/t.txt', 'tmp1/t.lnk', verbose: true)
    #     FileUtils.ln('tmp2/t.dat', 'tmp3', verbose: true)
    #     FileUtils.ln(['tmp0/t.txt', 'tmp2/t.dat'], 'tmp4/', verbose: true)
    #
    #   Output:
    #
    #     ln tmp0/t.txt tmp1/t.lnk
    #     ln tmp2/t.dat tmp3
    #     ln tmp0/t.txt tmp2/t.dat tmp4/
    #
    # Raises an exception if +dest+ is the path to an existing file
    # and keyword argument +force+ is not +true+.
    #
    # Related: FileUtils.link_entry (has different options).
    #
    # source://fileutils//lib/fileutils.rb#517
    def ln(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

    # Creates {symbolic links}[https://en.wikipedia.org/wiki/Symbolic_link].
    #
    # Arguments +src+ (a single path or an array of paths)
    # and +dest+ (a single path)
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # If +src+ is the path to an existing file:
    #
    # - When +dest+ is the path to a non-existent file,
    #   creates a symbolic link at +dest+ pointing to +src+:
    #
    #     FileUtils.touch('src0.txt')
    #     File.exist?('dest0.txt')   # => false
    #     FileUtils.ln_s('src0.txt', 'dest0.txt')
    #     File.symlink?('dest0.txt') # => true
    #
    # - When +dest+ is the path to an existing file,
    #   creates a symbolic link at +dest+ pointing to +src+
    #   if and only if keyword argument <tt>force: true</tt> is given
    #   (raises an exception otherwise):
    #
    #     FileUtils.touch('src1.txt')
    #     FileUtils.touch('dest1.txt')
    #     FileUtils.ln_s('src1.txt', 'dest1.txt', force: true)
    #     FileTest.symlink?('dest1.txt') # => true
    #
    #     FileUtils.ln_s('src1.txt', 'dest1.txt') # Raises Errno::EEXIST.
    #
    # If +dest+ is the path to a directory,
    # creates a symbolic link at <tt>dest/src</tt> pointing to +src+:
    #
    #   FileUtils.touch('src2.txt')
    #   FileUtils.mkdir('destdir2')
    #   FileUtils.ln_s('src2.txt', 'destdir2')
    #   File.symlink?('destdir2/src2.txt') # => true
    #
    # If +src+ is an array of paths to existing files and +dest+ is a directory,
    # for each child +child+ in +src+ creates a symbolic link <tt>dest/child</tt>
    # pointing to +child+:
    #
    #   FileUtils.mkdir('srcdir3')
    #   FileUtils.touch('srcdir3/src0.txt')
    #   FileUtils.touch('srcdir3/src1.txt')
    #   FileUtils.mkdir('destdir3')
    #   FileUtils.ln_s(['srcdir3/src0.txt', 'srcdir3/src1.txt'], 'destdir3')
    #   File.symlink?('destdir3/src0.txt') # => true
    #   File.symlink?('destdir3/src1.txt') # => true
    #
    # Keyword arguments:
    #
    # - <tt>force: true</tt> - overwrites +dest+ if it exists.
    # - <tt>relative: false</tt> - create links relative to +dest+.
    # - <tt>noop: true</tt> - does not create links.
    # - <tt>verbose: true</tt> - prints an equivalent command:
    #
    #     FileUtils.ln_s('src0.txt', 'dest0.txt', noop: true, verbose: true)
    #     FileUtils.ln_s('src1.txt', 'destdir1', noop: true, verbose: true)
    #     FileUtils.ln_s('src2.txt', 'dest2.txt', force: true, noop: true, verbose: true)
    #     FileUtils.ln_s(['srcdir3/src0.txt', 'srcdir3/src1.txt'], 'destdir3', noop: true, verbose: true)
    #
    #   Output:
    #
    #     ln -s src0.txt dest0.txt
    #     ln -s src1.txt destdir1
    #     ln -sf src2.txt dest2.txt
    #     ln -s srcdir3/src0.txt srcdir3/src1.txt destdir3
    #
    # Related: FileUtils.ln_sf.
    #
    # source://fileutils//lib/fileutils.rb#707
    def ln_s(src, dest, force: T.unsafe(nil), relative: T.unsafe(nil), target_directory: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

    # Like FileUtils.ln_s, but always with keyword argument <tt>force: true</tt> given.
    #
    # source://fileutils//lib/fileutils.rb#725
    def ln_sf(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

    # Like FileUtils.ln_s, but create links relative to +dest+.
    #
    # source://fileutils//lib/fileutils.rb#732
    def ln_sr(src, dest, target_directory: T.unsafe(nil), force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

    # Creates directories at the paths in the given +list+
    # (a single path or an array of paths),
    # also creating ancestor directories as needed;
    # returns +list+ if it is an array, <tt>[list]</tt> otherwise.
    #
    # Argument +list+ or its elements
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # With no keyword arguments, creates a directory at each +path+ in +list+,
    # along with any needed ancestor directories,
    # by calling: <tt>Dir.mkdir(path, mode)</tt>;
    # see {Dir.mkdir}[https://docs.ruby-lang.org/en/master/Dir.html#method-c-mkdir]:
    #
    #   FileUtils.mkdir_p(%w[tmp0/tmp1 tmp2/tmp3]) # => ["tmp0/tmp1", "tmp2/tmp3"]
    #   FileUtils.mkdir_p('tmp4/tmp5')             # => ["tmp4/tmp5"]
    #
    # Keyword arguments:
    #
    # - <tt>mode: <i>mode</i></tt> - also calls <tt>File.chmod(mode, path)</tt>;
    #   see {File.chmod}[https://docs.ruby-lang.org/en/master/File.html#method-c-chmod].
    # - <tt>noop: true</tt> - does not create directories.
    # - <tt>verbose: true</tt> - prints an equivalent command:
    #
    #     FileUtils.mkdir_p(%w[tmp0 tmp1], verbose: true)
    #     FileUtils.mkdir_p(%w[tmp2 tmp3], mode: 0700, verbose: true)
    #
    #   Output:
    #
    #     mkdir -p tmp0 tmp1
    #     mkdir -p -m 700 tmp2 tmp3
    #
    # Raises an exception if for any reason a directory cannot be created.
    #
    # FileUtils.mkpath and FileUtils.makedirs are aliases for FileUtils.mkdir_p.
    #
    # Related: FileUtils.mkdir.
    #
    # source://fileutils//lib/fileutils.rb#366
    def makedirs(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

    # Creates directories at the paths in the given +list+
    # (a single path or an array of paths);
    # returns +list+ if it is an array, <tt>[list]</tt> otherwise.
    #
    # Argument +list+ or its elements
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # With no keyword arguments, creates a directory at each +path+ in +list+
    # by calling: <tt>Dir.mkdir(path, mode)</tt>;
    # see {Dir.mkdir}[https://docs.ruby-lang.org/en/master/Dir.html#method-c-mkdir]:
    #
    #   FileUtils.mkdir(%w[tmp0 tmp1]) # => ["tmp0", "tmp1"]
    #   FileUtils.mkdir('tmp4')        # => ["tmp4"]
    #
    # Keyword arguments:
    #
    # - <tt>mode: <i>mode</i></tt> - also calls <tt>File.chmod(mode, path)</tt>;
    #   see {File.chmod}[https://docs.ruby-lang.org/en/master/File.html#method-c-chmod].
    # - <tt>noop: true</tt> - does not create directories.
    # - <tt>verbose: true</tt> - prints an equivalent command:
    #
    #     FileUtils.mkdir(%w[tmp0 tmp1], verbose: true)
    #     FileUtils.mkdir(%w[tmp2 tmp3], mode: 0700, verbose: true)
    #
    #   Output:
    #
    #     mkdir tmp0 tmp1
    #     mkdir -m 700 tmp2 tmp3
    #
    # Raises an exception if any path points to an existing
    # file or directory, or if for any reason a directory cannot be created.
    #
    # Related: FileUtils.mkdir_p.
    #
    # source://fileutils//lib/fileutils.rb#317
    def mkdir(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

    # Creates directories at the paths in the given +list+
    # (a single path or an array of paths),
    # also creating ancestor directories as needed;
    # returns +list+ if it is an array, <tt>[list]</tt> otherwise.
    #
    # Argument +list+ or its elements
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # With no keyword arguments, creates a directory at each +path+ in +list+,
    # along with any needed ancestor directories,
    # by calling: <tt>Dir.mkdir(path, mode)</tt>;
    # see {Dir.mkdir}[https://docs.ruby-lang.org/en/master/Dir.html#method-c-mkdir]:
    #
    #   FileUtils.mkdir_p(%w[tmp0/tmp1 tmp2/tmp3]) # => ["tmp0/tmp1", "tmp2/tmp3"]
    #   FileUtils.mkdir_p('tmp4/tmp5')             # => ["tmp4/tmp5"]
    #
    # Keyword arguments:
    #
    # - <tt>mode: <i>mode</i></tt> - also calls <tt>File.chmod(mode, path)</tt>;
    #   see {File.chmod}[https://docs.ruby-lang.org/en/master/File.html#method-c-chmod].
    # - <tt>noop: true</tt> - does not create directories.
    # - <tt>verbose: true</tt> - prints an equivalent command:
    #
    #     FileUtils.mkdir_p(%w[tmp0 tmp1], verbose: true)
    #     FileUtils.mkdir_p(%w[tmp2 tmp3], mode: 0700, verbose: true)
    #
    #   Output:
    #
    #     mkdir -p tmp0 tmp1
    #     mkdir -p -m 700 tmp2 tmp3
    #
    # Raises an exception if for any reason a directory cannot be created.
    #
    # FileUtils.mkpath and FileUtils.makedirs are aliases for FileUtils.mkdir_p.
    #
    # Related: FileUtils.mkdir.
    #
    # source://fileutils//lib/fileutils.rb#366
    def mkdir_p(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

    # Creates directories at the paths in the given +list+
    # (a single path or an array of paths),
    # also creating ancestor directories as needed;
    # returns +list+ if it is an array, <tt>[list]</tt> otherwise.
    #
    # Argument +list+ or its elements
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # With no keyword arguments, creates a directory at each +path+ in +list+,
    # along with any needed ancestor directories,
    # by calling: <tt>Dir.mkdir(path, mode)</tt>;
    # see {Dir.mkdir}[https://docs.ruby-lang.org/en/master/Dir.html#method-c-mkdir]:
    #
    #   FileUtils.mkdir_p(%w[tmp0/tmp1 tmp2/tmp3]) # => ["tmp0/tmp1", "tmp2/tmp3"]
    #   FileUtils.mkdir_p('tmp4/tmp5')             # => ["tmp4/tmp5"]
    #
    # Keyword arguments:
    #
    # - <tt>mode: <i>mode</i></tt> - also calls <tt>File.chmod(mode, path)</tt>;
    #   see {File.chmod}[https://docs.ruby-lang.org/en/master/File.html#method-c-chmod].
    # - <tt>noop: true</tt> - does not create directories.
    # - <tt>verbose: true</tt> - prints an equivalent command:
    #
    #     FileUtils.mkdir_p(%w[tmp0 tmp1], verbose: true)
    #     FileUtils.mkdir_p(%w[tmp2 tmp3], mode: 0700, verbose: true)
    #
    #   Output:
    #
    #     mkdir -p tmp0 tmp1
    #     mkdir -p -m 700 tmp2 tmp3
    #
    # Raises an exception if for any reason a directory cannot be created.
    #
    # FileUtils.mkpath and FileUtils.makedirs are aliases for FileUtils.mkdir_p.
    #
    # Related: FileUtils.mkdir.
    #
    # source://fileutils//lib/fileutils.rb#366
    def mkpath(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

    # Moves entries.
    #
    # Arguments +src+ (a single path or an array of paths)
    # and +dest+ (a single path)
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # If +src+ and +dest+ are on different file systems,
    # first copies, then removes +src+.
    #
    # May cause a local vulnerability if not called with keyword argument
    # <tt>secure: true</tt>;
    # see {Avoiding the TOCTTOU Vulnerability}[rdoc-ref:FileUtils@Avoiding+the+TOCTTOU+Vulnerability].
    #
    # If +src+ is the path to a single file or directory and +dest+ does not exist,
    # moves +src+ to +dest+:
    #
    #   tree('src0')
    #   # => src0
    #   #    |-- src0.txt
    #   #    `-- src1.txt
    #   File.exist?('dest0') # => false
    #   FileUtils.mv('src0', 'dest0')
    #   File.exist?('src0')  # => false
    #   tree('dest0')
    #   # => dest0
    #   #    |-- src0.txt
    #   #    `-- src1.txt
    #
    # If +src+ is an array of paths to files and directories
    # and +dest+ is the path to a directory,
    # copies from each path in the array to +dest+:
    #
    #   File.file?('src1.txt') # => true
    #   tree('src1')
    #   # => src1
    #   #    |-- src.dat
    #   #    `-- src.txt
    #   Dir.empty?('dest1')    # => true
    #   FileUtils.mv(['src1.txt', 'src1'], 'dest1')
    #   tree('dest1')
    #   # => dest1
    #   #    |-- src1
    #   #    |   |-- src.dat
    #   #    |   `-- src.txt
    #   #    `-- src1.txt
    #
    # Keyword arguments:
    #
    # - <tt>force: true</tt> - if the move includes removing +src+
    #   (that is, if +src+ and +dest+ are on different file systems),
    #   ignores raised exceptions of StandardError and its descendants.
    # - <tt>noop: true</tt> - does not move files.
    # - <tt>secure: true</tt> - removes +src+ securely;
    #   see details at FileUtils.remove_entry_secure.
    # - <tt>verbose: true</tt> - prints an equivalent command:
    #
    #     FileUtils.mv('src0', 'dest0', noop: true, verbose: true)
    #     FileUtils.mv(['src1.txt', 'src1'], 'dest1', noop: true, verbose: true)
    #
    #   Output:
    #
    #     mv src0 dest0
    #     mv src1.txt src1 dest1
    #
    # source://fileutils//lib/fileutils.rb#1158
    def move(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

    # Moves entries.
    #
    # Arguments +src+ (a single path or an array of paths)
    # and +dest+ (a single path)
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # If +src+ and +dest+ are on different file systems,
    # first copies, then removes +src+.
    #
    # May cause a local vulnerability if not called with keyword argument
    # <tt>secure: true</tt>;
    # see {Avoiding the TOCTTOU Vulnerability}[rdoc-ref:FileUtils@Avoiding+the+TOCTTOU+Vulnerability].
    #
    # If +src+ is the path to a single file or directory and +dest+ does not exist,
    # moves +src+ to +dest+:
    #
    #   tree('src0')
    #   # => src0
    #   #    |-- src0.txt
    #   #    `-- src1.txt
    #   File.exist?('dest0') # => false
    #   FileUtils.mv('src0', 'dest0')
    #   File.exist?('src0')  # => false
    #   tree('dest0')
    #   # => dest0
    #   #    |-- src0.txt
    #   #    `-- src1.txt
    #
    # If +src+ is an array of paths to files and directories
    # and +dest+ is the path to a directory,
    # copies from each path in the array to +dest+:
    #
    #   File.file?('src1.txt') # => true
    #   tree('src1')
    #   # => src1
    #   #    |-- src.dat
    #   #    `-- src.txt
    #   Dir.empty?('dest1')    # => true
    #   FileUtils.mv(['src1.txt', 'src1'], 'dest1')
    #   tree('dest1')
    #   # => dest1
    #   #    |-- src1
    #   #    |   |-- src.dat
    #   #    |   `-- src.txt
    #   #    `-- src1.txt
    #
    # Keyword arguments:
    #
    # - <tt>force: true</tt> - if the move includes removing +src+
    #   (that is, if +src+ and +dest+ are on different file systems),
    #   ignores raised exceptions of StandardError and its descendants.
    # - <tt>noop: true</tt> - does not move files.
    # - <tt>secure: true</tt> - removes +src+ securely;
    #   see details at FileUtils.remove_entry_secure.
    # - <tt>verbose: true</tt> - prints an equivalent command:
    #
    #     FileUtils.mv('src0', 'dest0', noop: true, verbose: true)
    #     FileUtils.mv(['src1.txt', 'src1'], 'dest1', noop: true, verbose: true)
    #
    #   Output:
    #
    #     mv src0 dest0
    #     mv src1.txt src1 dest1
    #
    # source://fileutils//lib/fileutils.rb#1158
    def mv(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

    # Returns an array of the string keyword names:
    #
    #   FileUtils.options.take(3) # => ["noop", "verbose", "force"]
    #
    # source://fileutils//lib/fileutils.rb#2580
    def options; end

    # Returns an array of the string keyword name for method +mid+;
    # the argument may be a string or a symbol:
    #
    #   FileUtils.options_of(:rm) # => ["force", "noop", "verbose"]
    #   FileUtils.options_of('mv') # => ["force", "noop", "verbose", "secure"]
    #
    # source://fileutils//lib/fileutils.rb#2601
    def options_of(mid); end

    # source://fileutils//lib/fileutils.rb#186
    def private_module_function(name); end

    # Returns a string containing the path to the current directory:
    #
    #   FileUtils.pwd # => "/rdoc/fileutils"
    #
    # Related: FileUtils.cd.
    #
    # source://fileutils//lib/fileutils.rb#198
    def pwd; end

    # Removes entries at the paths in the given +list+
    # (a single path or an array of paths)
    # returns +list+, if it is an array, <tt>[list]</tt> otherwise.
    #
    # Argument +list+ or its elements
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # With no keyword arguments, removes files at the paths given in +list+:
    #
    #   FileUtils.touch(['src0.txt', 'src0.dat'])
    #   FileUtils.rm(['src0.dat', 'src0.txt']) # => ["src0.dat", "src0.txt"]
    #
    # Keyword arguments:
    #
    # - <tt>force: true</tt> - ignores raised exceptions of StandardError
    #   and its descendants.
    # - <tt>noop: true</tt> - does not remove files; returns +nil+.
    # - <tt>verbose: true</tt> - prints an equivalent command:
    #
    #     FileUtils.rm(['src0.dat', 'src0.txt'], noop: true, verbose: true)
    #
    #   Output:
    #
    #     rm src0.dat src0.txt
    #
    # Related: {methods for deleting}[rdoc-ref:FileUtils@Deleting].
    #
    # source://fileutils//lib/fileutils.rb#1217
    def remove(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

    # Recursively removes the directory entry given by +path+,
    # which should be the entry for a regular file, a symbolic link,
    # or a directory.
    #
    # Argument +path+
    # should be {interpretable as a path}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # Optional argument +force+ specifies whether to ignore
    # raised exceptions of StandardError and its descendants.
    #
    # Related: {methods for deleting}[rdoc-ref:FileUtils@Deleting].
    #
    # source://fileutils//lib/fileutils.rb#1493
    def remove_dir(path, force = T.unsafe(nil)); end

    # Removes the entry given by +path+,
    # which should be the entry for a regular file, a symbolic link,
    # or a directory.
    #
    # Argument +path+
    # should be {interpretable as a path}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # Optional argument +force+ specifies whether to ignore
    # raised exceptions of StandardError and its descendants.
    #
    # Related: FileUtils.remove_entry_secure.
    #
    # source://fileutils//lib/fileutils.rb#1450
    def remove_entry(path, force = T.unsafe(nil)); end

    # Securely removes the entry given by +path+,
    # which should be the entry for a regular file, a symbolic link,
    # or a directory.
    #
    # Argument +path+
    # should be {interpretable as a path}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # Avoids a local vulnerability that can exist in certain circumstances;
    # see {Avoiding the TOCTTOU Vulnerability}[rdoc-ref:FileUtils@Avoiding+the+TOCTTOU+Vulnerability].
    #
    # Optional argument +force+ specifies whether to ignore
    # raised exceptions of StandardError and its descendants.
    #
    # Related: {methods for deleting}[rdoc-ref:FileUtils@Deleting].
    #
    # source://fileutils//lib/fileutils.rb#1352
    def remove_entry_secure(path, force = T.unsafe(nil)); end

    # Removes the file entry given by +path+,
    # which should be the entry for a regular file or a symbolic link.
    #
    # Argument +path+
    # should be {interpretable as a path}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # Optional argument +force+ specifies whether to ignore
    # raised exceptions of StandardError and its descendants.
    #
    # Related: {methods for deleting}[rdoc-ref:FileUtils@Deleting].
    #
    # source://fileutils//lib/fileutils.rb#1474
    def remove_file(path, force = T.unsafe(nil)); end

    # Removes entries at the paths in the given +list+
    # (a single path or an array of paths)
    # returns +list+, if it is an array, <tt>[list]</tt> otherwise.
    #
    # Argument +list+ or its elements
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # With no keyword arguments, removes files at the paths given in +list+:
    #
    #   FileUtils.touch(['src0.txt', 'src0.dat'])
    #   FileUtils.rm(['src0.dat', 'src0.txt']) # => ["src0.dat", "src0.txt"]
    #
    # Keyword arguments:
    #
    # - <tt>force: true</tt> - ignores raised exceptions of StandardError
    #   and its descendants.
    # - <tt>noop: true</tt> - does not remove files; returns +nil+.
    # - <tt>verbose: true</tt> - prints an equivalent command:
    #
    #     FileUtils.rm(['src0.dat', 'src0.txt'], noop: true, verbose: true)
    #
    #   Output:
    #
    #     rm src0.dat src0.txt
    #
    # Related: {methods for deleting}[rdoc-ref:FileUtils@Deleting].
    #
    # source://fileutils//lib/fileutils.rb#1217
    def rm(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

    # Equivalent to:
    #
    #   FileUtils.rm(list, force: true, **kwargs)
    #
    # Argument +list+ (a single path or an array of paths)
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # See FileUtils.rm for keyword arguments.
    #
    # Related: {methods for deleting}[rdoc-ref:FileUtils@Deleting].
    #
    # source://fileutils//lib/fileutils.rb#1242
    def rm_f(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

    # Removes entries at the paths in the given +list+
    # (a single path or an array of paths);
    # returns +list+, if it is an array, <tt>[list]</tt> otherwise.
    #
    # Argument +list+ or its elements
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # May cause a local vulnerability if not called with keyword argument
    # <tt>secure: true</tt>;
    # see {Avoiding the TOCTTOU Vulnerability}[rdoc-ref:FileUtils@Avoiding+the+TOCTTOU+Vulnerability].
    #
    # For each file path, removes the file at that path:
    #
    #   FileUtils.touch(['src0.txt', 'src0.dat'])
    #   FileUtils.rm_r(['src0.dat', 'src0.txt'])
    #   File.exist?('src0.txt') # => false
    #   File.exist?('src0.dat') # => false
    #
    # For each directory path, recursively removes files and directories:
    #
    #   tree('src1')
    #   # => src1
    #   #    |-- dir0
    #   #    |   |-- src0.txt
    #   #    |   `-- src1.txt
    #   #    `-- dir1
    #   #        |-- src2.txt
    #   #        `-- src3.txt
    #   FileUtils.rm_r('src1')
    #   File.exist?('src1') # => false
    #
    # Keyword arguments:
    #
    # - <tt>force: true</tt> - ignores raised exceptions of StandardError
    #   and its descendants.
    # - <tt>noop: true</tt> - does not remove entries; returns +nil+.
    # - <tt>secure: true</tt> - removes +src+ securely;
    #   see details at FileUtils.remove_entry_secure.
    # - <tt>verbose: true</tt> - prints an equivalent command:
    #
    #     FileUtils.rm_r(['src0.dat', 'src0.txt'], noop: true, verbose: true)
    #     FileUtils.rm_r('src1', noop: true, verbose: true)
    #
    #   Output:
    #
    #     rm -r src0.dat src0.txt
    #     rm -r src1
    #
    # Related: {methods for deleting}[rdoc-ref:FileUtils@Deleting].
    #
    # source://fileutils//lib/fileutils.rb#1300
    def rm_r(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

    # Equivalent to:
    #
    #   FileUtils.rm_r(list, force: true, **kwargs)
    #
    # Argument +list+ or its elements
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # May cause a local vulnerability if not called with keyword argument
    # <tt>secure: true</tt>;
    # see {Avoiding the TOCTTOU Vulnerability}[rdoc-ref:FileUtils@Avoiding+the+TOCTTOU+Vulnerability].
    #
    # See FileUtils.rm_r for keyword arguments.
    #
    # Related: {methods for deleting}[rdoc-ref:FileUtils@Deleting].
    #
    # source://fileutils//lib/fileutils.rb#1329
    def rm_rf(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

    # Removes directories at the paths in the given +list+
    # (a single path or an array of paths);
    # returns +list+, if it is an array, <tt>[list]</tt> otherwise.
    #
    # Argument +list+ or its elements
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # With no keyword arguments, removes the directory at each +path+ in +list+,
    # by calling: <tt>Dir.rmdir(path)</tt>;
    # see {Dir.rmdir}[https://docs.ruby-lang.org/en/master/Dir.html#method-c-rmdir]:
    #
    #   FileUtils.rmdir(%w[tmp0/tmp1 tmp2/tmp3]) # => ["tmp0/tmp1", "tmp2/tmp3"]
    #   FileUtils.rmdir('tmp4/tmp5')             # => ["tmp4/tmp5"]
    #
    # Keyword arguments:
    #
    # - <tt>parents: true</tt> - removes successive ancestor directories
    #   if empty.
    # - <tt>noop: true</tt> - does not remove directories.
    # - <tt>verbose: true</tt> - prints an equivalent command:
    #
    #     FileUtils.rmdir(%w[tmp0/tmp1 tmp2/tmp3], parents: true, verbose: true)
    #     FileUtils.rmdir('tmp4/tmp5', parents: true, verbose: true)
    #
    #   Output:
    #
    #     rmdir -p tmp0/tmp1 tmp2/tmp3
    #     rmdir -p tmp4/tmp5
    #
    # Raises an exception if a directory does not exist
    # or if for any reason a directory cannot be removed.
    #
    # Related: {methods for deleting}[rdoc-ref:FileUtils@Deleting].
    #
    # source://fileutils//lib/fileutils.rb#443
    def rmdir(list, parents: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

    # Equivalent to:
    #
    #   FileUtils.rm_r(list, force: true, **kwargs)
    #
    # Argument +list+ or its elements
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # May cause a local vulnerability if not called with keyword argument
    # <tt>secure: true</tt>;
    # see {Avoiding the TOCTTOU Vulnerability}[rdoc-ref:FileUtils@Avoiding+the+TOCTTOU+Vulnerability].
    #
    # See FileUtils.rm_r for keyword arguments.
    #
    # Related: {methods for deleting}[rdoc-ref:FileUtils@Deleting].
    #
    # source://fileutils//lib/fileutils.rb#1329
    def rmtree(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

    # Equivalent to:
    #
    #   FileUtils.rm(list, force: true, **kwargs)
    #
    # Argument +list+ (a single path or an array of paths)
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # See FileUtils.rm for keyword arguments.
    #
    # Related: {methods for deleting}[rdoc-ref:FileUtils@Deleting].
    #
    # source://fileutils//lib/fileutils.rb#1242
    def safe_unlink(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

    # Creates {symbolic links}[https://en.wikipedia.org/wiki/Symbolic_link].
    #
    # Arguments +src+ (a single path or an array of paths)
    # and +dest+ (a single path)
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # If +src+ is the path to an existing file:
    #
    # - When +dest+ is the path to a non-existent file,
    #   creates a symbolic link at +dest+ pointing to +src+:
    #
    #     FileUtils.touch('src0.txt')
    #     File.exist?('dest0.txt')   # => false
    #     FileUtils.ln_s('src0.txt', 'dest0.txt')
    #     File.symlink?('dest0.txt') # => true
    #
    # - When +dest+ is the path to an existing file,
    #   creates a symbolic link at +dest+ pointing to +src+
    #   if and only if keyword argument <tt>force: true</tt> is given
    #   (raises an exception otherwise):
    #
    #     FileUtils.touch('src1.txt')
    #     FileUtils.touch('dest1.txt')
    #     FileUtils.ln_s('src1.txt', 'dest1.txt', force: true)
    #     FileTest.symlink?('dest1.txt') # => true
    #
    #     FileUtils.ln_s('src1.txt', 'dest1.txt') # Raises Errno::EEXIST.
    #
    # If +dest+ is the path to a directory,
    # creates a symbolic link at <tt>dest/src</tt> pointing to +src+:
    #
    #   FileUtils.touch('src2.txt')
    #   FileUtils.mkdir('destdir2')
    #   FileUtils.ln_s('src2.txt', 'destdir2')
    #   File.symlink?('destdir2/src2.txt') # => true
    #
    # If +src+ is an array of paths to existing files and +dest+ is a directory,
    # for each child +child+ in +src+ creates a symbolic link <tt>dest/child</tt>
    # pointing to +child+:
    #
    #   FileUtils.mkdir('srcdir3')
    #   FileUtils.touch('srcdir3/src0.txt')
    #   FileUtils.touch('srcdir3/src1.txt')
    #   FileUtils.mkdir('destdir3')
    #   FileUtils.ln_s(['srcdir3/src0.txt', 'srcdir3/src1.txt'], 'destdir3')
    #   File.symlink?('destdir3/src0.txt') # => true
    #   File.symlink?('destdir3/src1.txt') # => true
    #
    # Keyword arguments:
    #
    # - <tt>force: true</tt> - overwrites +dest+ if it exists.
    # - <tt>relative: false</tt> - create links relative to +dest+.
    # - <tt>noop: true</tt> - does not create links.
    # - <tt>verbose: true</tt> - prints an equivalent command:
    #
    #     FileUtils.ln_s('src0.txt', 'dest0.txt', noop: true, verbose: true)
    #     FileUtils.ln_s('src1.txt', 'destdir1', noop: true, verbose: true)
    #     FileUtils.ln_s('src2.txt', 'dest2.txt', force: true, noop: true, verbose: true)
    #     FileUtils.ln_s(['srcdir3/src0.txt', 'srcdir3/src1.txt'], 'destdir3', noop: true, verbose: true)
    #
    #   Output:
    #
    #     ln -s src0.txt dest0.txt
    #     ln -s src1.txt destdir1
    #     ln -sf src2.txt dest2.txt
    #     ln -s srcdir3/src0.txt srcdir3/src1.txt destdir3
    #
    # Related: FileUtils.ln_sf.
    #
    # source://fileutils//lib/fileutils.rb#707
    def symlink(src, dest, force: T.unsafe(nil), relative: T.unsafe(nil), target_directory: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

    # Updates modification times (mtime) and access times (atime)
    # of the entries given by the paths in +list+
    # (a single path or an array of paths);
    # returns +list+ if it is an array, <tt>[list]</tt> otherwise.
    #
    # By default, creates an empty file for any path to a non-existent entry;
    # use keyword argument +nocreate+ to raise an exception instead.
    #
    # Argument +list+ or its elements
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments].
    #
    # Examples:
    #
    #   # Single path.
    #   f = File.new('src0.txt') # Existing file.
    #   f.atime # => 2022-06-10 11:11:21.200277 -0700
    #   f.mtime # => 2022-06-10 11:11:21.200277 -0700
    #   FileUtils.touch('src0.txt')
    #   f = File.new('src0.txt')
    #   f.atime # => 2022-06-11 08:28:09.8185343 -0700
    #   f.mtime # => 2022-06-11 08:28:09.8185343 -0700
    #
    #   # Array of paths.
    #   FileUtils.touch(['src0.txt', 'src0.dat'])
    #
    # Keyword arguments:
    #
    # - <tt>mtime: <i>time</i></tt> - sets the entry's mtime to the given time,
    #   instead of the current time.
    # - <tt>nocreate: true</tt> - raises an exception if the entry does not exist.
    # - <tt>noop: true</tt> - does not touch entries; returns +nil+.
    # - <tt>verbose: true</tt> - prints an equivalent command:
    #
    #     FileUtils.touch('src0.txt', noop: true, verbose: true)
    #     FileUtils.touch(['src0.txt', 'src0.dat'], noop: true, verbose: true)
    #     FileUtils.touch(path, noop: true, verbose: true)
    #
    #   Output:
    #
    #     touch src0.txt
    #     touch src0.txt src0.dat
    #     touch src0.txt
    #
    # Related: FileUtils.uptodate?.
    #
    # source://fileutils//lib/fileutils.rb#2007
    def touch(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), mtime: T.unsafe(nil), nocreate: T.unsafe(nil)); end

    # Returns +true+ if the file at path +new+
    # is newer than all the files at paths in array +old_list+;
    # +false+ otherwise.
    #
    # Argument +new+ and the elements of +old_list+
    # should be {interpretable as paths}[rdoc-ref:FileUtils@Path+Arguments]:
    #
    #   FileUtils.uptodate?('Rakefile', ['Gemfile', 'README.md']) # => true
    #   FileUtils.uptodate?('Gemfile', ['Rakefile', 'README.md']) # => false
    #
    # A non-existent file is considered to be infinitely old.
    #
    # Related: FileUtils.touch.
    #
    # @return [Boolean]
    #
    # source://fileutils//lib/fileutils.rb#265
    def uptodate?(new, old_list); end

    private

    # source://fileutils//lib/fileutils.rb#1661
    def apply_mask(mode, user_mask, op, mode_mask); end

    # source://fileutils//lib/fileutils.rb#2529
    def fu_clean_components(*comp); end

    # source://fileutils//lib/fileutils.rb#2468
    def fu_each_src_dest(src, dest); end

    # source://fileutils//lib/fileutils.rb#2476
    def fu_each_src_dest0(src, dest, target_directory = T.unsafe(nil)); end

    # source://fileutils//lib/fileutils.rb#1948
    def fu_get_gid(group); end

    # source://fileutils//lib/fileutils.rb#1934
    def fu_get_uid(user); end

    # source://fileutils//lib/fileutils.rb#1424
    def fu_have_symlink?; end

    # source://fileutils//lib/fileutils.rb#2463
    def fu_list(arg); end

    # source://fileutils//lib/fileutils.rb#397
    def fu_mkdir(path, mode); end

    # source://fileutils//lib/fileutils.rb#1722
    def fu_mode(mode, path); end

    # source://fileutils//lib/fileutils.rb#2498
    def fu_output_message(msg); end

    # source://fileutils//lib/fileutils.rb#2520
    def fu_relative_components_from(target, base); end

    # source://fileutils//lib/fileutils.rb#2493
    def fu_same?(a, b); end

    # source://fileutils//lib/fileutils.rb#2508
    def fu_split_path(path); end

    # source://fileutils//lib/fileutils.rb#2552
    def fu_starting_path?(path); end

    # source://fileutils//lib/fileutils.rb#1433
    def fu_stat_identical_entry?(a, b); end

    # source://fileutils//lib/fileutils.rb#1727
    def mode_to_s(mode); end

    # source://fileutils//lib/fileutils.rb#277
    def remove_trailing_slash(dir); end

    # source://fileutils//lib/fileutils.rb#1673
    def symbolic_modes_to_i(mode_sym, path); end

    # source://fileutils//lib/fileutils.rb#1643
    def user_mask(target); end
  end
end

# This module has all methods of FileUtils module, but never changes
# files/directories, with printing message before acting.
# This equates to passing the <tt>:noop</tt> and <tt>:verbose</tt> flag
# to methods in FileUtils.
#
# source://fileutils//lib/fileutils.rb#2678
module FileUtils::DryRun
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  include ::FileUtils::LowMethods
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils
  extend ::FileUtils::LowMethods
  extend ::FileUtils::DryRun

  private

  # source://fileutils//lib/fileutils.rb#2684
  def chmod(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def chmod_R(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def chown(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def chown_R(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def copy(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def cp(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def cp_lr(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def cp_r(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def install(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def link(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def ln(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def ln_s(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def ln_sf(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def ln_sr(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def makedirs(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def mkdir(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def mkdir_p(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def mkpath(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def move(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def mv(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def remove(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def rm(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def rm_f(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def rm_r(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def rm_rf(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def rmdir(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def rmtree(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def safe_unlink(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def symlink(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2684
  def touch(*args, **options); end

  class << self
    # source://fileutils//lib/fileutils.rb#2620
    def cd(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2620
    def chdir(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2684
    def chmod(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2684
    def chmod_R(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2684
    def chown(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2684
    def chown_R(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2620
    def cmp(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2620
    def compare_file(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2620
    def compare_stream(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2684
    def copy(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2620
    def copy_entry(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2620
    def copy_file(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2620
    def copy_stream(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2684
    def cp(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2684
    def cp_lr(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2684
    def cp_r(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2620
    def getwd(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2620
    def identical?(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2684
    def install(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2684
    def link(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2620
    def link_entry(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2684
    def ln(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2684
    def ln_s(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2684
    def ln_sf(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2684
    def ln_sr(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2684
    def makedirs(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2684
    def mkdir(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2684
    def mkdir_p(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2684
    def mkpath(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2684
    def move(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2684
    def mv(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2620
    def pwd(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2684
    def remove(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2620
    def remove_dir(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2620
    def remove_entry(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2620
    def remove_entry_secure(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2620
    def remove_file(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2684
    def rm(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2684
    def rm_f(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2684
    def rm_r(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2684
    def rm_rf(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2684
    def rmdir(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2684
    def rmtree(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2684
    def safe_unlink(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2684
    def symlink(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2684
    def touch(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2620
    def uptodate?(*_arg0); end
  end
end

# source://fileutils//lib/fileutils.rb#2071
class FileUtils::Entry_
  include ::FileUtils::StreamUtils_

  # @return [Entry_] a new instance of Entry_
  #
  # source://fileutils//lib/fileutils.rb#2074
  def initialize(a, b = T.unsafe(nil), deref = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://fileutils//lib/fileutils.rb#2140
  def blockdev?; end

  # @return [Boolean]
  #
  # source://fileutils//lib/fileutils.rb#2135
  def chardev?; end

  # source://fileutils//lib/fileutils.rb#2208
  def chmod(mode); end

  # source://fileutils//lib/fileutils.rb#2217
  def chown(uid, gid); end

  # source://fileutils//lib/fileutils.rb#2241
  def copy(dest); end

  # source://fileutils//lib/fileutils.rb#2279
  def copy_file(dest); end

  # source://fileutils//lib/fileutils.rb#2287
  def copy_metadata(path); end

  # @return [Boolean]
  #
  # source://fileutils//lib/fileutils.rb#2107
  def dereference?; end

  # @return [Boolean]
  #
  # source://fileutils//lib/fileutils.rb#2125
  def directory?; end

  # @return [Boolean]
  #
  # source://fileutils//lib/fileutils.rb#2157
  def door?; end

  # source://fileutils//lib/fileutils.rb#2162
  def entries; end

  # @return [Boolean]
  #
  # source://fileutils//lib/fileutils.rb#2111
  def exist?; end

  # @return [Boolean]
  #
  # source://fileutils//lib/fileutils.rb#2120
  def file?; end

  # source://fileutils//lib/fileutils.rb#2087
  def inspect; end

  # source://fileutils//lib/fileutils.rb#2225
  def link(dest); end

  # source://fileutils//lib/fileutils.rb#2194
  def lstat; end

  # source://fileutils//lib/fileutils.rb#2202
  def lstat!; end

  # source://fileutils//lib/fileutils.rb#2091
  def path; end

  # @return [Boolean]
  #
  # source://fileutils//lib/fileutils.rb#2150
  def pipe?; end

  # source://fileutils//lib/fileutils.rb#2336
  def platform_support; end

  # @yield [_self]
  # @yieldparam _self [FileUtils::Entry_] the object that the method was called on
  #
  # source://fileutils//lib/fileutils.rb#2366
  def postorder_traverse; end

  # source://fileutils//lib/fileutils.rb#2099
  def prefix; end

  # source://fileutils//lib/fileutils.rb#2356
  def preorder_traverse; end

  # source://fileutils//lib/fileutils.rb#2103
  def rel; end

  # source://fileutils//lib/fileutils.rb#2316
  def remove; end

  # source://fileutils//lib/fileutils.rb#2324
  def remove_dir1; end

  # source://fileutils//lib/fileutils.rb#2330
  def remove_file; end

  # @return [Boolean]
  #
  # source://fileutils//lib/fileutils.rb#2145
  def socket?; end

  # source://fileutils//lib/fileutils.rb#2172
  def stat; end

  # source://fileutils//lib/fileutils.rb#2182
  def stat!; end

  # @return [Boolean]
  #
  # source://fileutils//lib/fileutils.rb#2130
  def symlink?; end

  # source://fileutils//lib/fileutils.rb#2356
  def traverse; end

  # source://fileutils//lib/fileutils.rb#2386
  def wrap_traverse(pre, post); end

  private

  # @return [Boolean]
  #
  # source://fileutils//lib/fileutils.rb#2408
  def check_have_lchmod?; end

  # @return [Boolean]
  #
  # source://fileutils//lib/fileutils.rb#2426
  def check_have_lchown?; end

  # @return [Boolean]
  #
  # source://fileutils//lib/fileutils.rb#2454
  def descendant_directory?(descendant, ascendant); end

  # @return [Boolean]
  #
  # source://fileutils//lib/fileutils.rb#2400
  def have_lchmod?; end

  # @return [Boolean]
  #
  # source://fileutils//lib/fileutils.rb#2418
  def have_lchown?; end

  # source://fileutils//lib/fileutils.rb#2434
  def join(dir, base); end
end

# source://fileutils//lib/fileutils.rb#2618
module FileUtils::LowMethods
  private

  # source://fileutils//lib/fileutils.rb#2620
  def _do_nothing(*_arg0); end

  # source://fileutils//lib/fileutils.rb#2620
  def cd(*_arg0); end

  # source://fileutils//lib/fileutils.rb#2620
  def chdir(*_arg0); end

  # source://fileutils//lib/fileutils.rb#2620
  def cmp(*_arg0); end

  # source://fileutils//lib/fileutils.rb#2620
  def collect_method(*_arg0); end

  # source://fileutils//lib/fileutils.rb#2620
  def commands(*_arg0); end

  # source://fileutils//lib/fileutils.rb#2620
  def compare_file(*_arg0); end

  # source://fileutils//lib/fileutils.rb#2620
  def compare_stream(*_arg0); end

  # source://fileutils//lib/fileutils.rb#2620
  def copy_entry(*_arg0); end

  # source://fileutils//lib/fileutils.rb#2620
  def copy_file(*_arg0); end

  # source://fileutils//lib/fileutils.rb#2620
  def copy_stream(*_arg0); end

  # source://fileutils//lib/fileutils.rb#2620
  def getwd(*_arg0); end

  # source://fileutils//lib/fileutils.rb#2620
  def have_option?(*_arg0); end

  # source://fileutils//lib/fileutils.rb#2620
  def identical?(*_arg0); end

  # source://fileutils//lib/fileutils.rb#2620
  def link_entry(*_arg0); end

  # source://fileutils//lib/fileutils.rb#2620
  def options(*_arg0); end

  # source://fileutils//lib/fileutils.rb#2620
  def options_of(*_arg0); end

  # source://fileutils//lib/fileutils.rb#2620
  def private_module_function(*_arg0); end

  # source://fileutils//lib/fileutils.rb#2620
  def pwd(*_arg0); end

  # source://fileutils//lib/fileutils.rb#2620
  def remove_dir(*_arg0); end

  # source://fileutils//lib/fileutils.rb#2620
  def remove_entry(*_arg0); end

  # source://fileutils//lib/fileutils.rb#2620
  def remove_entry_secure(*_arg0); end

  # source://fileutils//lib/fileutils.rb#2620
  def remove_file(*_arg0); end

  # source://fileutils//lib/fileutils.rb#2620
  def uptodate?(*_arg0); end
end

# This module has all methods of FileUtils module, but never changes
# files/directories.  This equates to passing the <tt>:noop</tt> flag
# to methods in FileUtils.
#
# source://fileutils//lib/fileutils.rb#2654
module FileUtils::NoWrite
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  include ::FileUtils::LowMethods
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils
  extend ::FileUtils::LowMethods
  extend ::FileUtils::NoWrite

  private

  # source://fileutils//lib/fileutils.rb#2660
  def chmod(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def chmod_R(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def chown(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def chown_R(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def copy(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def cp(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def cp_lr(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def cp_r(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def install(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def link(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def ln(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def ln_s(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def ln_sf(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def ln_sr(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def makedirs(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def mkdir(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def mkdir_p(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def mkpath(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def move(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def mv(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def remove(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def rm(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def rm_f(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def rm_r(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def rm_rf(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def rmdir(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def rmtree(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def safe_unlink(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def symlink(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2660
  def touch(*args, **options); end

  class << self
    # source://fileutils//lib/fileutils.rb#2620
    def cd(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2620
    def chdir(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2660
    def chmod(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2660
    def chmod_R(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2660
    def chown(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2660
    def chown_R(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2620
    def cmp(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2620
    def compare_file(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2620
    def compare_stream(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2660
    def copy(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2620
    def copy_entry(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2620
    def copy_file(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2620
    def copy_stream(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2660
    def cp(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2660
    def cp_lr(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2660
    def cp_r(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2620
    def getwd(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2620
    def identical?(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2660
    def install(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2660
    def link(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2620
    def link_entry(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2660
    def ln(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2660
    def ln_s(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2660
    def ln_sf(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2660
    def ln_sr(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2660
    def makedirs(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2660
    def mkdir(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2660
    def mkdir_p(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2660
    def mkpath(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2660
    def move(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2660
    def mv(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2620
    def pwd(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2660
    def remove(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2620
    def remove_dir(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2620
    def remove_entry(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2620
    def remove_entry_secure(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2620
    def remove_file(*_arg0); end

    # source://fileutils//lib/fileutils.rb#2660
    def rm(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2660
    def rm_f(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2660
    def rm_r(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2660
    def rm_rf(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2660
    def rmdir(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2660
    def rmtree(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2660
    def safe_unlink(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2660
    def symlink(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2660
    def touch(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2620
    def uptodate?(*_arg0); end
  end
end

# source://fileutils//lib/fileutils.rb#2032
module FileUtils::StreamUtils_
  private

  # source://fileutils//lib/fileutils.rb#2056
  def fu_blksize(st); end

  # source://fileutils//lib/fileutils.rb#2043
  def fu_copy_stream0(src, dest, blksize = T.unsafe(nil)); end

  # source://fileutils//lib/fileutils.rb#2063
  def fu_default_blksize; end

  # source://fileutils//lib/fileutils.rb#2047
  def fu_stream_blksize(*streams); end

  # source://fileutils//lib/fileutils.rb#2040
  def fu_windows?; end
end

# This module has all methods of FileUtils module, but it outputs messages
# before acting.  This equates to passing the <tt>:verbose</tt> flag to
# methods in FileUtils.
#
# source://fileutils//lib/fileutils.rb#2632
module FileUtils::Verbose
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils
  extend ::FileUtils::Verbose

  private

  # source://fileutils//lib/fileutils.rb#2637
  def cd(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def chdir(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def chmod(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def chmod_R(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def chown(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def chown_R(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def copy(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def cp(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def cp_lr(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def cp_r(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def install(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def link(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def ln(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def ln_s(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def ln_sf(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def ln_sr(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def makedirs(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def mkdir(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def mkdir_p(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def mkpath(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def move(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def mv(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def remove(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def rm(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def rm_f(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def rm_r(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def rm_rf(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def rmdir(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def rmtree(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def safe_unlink(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def symlink(*args, **options); end

  # source://fileutils//lib/fileutils.rb#2637
  def touch(*args, **options); end

  class << self
    # source://fileutils//lib/fileutils.rb#2637
    def cd(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2637
    def chdir(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2637
    def chmod(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2637
    def chmod_R(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2637
    def chown(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2637
    def chown_R(*args, **options); end

    # source://fileutils//lib/fileutils.rb#1508
    def cmp(a, b); end

    # source://fileutils//lib/fileutils.rb#1508
    def compare_file(a, b); end

    # source://fileutils//lib/fileutils.rb#1531
    def compare_stream(a, b); end

    # source://fileutils//lib/fileutils.rb#2637
    def copy(*args, **options); end

    # source://fileutils//lib/fileutils.rb#1041
    def copy_entry(src, dest, preserve = T.unsafe(nil), dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end

    # source://fileutils//lib/fileutils.rb#1077
    def copy_file(src, dest, preserve = T.unsafe(nil), dereference = T.unsafe(nil)); end

    # source://fileutils//lib/fileutils.rb#1089
    def copy_stream(src, dest); end

    # source://fileutils//lib/fileutils.rb#2637
    def cp(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2637
    def cp_lr(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2637
    def cp_r(*args, **options); end

    # source://fileutils//lib/fileutils.rb#198
    def getwd; end

    # source://fileutils//lib/fileutils.rb#1508
    def identical?(a, b); end

    # source://fileutils//lib/fileutils.rb#2637
    def install(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2637
    def link(*args, **options); end

    # source://fileutils//lib/fileutils.rb#813
    def link_entry(src, dest, dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end

    # source://fileutils//lib/fileutils.rb#2637
    def ln(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2637
    def ln_s(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2637
    def ln_sf(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2637
    def ln_sr(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2637
    def makedirs(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2637
    def mkdir(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2637
    def mkdir_p(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2637
    def mkpath(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2637
    def move(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2637
    def mv(*args, **options); end

    # source://fileutils//lib/fileutils.rb#198
    def pwd; end

    # source://fileutils//lib/fileutils.rb#2637
    def remove(*args, **options); end

    # source://fileutils//lib/fileutils.rb#1493
    def remove_dir(path, force = T.unsafe(nil)); end

    # source://fileutils//lib/fileutils.rb#1450
    def remove_entry(path, force = T.unsafe(nil)); end

    # source://fileutils//lib/fileutils.rb#1352
    def remove_entry_secure(path, force = T.unsafe(nil)); end

    # source://fileutils//lib/fileutils.rb#1474
    def remove_file(path, force = T.unsafe(nil)); end

    # source://fileutils//lib/fileutils.rb#2637
    def rm(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2637
    def rm_f(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2637
    def rm_r(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2637
    def rm_rf(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2637
    def rmdir(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2637
    def rmtree(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2637
    def safe_unlink(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2637
    def symlink(*args, **options); end

    # source://fileutils//lib/fileutils.rb#2637
    def touch(*args, **options); end

    # source://fileutils//lib/fileutils.rb#265
    def uptodate?(new, old_list); end
  end
end
